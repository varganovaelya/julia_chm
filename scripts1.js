const JSON_content = {
        topic01: {
        "title": "Теория погрешностей",
        "theory": `
	<h1><i>Теория погрешностей</i></h1>
        <h2><i>Виды погрешностей</i></h1>\n
	<p>Решение многих инженерных задач начинается с перехода от реального объекта к его математической модели. При этом не учитываются те факторы, 
которые не оказывают существенного влияния на изучаемый объект. Математическая модель записывается в форме уравнений (алгебраических, дифференциальных, интегральных), 
основанных на различных физических законах. Например, в задачах строительства математическая модель отождествляется с расчетной схемой сооружения. Для решения таких 
задач необходимо использовать тот или иной численный метод.</p>\n
	<p><font color='#ff0000'>Под численным методом</font> понимается такой вычислительный алгоритм, который позволяет 
получить решение в виде числа или таблицы чисел.</p>\n
	<p>Полученные результаты анализируются с точки зрения их соответствия исследуемому объекту и, в случае необходимости, корректируется либо численный метод, 
либо математическая модель.</p>\n
	<p><b>В курсе численных методов</b> рассматриваются вопросы разработки, использования и теоретического обоснования алгоритмов приближенного решения различных математических задач.</p>\n
	<p>В процессе решения задач численным методом получается приближенный результат, потому что на каждом этапе возникают некоторые погрешности.</p>\n	
	<p>Под <font color='#ff0000'>погрешностью</font> понимается некоторая величина, характеризующая точность результата.</p>\n

	<h2><font color='#ff9100'>Существуют три вида погрешностей:</font></h2>\n
	<ul>\n<li>неустранимая погрешность (возникает из-за неточности исходной информации, например, неточности измерений);</li>\n    
              <li>погрешность метода (применяемый численный метод дает приближенное решение);</li>\n    
	      <li>погрешность вычислений (возникает из-за округления чисел).</li>\n</ul>\n
	<p>Основная (прямая) задача теории погрешностей &mdash; указание области неопределенности результата, то есть нужно определить по известным погрешностям параметров 
погрешность функции от этих параметров.</p>\n\n
	
	<h1><i>Типы погрешностей</i></h1>\n
	<p>Пусть \\(x^{*}\\) &mdash; точное (как правило, неизвестное) значение величины</p>\n
	<p>\\(x\\) &mdash; приближенное значение этой величины.</p>\n
	<p><font color='#ff0000'>Абсолютной погрешностью</font> приближенного числа \\(x\\) называется абсолютная величина разности между точным и приближенным числами:</p>\n
	\\[\\Delta=\\left| x^{*}-x \\right|\\tag{1.1}\\]\n
	<p>На практике точное значение величины часто бывает неизвестно. Поэтому найти абсолютную погрешность невозможно. Но необходимо уметь <b>оценить</b> абсолютную погрешность, 
то есть указать число, которого не может превысить абсолютная погрешность.</p>\t\n
	<h3>На Julia для абсолютной погрешности есть встроенная функция:</h3>
		<div class="code-container">
       		 <div class="code-header">
            		Абсолютная погрешность
           		 <span class="language-label">JULIA</span>
        	 </div>
       		 <pre><code class="language-julia">using Measurements

# Создание измерения с абсолютной погрешностью
а = measurement(2.8934, 0.0003)

# Получение абсолютной погрешности
Δ_а = Measurements.uncertainty(а) </code></pre>
	        </div>

	<p><font color='#ff0000'>Предельной абсолютной погрешностью</font> приближенного числа x называется число \\(\\Delta_{x}>0\\) такое, что \\(\\Delta \\leq \\Delta_{x}\\), 
то есть \\[\\Delta =\\left|x-x^{*} \\right|\\leq \\Delta_{x}\\tag{1.2}\\]</p>\n
	<p>Из (1.2) получаем: \\(x-\\Delta_{x}\\leq x^{*}\\leq x+\\Delta_{x}\\), значит \\(x-\\Delta_{x}\\) - это приближенное значение числа \\(x^{*}\\) по недостатку, \\(x+\\Delta_{x}\\)
 - по избытку. Применяют также краткую запись: \\[x^{*}=x\\pm \\Delta_{x}\\]</p>\n
	<p>Если в условии задачи предельная абсолютная погрешность не указана, то она принимается равной половине последнего значащего разряда.</p>\n
	<p>Предельная абсолютная погрешность измеряется в тех же единицах, что и сама измеряемая величина.</p>\n

	<p><font color='#ff0000'>Относительной погрешностью</font> приближенного числа \\(x\\) называется отношение абсолютной погрешности \\(\\Delta\\) этого числа к абсолютной величине 
точного значения числа \\[\\delta =\\frac{\\Delta}{\\left|x^{*}\\right|}\\tag{1.3}\\]</p>\n
	<p>Так как точное число обычно неизвестно, то его заменяют приближенным числом. В результате получают оценку погрешности числа \\(\\delta_{x}\\), которую называют предельной относительной погрешностью.</p>\n
	<h3>Рассмотрим пример на Julia для относительной погрешности :</h3>
		<div class="code-container">
       		 <div class="code-header">
            		Относительная погрешность
           		 <span class="language-label">JULIA</span>
        	 </div>
       		 <pre><code class="language-julia">using Measurements

а = measurement(2.8934, 0.0003)

# Абсолютная погрешность
Δ_а = Measurements.uncertainty(а)

# Функция для относительной погрешности
function δ(m)
	return Measurements.uncertainty(m) / Measurements.value(m)
end

δ_а = δ(а) </code></pre>
	        </div>
	
	<p><font color='#ff0000'>Предельной относительной погрешностью</font> числа \\(x\\) называется отношение предельной абсолютной погрешности к абсолютной величине приближенного числа 
\\[\\delta_{x}=\\frac{\\Delta_{x}}{\\left|x \\right|}\\tag{1.4}\\]</p>\n
	<p>причем \\(\\delta\\leq \\delta_{x}\\), \\(\\delta_{x}>0\\).</p>\n
	<p>Из (1.4) можно получить \\[\\Delta_{x}=\\left|x \\right|\\delta_{x}\\tag{1.5}\\]</p>\n
	<p>Предельная относительная погрешность является безразмерной величиной и часто выражается в процентах \\[\\delta_{x}=\\frac{\\Delta_{x}}{\\left|x \\right|}\\cdot 100\\%\\tag{1.6}\\]</p>\n
	<p>Точность результата лучше характеризует его предельная относительная погрешность, которая показывает какую часть самого числа составляет погрешность.</p>\n
	<p>В вычислениях вместо абсолютной и относительной погрешностей используют предельную абсолютную и предельную относительную погрешность. Поэтому слово \"предельная\" для краткости пропускают, если это не может вызвать недоразумений.</p>\n\n
	
<h3>Пример вычисления предельной абсолютной и относительной погрешностей на Julia:</h3>
		<div class="code-container">
       		 <div class="code-header">
            		Предельные абсолютная и относительная погрешности
           		 <span class="language-label">JULIA</span>
        	 </div>
       		 <pre><code class="language-julia"># Пример: Сопротивление через закон Ома
U = 12.0    # напряжение, В
ΔU = 0.1    # погрешность напряжения, В
I = 0.5     # ток, А
ΔI = 0.01   # погрешность тока, А

# Вычисляем сопротивление по закону Ома: R = U/I
R = U / I

# Вычисляем предельную относительную погрешность 
δR = abs(ΔU/U) + abs(ΔI/I)

# Вычисляем предельную абсолютную погрешность
ΔR = δR * abs(R) </code></pre>
	        </div>

	<h1><i>Округление приближенных чисел</i></h1>\n
	<h2><font color='#ff9100'>Правила округления</font></h2>\n
	<ul>\n<li>Если первая слева из отбрасываемых цифр больше 5, то последняя справа из сохраняющихся цифр увеличивается на 1;</li>\n
	<li>Если первая слева из отбрасываемых цифр меньше 5, то последняя из сохраняющихся цифр остается неизменной;</li>\n
	<li>Если отбрасывается цифра 5, а за ней нет значащих цифр, то последняя из сохраняемых цифр остается неизменной если она четная, и увеличивается на 1 если она нечетная.</li>\n</ul>\n
	<p><font color='#ff0000'>Значащими цифрами</font> приближенного числа \\(a\\) называются все цифры в его десятичном представлении, начиная с первой ненулевой слева.</p>\n


	<p><font color='#ffa726'><font size=\"4\">Пример.</font></font> Определить все значащие цифры.</p>\n

	<h3><font color='#ffa726'>Решение:</font></h3>\n<p>У числа 5142,39 все цифры значащие;</p>\n
	<p>У числа 0,0046 только две значащих цифры: 4 и 6;</p>\n
	<p>У числа 0,004600 четыре значащих цифры: 4, 6 и два последних нуля.</p>\n
		<br>\n<p>Цифра приближенного числа называется <font color='#ff0000'>верной в широком смысле</font>, если абсолютная погрешность этого числа не превосходит единицы 
десятичного разряда, соответствующего этой цифре, в противном случае <font color='#ff0000'>сомнительной в широком смысле</font>.</p>\n
	<p><font color='#ffa726'><font size=\"4\">Пример.</font></font> Определить верные и сомнительные цифры в широком смысле приближенного числа \\(A=7,158\\pm 0,009\\).</p>\n
	
	<h3><font color='#ffa726'>Решение:</font></h3>\n
	<p>Заметим, что \\(a=7,158\\), \\(\\Delta_{a}=0,009\\).</p>\n
	<p>Т.к. \\(0,009\\leq 1\\), то цифра 7 верная в широком смысле;</p>\n
	<p>Т.к. \\(0,009\\leq 0,1\\), то цифра 1 верная в широком смысле;</p>\n
	<p>Т.к. \\(0,009\\leq 0,01\\), то цифра 5 верная в широком смысле;</p>\n
	<p>Т.к. \\(0,009\\leq 0,001\\), то цифра 8 верная в широком смысле;</p>\n
		<br>\n<p>Цифра приближенного числа называется <font color='#ff0000'>верной в узком смысле</font>, если абсолютная погрешность этого числа не превосходит половины
 единицы десятичного разряда, соответствующего этой цифре, в противном случае <font color='#ff0000'>сомнительной в узком смысле</font>.</p>\n
	<p><font color='#dd2c00'>Замечание.</font> При записи целых приближенных чисел сомнительные цифры принято заменять нулями.</p>\n
	<p><font color='#ffa726'><font size=\"4\">Пример.</font></font> Определить верные и сомнительные цифры в узком смысле приближенного числа \\(A=7,158\\pm 0,009\\)</p>\n

	<h3><font color='#ffa726'>Решение:</font></h3>\n
	<p>Т.к \\(0,009\\leq \\dfrac{1}{2}=0,5\\), то цифра 7 верная в узком смысле;</p>\n
	<p>Т.к \\(0,009\\leq \\dfrac{0,1}{2}=0,05\\), то цифра 1 верная в узком смысле;</p>\n	
	<p>Т.к \\(0,009\\leq \\dfrac{0,01}{2}=0,005\\), то цифра 5 верная в узком смысле;</p>\n
	<p>Т.к \\(0,009 > \\dfrac{0,001}{2}=0,0005\\), то цифра 8 сомнительная в узком смысле.</p>\n\n
	
	<h1><i>Решение типовых примеров</i></h1>\n
	<p><font color='#ffa726'><font size=\"4\">Пример.</font></font> Число \\(X = 7,3344\\), все цифры которого верны в строгом смысле, округлите до трех значащих цифр. Для полученного 
числа \\(X_{1}\\approx X\\) найти абсолютную и относительную погрешности. В записи числа \\(X_{1}\\) указать количество верных цифр (в узком и широком смысле).</p>\n
	
	<h4><font color='#ffa726'>Решение:</font></h4>\n
	<p>Пусть \\(X = 7,3344\\). Округлим данное число до трех значащих цифр, получим число: \\(X_{1}=7,33\\).</p>\n
	<p>Вычислим абсолютную погрешность: \\(\\Delta_{X_{1}}=\\left|X-X_{1}\\right|=\\left|7,3344-7,33\\right|=0,0044\\).</p>\n
	<p>Относительная погрешность составляет: \\(\\delta_{X_{1}}=\\dfrac{\\Delta_{X_{1}}}{\\left|X\\right|}=\\dfrac{0,0044}{7,33}\\approx 0,0006=0,06\\%\\).</p>\n
	<p>Укажем количество верных цифр в узком и широком смысле в записи числа \\(X_{1}=7,33\\).</p>\n
	<p>Т.к \\(0,0044\\leq \\dfrac{1}{2}=0,5\\), то цифра 7 верная в узком смысле;</p>\n
	<p>Т.к \\(0,0044\\leq \\dfrac{0,1}{2}=0,05\\), то цифра 3 верная в узком смысле;</p>\n
	<p>Т.к \\(0,0044\\leq \\dfrac{0,01}{2}=0,005\\), то цифра 3 верная в узком смысле;</p>\n
		<br>\n<p><font color='#ffa726'>Ответ:</font> Все цифры в записи числа \\(X_{1}=7,33\\) являются верными в узком смысле.</p>\n<br>\n
	<p>Т.к \\(0,0044\\leq 1\\), то цифра 7 верная в широком смысле;</p>\n
	<p>Т.к \\(0,0044\\leq 0,1\\), то цифра 3 верная в широком смысле;</p>\n
	<p>Т.к \\(0,0044\\leq 0,01\\), то цифра 3 верная в широком смысле;</p>\n
		<br>\n<p><font color='#ffa726'>Ответ:</font> Все цифры в записи числа \\(X_{1}=7,33\\) являются верными в широком смысле.</p>\n
		<br>\n<p><font color='#ffa726'><font size=\"4\">Пример.</font></font> Округлить число \\(32,0457\\pm 0,003\\) до верных знаков в узком смысле.</p>\n
	
	<h3><font color='#ffa726'>Решение:</font></h3>\n
		<ol>\n <li>Цифра \\(3\\). Должно выполняться условие \\(\\Delta_{X} <\\) половины единицы разряда десятков, то есть \\(0,003 < 5 (\\dfrac{10}{2}=5)\\). Условие выполняется. Цифра верная.</li>\n   
		       <li>Цифра \\(2\\). \\(\\Delta_{X} <\\) половины единицы разряда единиц, то есть \\(0,003 < 0,5 (\\dfrac{1}{2}=0,5)\\). Условие выполняется. Цифра верная.</li>\n
		       <li>Цифра \\(0\\). \\(\\Delta_{X} <\\) половины единицы соответствующего разряда в дробной части.</li>\n   
	<p>Разрядам справа от разряда единиц, то есть разрядам в дробной части числа, присваиваются отрицательные значения \\(-1, -2\\) и так далее. Определить разряд в дробной части числа
 можно по формуле: \\(10^{-n}\\), где \\(n\\) - соответствующая степень. Таким образом первый разряд в дробной части числа будет равен \\(10^{-1}\\), то есть равен одной десятой.</p>\n    
	<p>\\(0,003 < 0,05 (\\dfrac{0,1}{2}=0,05)\\). Условие выполняется. Цифра верная.</p>\n    
			<li>Цифра \\(4\\). \\(\\Delta_{X} <\\) половины разряда \\(10^{-2}\\), то есть \\(0,003 < 0,005\\). Условие выполняется. Цифра верная.</li>\n    
			<li>Цифра \\(5\\). Условие \\(0,003 < 0,0005\\) не выполняется, значит цифра и все последующие будут сомнительными.</li>\n</ol>\n
		<br>\n<p><font color='#ffa726'>Ответ:</font> \\(32,04\\pm 0,003\\).</p>\n\n
	
	<h1><i>Округление погрешностей</i></h1>\n
	<h2><font color='#ff9100'>Правила округления</font></h2>\n
	<p>1. Погрешности, в отличие от чисел, всегда округляют в большую сторону. Погрешность указывается двумя значащими цифрами, если первая из них 1 или 2, и одной &mdash; если первая цифра 3 и более.</p>\n
	        
	<h3>Пример использования встроенной функции для округления на Julia:</h3>
		<div class="code-container">
       		 <div class="code-header">
            		Округление цифр после запятой
           		 <span class="language-label">JULIA</span>
        	 </div>
       		 <pre><code class="language-julia">a = 2.8934
Δa = 0.0003

println("а = $a ± $Δa")
println("а ≈ ", round(a, sigdigits=3))</code></pre>
	        </div>

	<p><font color='#ffa726'><font size=\"4\">Пример.</font></font> Округлите следующие погрешности.</p>\n
	
	<h3><font color='#ffa726'>Решение:</font></h3>\n
	<p>\\(0,17295\\approx 0,17\\)</p>\n
	<p>\\(4,8329\\approx 5\\)</p>\n
	<p>\\(0,97283\\approx 1,0\\)</p>\n
	<p>\\(0,006298\\approx 0,006\\)</p>\n
		<br>\n<p><font color='#dd2c00'>Исключение</font> составляет только если следующая цифра \\(0\\)</p>\n
	<p>\\(5,01\\approx 5\\), а если \\(5,11\\approx 6\\)</p>\n
		<br>\n<p>2. Результат измерения округляется до того же десятичного разряда, которым оканчивается округленное значение абсолютной погрешности.</p>\n
	<p><font color='#ffa726'><font size=\"4\">Пример.</font></font> Округлить следующие числа и погрешности.</p>\n
	
	<h3><font color='#ffa726'>Решение:</font></h3>\n
	<p>\\(3,4874\\pm 0,17295\\approx 3,49\\pm 0,17\\)</p>\n
	<p>\\(285,396\\pm 4,8329\\approx 285\\pm 5\\)</p>\n
	<p>\\(19,9821\\pm 0,97283\\approx 20,0\\pm 1,0\\) (0 добавляется обязательно &mdash; это значащие цифры)</p>\n
		<br>\n<p>Округление следует начинать с погрешности, далее округляется сама величина.</p>\n\n\n
	
	<h1><i>Погрешности элементарных функций</i></h1>\n
	<h2><font color = '#ff9100'>Погрешности функции одной переменной</font></h2>\n
	<p>Пусть величина \\(y\\) является функцией величины \\(x\\), значения которой задаются приближенно. Нужно определить погрешность функции \\(y\\).</p>\n
	<p><font color = '#ff0000'>Абсолютная погрешность функции</font> равна произведению абсолютной величине производной на абсолютную погрешность агрумента \\[\\Delta _{y}=\\left|f^{'}(x) \\right|\\Delta _{x}\\tag{2.1}\\]</p>\n
	<p><font color = '#ff0000'>Относительная погрешность</font>  вычисляется по формуле: \\[\\delta _{y}=\\frac{\\Delta _{y}}{\\left|y \\right|}=\\frac{\\left|f^{'}(x) \\right|\\Delta _{x}}{\\left|f(x) \\right|}=\\left|\\frac{f^{'}(x)}{f(x)} \\right|\\left|x \\right|\\frac{\\Delta _{x}}{\\left|x \\right|}\\]</p>\n
	<p>Отсюда \\[\\delta _{y}=\\left|\\frac{f^{'}(x)}{f(x)} \\right|\\left|x \\right|\\delta _{x}\\tag{2.2}\\]</p>\n
	<p>Учитывая формулы для вычисления производных, запишем погрешности для некоторых функций.</p>\n
		<table align=center>\n<caption><h4>Вычисление погрешностей арифметических действий</h4>
		</caption>\n<tr><th>действие<th>абсолютная погрешность<th>относительная погрешность</tr>\n
			    <tr><td>\\(x+y\\)<td>\\(\\Delta x+\\Delta y\\)<td>\\(\\dfrac{|x|}{|x+y|}\\delta x+\\dfrac{|y|}{|x+y|}\\delta y\\)</tr>\n
			    <tr><td>\\(x-y\\)<td>\\(\\Delta x+\\Delta y\\)<td>\\(\\dfrac{|x|}{|x-y|}\\delta x+\\dfrac{|y|}{|x-y|}\\delta y\\)</tr>\n
			    <tr><td>\\(x y\\)<td>\\(|x|\\Delta y+|y|\\Delta x\\)<td>\\(\\delta x+\\delta y\\)</tr>\n
			    <tr><td>\\(\\dfrac{x}{y}\\)<td>\\(\\dfrac{|x|\\Delta y+|y|\\Delta x}{y^2}\\)<td>\\(\\delta x+\\delta y\\)</tr>\n</table>\n
		<table align=center>\n<caption><h4>Оценка погрешностей значений функций</h4></caption>\n
			    <tr><th>функция<th>абсолютная погрешность<th>относительная погрешность</tr>\n
                            <tr><td>\\(\\sqrt x\\)<td>\\(\\dfrac{\\Delta x}{2\\sqrt x}\\)<td>\\(\\dfrac{1}{2}\\delta x\\)</tr>\n
			    <tr><td>\\(\\dfrac{1}{x}\\)<td>\\(\\dfrac{\\Delta x}{x^2}\\)<td>\\(\\delta x\\)</tr>\n
			    <tr><td>\\(\\sin x\\)<td>\\(|\\cos x|\\Delta x\\)<td>\\(|x\\cot x|\\delta x\\)</tr>\n
			    <tr><td>\\(\\cos x\\)<td>\\(|\\sin x|\\Delta x\\)<td>\\(|x\\tan x|\\delta x\\)</tr>\n
			    <tr><td>\\(\\tan x\\)<td>\\(\\dfrac{\\Delta x}{\\cos^2x}\\)<td>\\(\\dfrac{2|x|}{|\\sin{2x}|}\\delta x\\)</tr>\n
			    <tr><td>\\(\\ln x\\)<td>\\(\\dfrac{\\Delta x}{x}\\)<td>\\(\\dfrac{\\delta x}{|\\ln x|}\\)</tr>\n
			    <tr><td>\\(e^x\\)<td>\\(e^x\\Delta x\\)<td>\\(|x|\\delta x\\)</tr>\n
			    <tr><td>\\(\\arcsin x\\)<td>\\(\\dfrac{\\Delta x}{\\sqrt{1-x^2}}\\)<td>\\(\\dfrac{|x|}{|\\arcsin x|\\sqrt{1-x^2}}\\delta x\\)</tr>\n
			    <tr><td>\\(\\arccos x\\)<td>\\(\\dfrac{\\Delta x}{\\sqrt{1-x^2}}\\)<td>\\(\\dfrac{|x|}{|\\arccos x|\\sqrt{1-x^2}}\\delta x\\)</tr>\n
			    <tr><td>\\(\\arctan x\\)<td>\\(\\dfrac{\\Delta x}{1+x^2}\\)<td>\\(\\dfrac{|x|}{|\\arctan x|\\sqrt{1-x^2}}\\delta x\\)</tr>\n
			    <tr><td>\\(x^y\\)<td>\\(x^y(|y|\\dfrac{\\Delta x}{x}+|\\ln x|\\Delta y)\\)<td>\\(|y\\ln x|\\delta y+|y|\\delta{x}\\)</tr>\n</table>\n\n

	<h2><font color = '#ff9100'>Погрешности функции нескольких переменных</font></h2>\n
	<p>Пусть \\(y=f(x_{1},x_{2},...,x_{n})\\) непрерывно дифференцируемая функция, \\(\\Delta _{y}=\\left|f(x_{1}+\\Delta _{x_{1}},x_{2}+\\Delta _{x_{2}},...,x_{n}+\\Delta _{x_{n}})-f(x_{1},x_{2},...,x_{n}) \\right|\\) известные абсолютные погрешности.</p>\n
	<p><font color = '#ff0000'>Абсолютная погрешность</font> результата вычисления функции нескольких приближенных чисел равна сумме произведений модуля частной производной функции на 
абсолютную погрешность приближенного числа: \\[\\Delta _{y}=\\sum_{i=1}^{n}{\\left|\\frac{\\partial f}{\\partial x_{i}} \\right|}\\Delta _{x_{i}}\\tag{2.3}\\]</p>\n
	<p><font color = '#ff0000'>Относительная погрешность</font> функции нескольких переменных: \\[\\delta _{y}=\\sum_{i=1}^{n}{\\left|\\frac{\\partial \\ln f(x_{1},x_{2},...,x_{n})}{\\partial x_{i}} \\right|}\\Delta _{x_{i}}\\tag{2.4}\\]</p>\n\n
 `,
	"practica": `
	<h1><i>Теория погрешностей</i></h1>
        <h2><i>Практическая работа №1</i></h2>

	<caption><h4>Пример 1.</h4></caption>
<p>Вычислить период колебания маятника и найти его абсолютную и относительную погрешности, если даны значения:\\[\\pi \\approx 3.142, \\quad l \\approx 120.00 \\, \\text{см}, \\quad g \\approx 981.32 \\, \\text{см/сек}^2.\\]</p>
	
<h4>Алгоритм вычисления периода колебания маятника</h4>

    <p>Шаг 1: Вводим входные данные</p>
    <pre><code class="language-julia">
using Measurements

π_val = measurement(3.142, 0.0005)  # π = 3.142 ± 0.0005
l_val = measurement(120.00, 0.01)   # длина = 120.00 ± 0.01 см
g_val = measurement(981.32, 0.01)   # g = 981.32 ± 0.01 см/сек²
    </code></pre>
    
    <p>Шаг 2: Определение формулы периода</p>
    <pre><code class="language-julia">
function period(π, l, g)
    return 2π * sqrt(l / g)
end
    </code></pre>
    
    <p>Шаг 3: Вычисление периода</p>
    <pre><code class="language-julia">T_val = period(π_val, l_val, g_val)</pre></code>
    
    <p>Шаг 4: Вычисление относительных погрешностей</p>
    <pre><code class="language-julia">
function pogreshnost(m)
    return Measurements.uncertainty(m) / Measurements.value(m)
end

S_π = pogreshnost(π_val)
S_l = pogreshnost(l_val)
S_g = pogreshnost(g_val)
    </code></pre>
    
    <p>Шаг 5: Вычисление относительной погрешности периода</p>
    <pre><code class="language-julia">S_T = S_π + 0.5(S_l + S_g)
    
S_T_percent = S_T * 100
    </code></pre>
    
    <p>Шаг 6: Вычисление абсолютной погрешности периода</p>
    <pre><code class="language-julia">Δ_T = Measurements.uncertainty(T_val)</code></pre>
    
    <p>Шаг 7: Округление результатов</p>
    <pre><code class="language-julia">
T_rounded = round(Measurements.value(T_val), digits=4)
Δ_T_rounded = round(Measurements.uncertainty(T_val), digits=4)
    </code></pre>
    <p>Выводим результат</p>    
    
    <p>Примечания:</p>
    <ul>
        <li>Для работы требуется библиотека Measurements.jl</li>
        <li>Все вычисления погрешностей выполняются автоматически</li>
    </ul>

	<caption><h4>Пример 2.</h4></caption>
<p>Вычислить диагональ прямоугольника измеренных:  \\[a = 3.18 \\pm 0.005 \\, \\text{см}, \\quad b = 2.5 \\pm 0.05 \\, \\text{см}.\\]</p>

<h4>Алгоритм вычисления диагонали прямоугольника</h4>
<p>Вводим входные данные</p>
<p>Шаг 1: Зададим определение формулы диагонали</p>
<pre><code class="language-julia">
function p_diagonal(a, b)
    return sqrt(a^2 + b^2)
end
</code></pre>

<p>Шаг 2: Вычисление диагонали</p>
<pre><code class="language-julia">c_val = p_diagonal(a_val, b_val)</code></pre>

<p>Шаг 3: Вычисление абсолютной погрешности</p>
<pre><code class="language-julia">Δc = Measurements.uncertainty(c_val)</code></pre>

<p>Шаг 4: Вычисление относительной погрешности</p>
<pre><code class="language-julia">
function p_pogreshnost(m)
    return (Measurements.uncertainty(m) / Measurements.value(m)) * 100
end

δc = p_pogreshnost(c_val)
</code></pre>
<p>Выводим результат</p>

	<caption><h4>Пример 3.</h4></caption>
<p>Найти абсолютную и относительную погрешность полной поверхности усеченного конуса, если радиусы его оснований \\( R = 46.3 \\, \\text{см}, \\, r = 24.7 \\, \\text{см} \\),
 а длина образующей \\( l = 32.6 \\, \\text{см} \\).</p>
<h4>Алгоритм вычисления поверхности усеченного конуса</h4>
<p>Вводим входные данные</p>
<p>Шаг 1: Определение формулы поверхности</p>
<pre><code class="language-julia">
function conus_pov(R, r, l, π)
    return π * (R^2 + (R + r) * l + r^2)
end
</code></pre>

<p>Шаг 2: Вычисление поверхности</p>
<pre><code class="language-julia">S_val = conus_pov(R_val, r_val, l_val, π_val)</code></pre>

<p>Шаг 3: Вычисление частных производных</p>
<p>Для расчета погрешности вычисляем производные по каждому параметру:</p>
<pre><code class="language-julia">
∂S_∂π = R² + (R + r)l + r²
∂S_∂R = π(2R + l)  
∂S_∂r = π(2r + l)
∂S_∂l = π(R + r)
</code></pre>

<p>Шаг 4: Вычисление абсолютной погрешности</p>
<pre><code class="language-julia">ΔS = Measurements.uncertainty(S_val)</code></pre>

<p>Шаг 5: Вычисление относительной погрешности</p>
<pre><code class="language-julia">
function p_pogreshnost(m)
    return (Measurements.uncertainty(m) / Measurements.value(m)) * 100
end

δS = p_pogreshnost(S_val)
</code></pre>
<p>Выводим результат</p>
        
    `,
        "test": {
            "timeLimit": 600,
            "questions":  [
            {
                "question": "Что из перечисленного относится к правилам округления обычных приближённых чисел (не погрешностей)?",
                "answers": [
                {
                    "text": "Если первая из отбрасываемых цифр больше 5, последняя сохраняемая цифра увеличивается на единицу.",
                    "correct": true
                },
                {
                    "text": "Если отбрасывается цифра 5, а за ней нет значащих цифр, то последняя сохраняемая цифра остаётся неизменной, если она чётная.",
                    "correct": true
                },
                {
                    "text": "Погрешность всегда округляется в большую сторону, и её принято записывать двумя значащими цифрами.",
                    "correct": false
                }
                ],
                "type": "multiple"
            },
            {
                "question": "По каким правилам происходит округление погрешностей (в отличие от обычных чисел)?",
                "answers": [
                {
                    "text": "Погрешности всегда округляются в большую сторону.",
                    "correct": true
                },
                {
                    "text": "Погрешность указывается одной значащей цифрой, если первая из них равна 1 или 2.",
                    "correct": false
                },
                {
                    "text": "Результат измерения округляется до того же десятичного разряда, которым оканчивается округлённое значение абсолютной погрешности.",
                    "correct": true
                }
                ],
                "type": "multiple"
            },
            {
                "question": "Цифра приближённого числа считается верной в узком смысле, если:",
                "answers": [
                {
                    "text": "Абсолютная погрешность не превосходит единицы десятичного разряда, соответствующего этой цифре.",
                    "correct": false
                },
                {
                    "text": "Абсолютная погрешность не превосходит половины единицы десятичного разряда, соответствующего этой цифре.",
                    "correct": true
                },
                {
                    "text": "Она является значащей цифрой в записи числа.",
                    "correct": false
                }
                ],
                "type": "single"
            },
            {
                "question": "Что характеризует предельная относительная погрешность?",
                "answers": [
                {
                    "text": "Показывает, какую часть самого приближённого числа составляет возможная ошибка.",
                    "correct": true
                },
                {
                    "text": "Измеряется в тех же единицах, что и сама величина.",
                    "correct": false
                },
                {
                    "text": "Может быть выражена в процентах.",
                    "correct": true
                }
                ],
                "type": "multiple"
            },
            {
                "question": "Какие виды погрешностей возникают в процессе решения задачи численным методом?",
                "answers": [
                {
                    "text": "Неустранимая погрешность (возникает из-за неточности исходных данных).",
                    "correct": true
                },
                {
                    "text": "Погрешность округления (возникает из-за округления чисел при вычислениях).",
                    "correct": true
                },
                {
                    "text": "Погрешность модели (возникает из-за несоответствия математической модели реальному объекту).",
                    "correct": false
                }
                ],
                "type": "multiple"
            }
            ]
        }
    },
        topic02: {
        "title": "Численные методы решения нелинейных уравнений",
        "theory": `
	<h1><i>Численные методы решения нелинейных уравнений</i></h1>
	<h2><i>Отделение корней</i></h2>\n
	<p>При решении многих практических задач математические модели решения представляют собой нелинейные уравнения.</p>\n
	<p>Например, в медицине при исследовании действия лекарственных препаратов нужно знать, когда концентрация вещества достигнет заданного уровня; в экономике, развивая бизнес, необходимо знать, когда прибыль достигнет определенного значения.</p>\n
	<p>Однако большая часть таких уравнений либо не имеет точного аналитического решения, либо оно представляется слишком сложным. В этом случае используются численные (приближенные) методы.</p>\n
	<p><span style=\\\"color: #ff0000;\\\">Нелинейным уравнением</span> называется уравнение вида \\(f(x)=0\\) где функция \\(y=f(x)\\) является нелинейной, т.е. трансцендентной (тригонометрической, показательной, гиперболической).</p>\n
	<p>Число называется <span style=\\\"color: #ff0000;\\\">корнем (решением)</span> нелинейного уравнения, если при подстановке вместо \\(x\\) этого числа в нелинейное уравнение, оно превращается в верное числовое равенство.</p>\n
	<p>На практике не всегда удается найти такое решение точно. Поэтому решение нелинейного уравнения находят с применением численных методов.</p>\n
	<p>В этом случае <span style=\\\"color: #ff0000;\\\">корнем (решением) нелинейного уравнения</span> называют такое число \\(\\xi\\), при подстановке которого в нелинейное 
	уравнение последнее будет выполняться с заданной степенью точности, т.е. \\[\\left|f(\\xi) \\right|\\leq \\varepsilon\\] где \\(\\varepsilon\\) — заданная точность.</p>\n\n
	
	<h1><i>Методы уточнения корней: метод половинного деления (метод биссекции).</i></h1>\n
	<p><span style=\\\"color: #008000;\\\">Описание метода:</span> Допустим, что отделение корней уравнения \\(y=f(x)\\) проведено, и на отрезке \\([a;b]\\) расположен 
один корень, который необходимо уточнить до заданной точности \\(\\varepsilon\\). В качестве начального приближения корня принимаем середину этого отрезка \\[x_{0}=\\frac{a+b}{2}\\]</p>\n
<img src="https://sun9-75.userapi.com/impg/cGA59ddzSlZWg4BNhgmApG9uR3-Ow9fTwwtUjg/Bul8Hmu5Zl4.jpg?size=477x336&quality=96&sign=637697ff58207d0444fda4e15e5157f6&type=album" 
alt="Метод половинного деления">\n<p>Затем исследуем значение функции \\(f(x)\\) на концах отрезков \\([a;x_{0}]\\) и \\([x_{0};b]\\). Тот из отрезков, на концах которого 
\\(f(x)\\) принимает значение разных знаков, содержит искомый корень. И этот отрезок принимаем в качестве нового отрезка \\([a_{1};b_{1}]\\) (на рисунке это отрезок \\([a;x_{0}]\\)). 
Вторую половину отрезка \\([a;b]\\), на которой \\(f(x)\\) не меняет знак, не рассматриваем.</p>\n
	<p>В качестве следующего приближения корня принимаем середину отрезка \\[x_{1}=\\frac{a_{1}+b_{1}}{2}\\]</p>\n
	<img src="https://sun9-78.userapi.com/impg/EhZRYzFXQ1VQuLagfT50oBvn_vtjB7ODxDPf-A/xB87BdLmtM4.jpg?size=488x318&quality=96&sign=dbb5f414c2bbe28851e027b8420ead8c&type=album" 
alt="Метод половинного деления - вторая итерация">\n
	<p>И так далее. Таким образом, k-е приближение вычисляется \\[x_{k}=\\frac{a_{k}+b_{k}}{2}\\tag{1.1}\\]</p>\n
	<p>После каждой итерации отрезок, на котором расположен корень, уменьшается вдвое, а после k итераций в \\(2^{k}\\) раз: \\[b_{k}-a_{k}=\\frac{b-a}{2^{k}}\\tag{1.2}\\]</p>\n
	<p>Прекратить итерационный процесс следует, когда будет достигнута заданная точность \\(\\varepsilon\\).</p>\n\n
		
	<h3>Функция для метода половинного деления на Julia:</h3>
		<div class="code-container">
       		 <div class="code-header">
            		Метод половинного деления
           		 <span class="language-label">JULIA</span>
        	 </div>
       		 <pre><code class="language-julia"> function pol_del(a, b, eps)
	# Вычисляем значения функции на концах интервала
	fa = f(a)
	fb = f(b)
    
	# Проверка на разные знаки на интервале
	if sign(fa) == sign(fb)
		println("Ошибка: f(a) и f(b) имеют одинаковые знаки")
		return nothing
	end
    
	iter = 0
	c = 0.0
    
	# Основной цикл 
	while (b - a) > eps
		c = (a + b) / 2.0  # Середина интервала
		fc = f(c)
       
		iter += 1
       
		# Уточнение интервала
		if fa * fc < 0
			b = c
			fb = fc
		else
			a = c
			fa = fc
		end
	end
end</code></pre>
	        </div>

	<h1><i>Методы уточнения корней: метод Ньютона(метод касательных).</i></h1>\n
	<p>Метод Ньютона (метод касательных, или метод линеаризации) является одним из наиболее популярных численных методов. Он быстро сходится (имеет квадратичную сходимость) и 
допускает различные модификации, приспособленные для решения векторных задач и сеточных уравнений. Однако этот метод эффективен при весьма жестких ограничениях на характер функции:</p>\n
		<ol>\n    <li>\\(f(x)\\) непрерывна на отрезке \\([a;b]\\);</li>\n    
			  <li>\\(f(a)\\cdot f(b) < 0\\) (функция на концах отрезка имеет разные знаки);</li>\n    
			  <li>\\(f'(x)\\) и \\(f''(x)\\) сохраняют постоянный знак на всем отрезке \\([a;b]\\).</li>\n</ol>\n
	<p>В методе Ньютона в отличие от других методов не обязательно задавать отрезок \\([a;b]\\), содержащий корень уравнения, достаточно найти некоторое начальное приближение корня 
\\(x_{0}\\) (\\(x_{0}\\in [a;b]\\)).</p>\n<p><span style=\\\"color: #ff0000;\\\">Геометрическая интерпретация</span> метода Ньютона состоит в следующем. Пусть известно начальное 
приближение к корню \\(x_{0}\\). Проведем в этой точке касательную к кривой \\(y=f(x)\\). Эта касательная пересечет ось абсцисс в точке \\(x_{1}\\), которую будем рассматривать в 
качестве следующего приближения. Далее снова проводим касательную к кривой в точке \\(x_{1}\\). Её пересечение с осью абсцисс дает следующее приближение корня \\(x_{2}\\). Продолжая 
этот процесс, получим приближенные значения \\(x_{3},x_{4},...\\). При этом каждое новое приближенное значение корня ближе к истинному значению.</p>\n
	<img src="https://sun9-10.userapi.com/impg/jOmzESapllpwpyu_VdbUkvJ5zr95KcQR5EpPhA/28s-SOaYUe0.jpg?size=419x324&quality=96&sign=0a4c632e6972abd0560a9174e7b6cdb3&type=album" alt="Метод Ньютона">\n
	<p>Процесс построения касательных и нахождения точек пересечения с осью абсцисс повторяется до тех пор, пока приращение не станет меньше заданной величины \\(\\varepsilon\\).</p>\n
	<p>Найдем формулу для вычисления приближенных значений корня по этому методу.</p>\n
	<p>Уравнение касательной в точке \\((x_{0};f(x_{0}))\\) имеет вид: \\[y=f(x_{0})+f'(x_{0}) \\cdot (x-x_{0})\\tag{2.1}\\]</p>\n
	<p>Полагая в этом уравнении \\(y=0\\) и выражая \\(x\\), получим следующее (первое) приближение к корню: \\[x_{1}=x_{0}-\\frac{f(x_{0})}{f'(x_{0})}\\tag{2.2}\\]</p>\n
	<p>Аналогично находят следующие приближения. Формула для \\(k+1\\)-ого приближения имеет вид: \\[x_{k+1}=x_{k}-\\frac{f(x_{k})}{f'(x_{k})},\\;\;\\;\\;\\;\\;k=0,1,2,...\\tag{2.3}\\]</p>\n
	<p>Вычисления продолжают до тех пор, пока не будет выполнено условие \\[\\left|x_{k+1}-x_{k} \\right| < \\varepsilon\\tag{2.4}\\]</p>\n
	<p>\\(\\varepsilon\\) — заданная точность.</p>\n
	<p>Абсолютная погрешность метода вычисляется по формуле: \\[R=\\left|x^{*}-x \\right|\\leq \\frac{M_{2}}{2m_{1}}\\left|x_{k+1}-x_{k} \\right|\\tag{2.5}\\]</p>\n<p>где \\(x^{*}\\) — точное решение;</p>\n
	<p>\\(x\\) — приближенное решение; \\[m_{1}=\\min_{x \\in [a; b]}\\left|f'(x) \\right|\\] \\[M_{2}=\\max_{x \\in [a; b]}\\left|f''(x) \\right|\\]</p>\n
	<p>Сходимость итерационной последовательности, получаемой в методе Ньютона, зависит от выбора начального приближения \\(x_{0}\\).</p>\n

	<h3><span style=\\\"color: #008000;\\\">Выбор начального приближения в методе Ньютона</span></h3>\n
	<p>Если в качестве начального приближения взять точку \\(x'_{0}\\), то итерационный процесс сходиться не будет.</p>\n
	<p>Если же в качестве начального приближения выбрать точку \\(x_{0}\\), то получим сходящуюся последовательность.</p>\n
	<p>Поэтому для выбора начального приближения справедлива теорема.</p>\n
	<p><span style=\\\"color: #8b00ff; font-size: 1.1em;\\\">Теорема.</span> Если задан отрезок \\([a;b]\\), содержащий корень, и известно, что \\(f'(x)\\) и \\(f''(x)\\) сохраняют знаки на
 отрезке \\([a;b]\\), то в качестве начального приближения \\(x_{0}\\) нужно выбрать ту границу отрезка \\([a;b]\\), то есть точку, в которой совпадают знаки функции 
\\(f(x)\\) и второй производной \\(f''(x)\\), другими словами в точке начального приближения знаки функции и ее второй производной должны совпадать \\(f(x_{0}) \\cdot f''(x_{0}) > 0\\).</p>\n
	
	<h2><i>Алгоритм метода</i></h2>\n
		<ol>\n    <li>Задать начальное приближение корня \\(x_{0}\\);</li>\n    
			  <li>Проверить условие сходимости метода \\(f(x_{0})\\cdot f''(x_{0}) > 0\\). Если условие не выполняется, перейти к п. 1;</li>\n    
			  <li>Вычислить следующее приближение по формуле \\[x=x_{0}-\\frac{f(x_{0})}{f'(x_{0})}\\]</li>\n   
			  <li>Если \\(\\left|x-x_{0} \\right| < \\varepsilon\\), перейти к п. 3, при этом \\(x_{0}=x\\);</li>\n    
			  <li>Вывести значение \\(x\\).</li>\n</ol>\n\n

		
	<h3>Функция для метода Ньютона на Julia:</h3>
		<div class="code-container">
       		 <div class="code-header">
            		Метод Ньютона
           		 <span class="language-label">JULIA</span>
        	 </div>
       		 <pre><code class="language-julia">using ForwardDiff
function newton_auto(x0, eps)
	x = x0
	iter = 0

	while iter < 100
		fx = f(x)
		dfx = ForwardDiff.derivative(f, x)
        
		x_new = x - fx / dfx
		iter += 1
        
		println("$iter: x = $x, f(x) = $fx")
        
		if abs(x_new - x) < eps
			println("\nРешение: x = $x_new")
			return x_new
		end
        
		x = x_new
	end
    
println("Не сошлось")
return x
end</code></pre>
	        </div>

	<h1><i>Методы уточнения корней: метод простой итерации (метод последовательных приближений)</i></h1>\n
	<p><span style=\\\"color: #8b00ff; font-size: 1.1em;\\\">Описание метода:</span> Дано уравнение \\(f(x)=0\\). При отделении корней найден отрезок \\([a;b]\\), содержащий корень. 
Необходимо уточнить значение корня на этом отрезке.</p>\n<p>Пусть функция \\(f(x)\\) имеет на концах отрезка значения разных знаков \\(f(a)\\cdot f(b) < 0\\).</p>\n
	<p>Заменим уравнение \\(f(x)=0\\) равносильным уравнением \\[x=\\varphi (x)\\tag{3.1}\\]</p>\n
	<p>Зададим некоторое начальное приближение корня \\(x_{0}\\in [a;b]\\) и, подставляя его в правую часть уравнения, получим первое приближение корня \\(x_{1}\\). Затем, подставляя 
найденное значение \\(x_{1}\\) в правую часть уравнения, получим следующее приближение корня \\(x_{2}\\) и так далее. \\[x_{1}=\\varphi (x_{0}),\\;x_{2}=\\varphi (x_{1}),...,x_{k}=\\varphi (x_{k-1}),\\;\\;\\;\\;\\;k\\rightarrow \\infty \\tag{3.2}\\]</p>\n
	<p>Если последовательность \\(x_{1},\\;x_{2},...,\\;x_{k}\\) при \\(k\\rightarrow \\infty\\) сходится, то она сходится к точному решению уравнения. Однако не всегда 
числа \\(x_{1},x_{2},...\\) , получающиеся в этом процессе, приближаются к корню уравнения. Иногда они наоборот удаляются от корня уравнения. Поэтому следует выяснить условия, при которых 
данный метод применим.</p>\n
	<p><span style=\\\"color: #ff0000;\\\">Абсолютная погрешность</span> метода итераций вычисляется по формуле: \\[R=\\left|x^{*}-x \\right|=\\frac{1}{1-q}\\left|x_{k+1}-x_{k} \\right|\\]</p>\n
	<p>где \\(q=\\max_{ [a, b]}\\left|\\varphi '(x) \\right|\\).</p>\n

	<h3><span style=\\\"color: #008000;\\\">Условия сходимости метода простой итерации</span></h3>\n
	<p>Для того, чтобы итерационный процесс (3.2) был сходящимся, необходимо, чтобы абсолютная величина производной \\(\\varphi' (x)\\) в окрестностях корня была меньше 1 \\[\\left|\\varphi' (x) \\right| < 1\\tag{3.3}\\]</p>\n
	<p>Если это условие выполняется на отрезке \\([a;b]\\), на котором находится корень, то в качестве начального приближения можно взять любую точку из этого отрезка \\(x_{0}\\).</p>\n
	<p>Процесс итераций прекращают, когда выполняется условие \\[\\left|x_{k+1}-x_{k} \\right| < \\varepsilon\\tag{3.4}\\]</p>\n
	<p>Рассмотрим <span style=\\\"color: #ff0000;\\\">графический процесс</span> получения приближенного решения методом простой итерации.</p>\n
	<p>При решении уравнения (3.1) необходимо отыскать точку пересечения кривой \\(y=\\varphi (x)\\) и прямой \\(y=x\\) (график функции \\(y=x\\) есть биссектриса координатного угла). 
На (рис. 1, а) изображена некоторая кривая \\(y=\\varphi (x)\\), которая может представлять собой любую функцию, причем производная этой функции в окрестности корня должна быть
 положительна и меньше 1. Пусть \\(x=x^{*}\\) — корень уравнения, который предполагается неизвестным. Выберем начальное приближение в точке \\(x_{0}\\). Следующее приближение \\(x_{1}\\). 
В соответствии с (3.2), будет равно \\(\\varphi (x_{0})\\). Чтобы отобразить \\(x_{1}\\) на графике, нужно провести через точку \\((x_{0},f(x_{0}))\\) прямую, параллельную оси Ох, до 
пересечения с прямой \\(y=x\\), а затем в точке пересечения этих прямых опустить перпендикуляр на ось Ох, который и отметит положение точки \\(x_{1}\\). Аналогично получаются все 
последующие приближения. Из рисунка видно, что они сходятся к корню. Напомним, что для рассмотрения мы взяли функцию, производная которой положительна и меньше 1. В результате получают 
ломаную. Абсциссы вершин этой ломаной \\(x_{0},\\;x_{1},\\;x_{2},...\\) — это элементы итерационной последовательности. Сама ломаная называется <span style=\\\"color: #ff0000;\\\">ломаной итерации</span>.</p>\n
<img src="https://sun9-74.userapi.com/impg/7xFUbqcRpi_AYbfFKqlssqU_omci33-QuTv4aA/qjMo6nQ25ME.jpg?size=649x698&quality=96&sign=a95cc524007b10845c1944e5d6e74270&type=album" alt="Графическая иллюстрация метода простой итерации">\n
	<p>Рассмотрим теперь другую функцию \\(y=\\varphi (x)\\), производная которой отрицательна, но меньше 1 по абсолютному значению. Этот случай изображен на рисунке 1,в. 
Последовательные приближения также сходятся к корню, но на этот раз каждое последующее приближение находится с противоположной стороны от корня. В то время как в первом случае все 
последовательные приближения находились с одной стороны от корня.</p>\n
	<p>Наконец, рассмотрим случай, когда производная функции \\(y=\\varphi (x)\\) больше 1 (рис.1, б) и меньше -1 (рис. 1, г). В обоих случаях каждое последующее приближение отстоит 
дальше от корня, т.е. итерационный процесс расходится. Из сказанного выше можно предположить, что итерационный процесс, определяемый формулой (3.1) сходится при условии, что 
производная \\(\\varphi' (x)\\) меньше 1 по абсолютной величине.</p>\n
	
	<h3><span style=\\\"color: #008000;\\\">Преобразование уравнения к итерационному виду</span></h3>\n<p>Рассмотрим общий алгоритм перехода от уравнения \\(f(x)=0\\) к уравнению \\(x=\\varphi (x)\\).</p>\n
	<p>Умножим левую и правую части уравнения \\(f(x)=0\\) на произвольную константу \\(\\lambda \\neq 0\\) и добавим к обеим частям неизвестное \\(x\\). При этом корни исходного 
уравнения не изменятся \\[x+\\lambda\\cdot f(x)=0 \\cdot \\lambda +x\\tag{3.5}\\]</p>\n
	<p>Уравнение (3.5) эквивалентно уравнению (3.1) с функцией \\(\\varphi (x)=x+\\lambda \\cdot f(x)\\). Поскольку \\(\\varphi' (x)=1+\\lambda \\cdot f'(x)\\), значение 
\\(\\lambda\\) следует выбирать так, чтобы в окрестности корня выполнялось условие \\[\\left|\\varphi' (x) \\right|=\\left|1+\\lambda \\cdot f'(x) \\right| < 1\\]</p>\n
	<p>Чтобы итерационный процесс сходился быстрее, \\(\\lambda\\) надо выбрать в виде: \\[\\lambda =- \\frac{1}{M_{1}},\\;\\;\\;\\; M_{1}=\\max_{x \\in [a, b]}\\left|f'(x) \\right|\\tag{3.6}\\]</p>\n
	<p>При этом итерационная формула (3.1) переходит в формулу Ньютона \\[x_{k+1}=x_k-\\frac{f(x)}{f'(x)}\\]</p>\n
	<p>Таким образом, метод Ньютона можно трактовать как частный случай метода простых итераций, обладающий максимальной скоростью сходимости.</p>\n
	<h2><i>Алгоритм метода</i></h2>\n
		<ol>\n    <li>Задать начальное приближение \\(x_{0}\\) и малое положительное число \\(\\varepsilon\\). Положить \\(k=0\\).</li>\n    
			  <li>Представить уравнение в виде, удобным для применения метода итераций, то есть в виде \\(x=\\varphi (x_{0})\\), где \\(\\varphi (x_{0})=x_{0}+\\lambda f(x_{0})\\).</li>\n    
			  <li>Проверить условие сходимости метода \\(\\left|\\varphi' (x_{0}) \\right| < 1\\), где \\(\\varphi' (x_{0}) =1+\\lambda f'(x_{0}),\\lambda  =-\\frac{1}{M_{1}}, M_{1}=\\min_{x \\in [a, b]}\\left|f'(x) \\right|\\).
 Если условие выполняется, метод итераций применим.</li>\n    
			  <li>Вычислить следующее приближение по формуле: \\[x=\\varphi (x_{0})\\]</li>\n    
			  <li>Если \\(\\left|x-x_{0} \\right| < \\varepsilon\\), положить \\(k=k+1\\) и перейти к п. 3 при этом \\(x_{0}=x\\);</li>\n    
			  <li>Вывести значение \\(x\\).</li>\n</ol>\n
	
	<p><span style=\\\"color: #008000; font-size: 1.1em;\\\">Пример.</span> Пусть дано уравнение \\(x^{3}-x+1=0\\) и надо уточнить его корень, который находится на 
\\([-2;-1]\\) с точностью \\(\\varepsilon_{1}=0,01\\) и \\(\\varepsilon_{2}=0,001\\).</p>\n

	<h4><span style=\\\"color: #008000;\\\">Решение:</span></h4>\n
		<ol>\n    <li>Зададим начальное приближение \\(x_{0}=-1\\). Решим задачу с различной точностью \\(\\varepsilon_{1}\\) и \\(\\varepsilon_{2}\\).</li>\n    
			  <li>Преобразуем уравнение к виду \\(x=\\varphi (x)\\). Для этого запишем его сначала в форме \\(x=x^3+1\\). Легко показать, что функция \\(\\varphi (x)=x^3+1\\) 
не удовлетворяет условию сходимости, поскольку \\(\\varphi' (x)=3x^2,\\;\\varphi' (-2)=12 > 1,\\;\\;\\;\\varphi' (-1)=3 > 1\\).</li>\n    
	<p>Поэтому воспользуемся другим преобразованием. В результате получим \\(x=\\sqrt[3]{x-1}\\). Можно проверить, что \\(\\left| \\varphi'(x) \\right| < 1\\) на отрезке \\([-2;-1]\\), т.е. достаточные условия сходимости выполняются.</p>\n    
			  <li>Выполним расчеты по формуле: \\(x^{(k+1)}=\\sqrt[3]{x^{(k)}-1}\\), \\(k=0,1,2, ...\\) . Результаты расчетов приведены в таблице </li>\n    
<img src="https://sun9-46.userapi.com/impg/JoULpINVOtE6mNs11d3pI-3HtJrdmzeczMH8Rg/fQsBenaMwrs.jpg?size=668x147&quality=96&sign=9439b81547f8b182af0c158ab860d082&type=album" alt="Таблица расчетов метода простой итерации">\n</ol>\n
	<p>Если \\(\\varepsilon_{1}=0,01\\), то \\(x^{*}\\cong -1,3223\\), а если \\(\\varepsilon_{2}=0,001\\), то \\(x^{*}\\cong -1,3246\\).</p>
	
	<h3>Функция для метода простой итерации на Julia:</h3>
		<div class="code-container">
       		 <div class="code-header">
            		Метод проостой итерации
           		 <span class="language-label">JULIA</span>
        	 </div>
       		 <pre><code class="language-julia">function simple_iter(x0, eps, lambda)
	x = x0
	iter = 0
    
	while iter < 100
		x_new = x - lambda * f(x)  
        
		iter += 1
		diff = abs(x_new - x)
        
		if diff < eps
			return x_new
		end
        
		x = x_new
	end
    
println("Не сошлось")
return x
end</code></pre>
	        </div>
`,
	"practica": `
	<h1><i>Численные методы решения нелинейных уравнений</i></h1>
        <h2><i>Практическая работа №2</i></h2>

	<caption><h4>Пример 1.</h4></caption>
<p>Дано нелинейное уравнение \\[ \\sin x + x - 0.5 = 0 \\] Отделить его корни на отрезке \\([-2; 2]\\) с шагом \\(0.1\\). Провести уточнение корней уравнения методом половинного деления 
с точностью \\(\\varepsilon = 10^{-4}\\).
Для решения задачи выполнить следующие шаги:

<ol> <li>Написать функцию, представляющую правую часть уравнения.</li> 
<li>Написать функцию метода половинного деления.</li> 
<li>В главной функции обратиться к функции метода половинного деления.</li> 
<li>Вывести на экран значение корня, число итераций и значение погрешности метода.</li> </ol></p>

<h4>Алгоритм поиска корней уравнения методом половинного деления с учётом погрешностей</h4>

<p>Шаг 1: Задим функцию для правой части уравнения:</p>
<pre><code class="language-julia">
using Measurements

function f(x)
    return sin(x) + x - 0.5
end
</code></pre>

<p>Шаг 2: Определим константы для алгоритма:</p>
<pre><code class="language-julia">
const MAX_ROOTS = 100  # максимальное количество корней
const STEP = 0.1       # шаг сканирования интервала
</code></pre>

<p>Шаг 3: Ввод данных с консоли </p>
<pre><code class="language-julia">
println("Введите точность (эпсилон): ")
eps = parse(Float64, readline())

println("Введите начало отрезка:")
a_input = readline()
a = if occursin("±", a_input)
    parts = split(a_input, "±")
    val = parse(Float64, strip(parts[1]))
    unc = parse(Float64, strip(parts[2]))
    val ± unc
else
    parse(Float64, a_input) ± 0.0
end
</code></pre>

<p>Шаг 4: Метод половинного деления, функция для нахождения корня:</p>
<pre><code class="language-julia">
function pol_del(a, b, eps)
    # Проверка условий сходимости
    if Measurements.value(f(a)) * Measurements.value(f(b)) >= 0
        println("Метод не применим: f(a) и f(b) должны иметь разные знаки")
        return 0.0 ± 0.0
    end

    # Итерационный процесс
    while error >= eps || iter == 0
        # Вычисление середины интервала с учётом погрешностей
        c_val = (Measurements.value(a) + Measurements.value(b)) / 2.0
        c_unc = sqrt((Measurements.uncertainty(a)^2 + Measurements.uncertainty(b)^2) / 4.0)
        c = c_val ± c_unc
        
        # Проверка точности
        if abs(Measurements.value(f(c))) < eps
            break
        end
        
        # Выбор нового интервала
        if Measurements.value(f(a)) * Measurements.value(f(c)) < 0
            b = c
        else
            a = c
        end
    end
    return c
end
</code></pre>

<p>Шаг 5: Сканирование интервала для поиска всех корней</p>
<pre><code class="language-julia">
# Инициализация массива корней
roots = Vector{Measurement{Float64}}(undef, MAX_ROOTS)
root_count = 0

# Сканирование интервала с заданным шагом
x_val = Measurements.value(a)
while x_val < Measurements.value(b)
    x_current = x_val ± Measurements.uncertainty(a)
    x_next = (x_val + STEP) ± Measurements.uncertainty(a)
    
    # Проверка смены знака функции
    if Measurements.value(f(x_current)) * Measurements.value(f(x_next)) < 0
        # Применение метода половинного деления к найденному интервалу
        root = pol_del(x_current, x_next, eps)
        
        # Сохранение корня
        if root_count < MAX_ROOTS
            roots[root_count+1] = root
            root_count += 1
        end
    end
    x_val += STEP
end
</code></pre>
<p>Добавляем главную функцию.</p>
<p>Выводим результат.</p>


	<caption><h4>Пример 2.</h4></caption>
<p>Дано нелинейное уравнение \\[ \\sin x + x - 0.5 = 0 \\] Отделить его корни на отрезке \\([-2; 2]\\) с шагом \\(0.1\\). Провести уточнение корней уравнения методом Ньютона с точностью
 \\(\\varepsilon = 10^{-4}\\).
Для решения задачи выполнить следующие шаги:

<ol> <li>Написать функцию, представляющую правую часть уравнения.</li> 
<li>Написать функцию, представляющую производную правой части уравнения.</li> 
<li>Написать функцию, представляющую вторую производную правой части уравнения.</li> 
<li>Написать функцию метода Ньютона, в которой проверить условие сходимости метода.</li> 
<li>В главной функции обратиться к функции метода Ньютона.</li> 
<li>Вывести на экран значение корня, число итераций и значение погрешности метода.</li> </ol></p>

<h4>Алгоритм решения уравнений методом Ньютона с учётом погрешностей</h4>

<p>Вводим заданную функцию</p>
<p>Шаг 1: Метод Ньютона</p>
<pre><code class="language-julia">
function newton_method(x0, eps)
    x = x0
    iter = 0
    
    while iter < MAX_ITERATIONS
        # Вычисление функции и её производной
        fx = f(x)
        dfx = ForwardDiff.derivative(f, x)
        
        # Проверка деления на ноль
        if abs(Measurements.value(dfx)) < eps
            return (false, 0.0 ± 0.0, 0.0, 0)
        end
        
        x_prev = x
        
        # Формула Ньютона
        x = x - fx / dfx
        iter += 1
        
        # Проверка условия остановки
        if abs(Measurements.value(x - x_prev)) < eps
            # Оценка погрешности
            d2f_x = ForwardDiff.derivative(x -> ForwardDiff.derivative(f, x), x)
            M = abs(Measurements.value(d2f_x))
            m = abs(Measurements.value(dfx))
            error = M / (2 * m) * abs(Measurements.value(x - x_prev))
            
            return (true, x, error, iter)
        end
    end
    
    return (false, 0.0 ± 0.0, 0.0, 0)
end
</code></pre>

<p>Шаг 4: Выполнение алгоритма</p>
<pre><code class="language-julia">
success, root, error, iter = newton_method(x0, eps)
</code></pre>

<p>Примечания:</p>
<ul>
    <li>Для работы требуются библиотеки Measurements.jl и ForwardDiff.jl</li>
    <li>ForwardDiff.jl используется для автоматического вычисления производных</li>
</ul>
<p>Добавляем главную функцию.</p>
<p>Выводим результат.</p>
	
	<caption><h4>Пример 3.</h4></caption>
<p><strong>Задание.</strong> Дано нелинейное уравнение  \\[\\sin x + x - 0.5 = 0\\].  Отделить его корни на отрезке \\([-2; 2]\\) с шагом \\(0.1\\). Провести уточнение корней уравнения методом 
простой итерации с точностью \\(\\varepsilon = 10^{-4}\\).  

Для решения задачи выполнить следующие шаги:  
<ol>
<li>Написать функцию, представляющую правую часть уравнения.</li>
<li>Написать функцию, представляющую производную правой части уравнения.</li>
<li>Написать функцию приведения уравнения к виду, удобному для применения метода простой итерации.</li>
<li>Написать функцию метода простой итерации, в которой проверить условие сходимости метода.</li>
<li>В главной функции обратиться к функции метода простой итерации.</li>
<li>Вывести на экран значение корня, число итераций и значение погрешности метода.</li>
</ol></p>

<h4>Алгоритм решения уравнений методом простой итерации с учётом погрешностей</h4>

<p>Вводим заданную функцию</p>
<p>Шаг 1: Проверка условия сходимости</p>
<pre><code class="language-julia">
# Вычисление производной преобразования
function phi_derivative(x, lambda)
    return 1 + lambda * ForwardDiff.derivative(f, x)
end

# Проверка условия сходимости
function check_cx(x0, lambda)
    derivative_value = phi_derivative(Measurements.value(x0), Measurements.value(lambda))
    return abs(derivative_value) < 1
end
</code></pre>

<p>Шаг 2: Метод простой итерации</p>
<pre><code class="language-julia">
function simple_iter_met(x0, eps, lambda)
    # Проверка условия сходимости
    if !check_cx(x0, lambda)
        println("Условие сходимости не выполнено.")
        return (false, 0.0 ± 0.0, 0.0, 0)
    end
    
    root = x0
    iter = 0
    
    while iter < MAX_ITERATIONS
        # Итерационная формула
        x_new = phi(root, lambda)
        iter += 1
        
        # Проверка условия остановки
        diff = abs(Measurements.value(x_new) - Measurements.value(root))
        if diff < eps
            # Оценка погрешности
            error = Q_VALUE / (1 - Q_VALUE) * diff
            return (true, x_new, error, iter)
        end
        
        root = x_new
    end
    
    return (false, 0.0 ± 0.0, 0.0, 0)
end
</code></pre>
<p>Добавляем главную функцию.</p>
<p>Выводим результат.</p>
`,
         "test": {
            "timeLimit": 600,
            "questions": [
      {
        "question": "Какие из следующих условий необходимы для применения метода половинного деления?",
        "answers": [
          {
            "text": "Функция \\(f(x)\\) должна быть непрерывна на отрезке \\([a, b]\\).",
            "correct": true
          },
          {
            "text": "На концах отрезка функция должна принимать значения одного знака: \\(f(a)\\cdot f(b) > 0\\).",
            "correct": false
          },
          {
            "text": "Функция \\(f(x)\\) должна быть дифференцируема на отрезке \\([a, b]\\).",
            "correct": false
          }
        ],
        "type": "single"
      },
      {
        "question": "Какие утверждения справедливы для метода Ньютона (метода касательных)?",
        "answers": [
          {
            "text": "Для его применения необходимо знать не только саму функцию \\(f(x)\\), но и её первую производную \\(f'(x)\\).",
            "correct": true
          },
          {
            "text": "В качестве начального приближения можно выбрать любую точку, принадлежащую отрезку \\([a, b]\\).",
            "correct": false
          },
          {
            "text": "Начальное приближение \\(x_0\\) следует выбирать так, чтобы знак функции \\(f(x_0)\\) совпадал со знаком второй производной \\(f''(x_0)\\).",
            "correct": true
          }
        ],
        "type": "multiple"
      },
      {
        "question": "Для сходимости метода простой итерации \\(x_{k+1} = \\varphi(x_k)\\) необходимо выполнение условия:",
        "answers": [
          {
            "text": "\\(\\left| \\varphi'(x) \\right| > 1\\) в окрестности корня.",
            "correct": false
          },
          {
            "text": "\\(\\left| \\varphi'(x) \\right| < 1\\) в окрестности корня.",
            "correct": true
          },
          {
            "text": "Функция \\(\\varphi(x)\\) должна быть монотонной.",
            "correct": false
          }
        ],
        "type": "single"
      },
      {
        "question": "В чем заключается основная идея преобразования уравнения \\(f(x)=0\\) к виду \\(x = \\varphi(x)\\) для метода простой итерации?",
        "answers": [
          {
            "text": "Уравнение умножают на произвольную константу и прибавляют \\(x\\) к обеим частям, чтобы получить \\(\\varphi(x) = x + \\lambda f(x)\\).",
            "correct": true
          },
          {
            "text": "Уравнение заменяют на эквивалентное так, чтобы производная \\(\\varphi'(x)\\) по модулю стала меньше 1.",
            "correct": true
          },
          {
            "text": "Функцию \\(\\varphi(x)\\) всегда выбирают равной \\(f(x)\\), чтобы упростить вычисления.",
            "correct": false
          }
        ],
        "type": "multiple"
      },
      {
        "question": "Какие из перечисленных утверждений верны относительно прекращения итерационного процесса в рассмотренных методах?",
        "answers": [
          {
            "text": "В методе половинного деления процесс останавливают, когда длина текущего отрезка становится меньше заданной точности \\(\\varepsilon\\).",
            "correct": true
          },
          {
            "text": "В методе Ньютона и методе простой итерации процесс останавливают, когда модуль разности двух последовательных приближений становится меньше \\(\\varepsilon\\).",
            "correct": true
          },
          {
            "text": "Итерационный процесс всегда прекращают после выполнения заранее заданного фиксированного числа шагов.",
            "correct": false
          }
        ],
        "type": "multiple"
      }
         ]
        }
    },
    topic03: {
           "title": "Численные методы решения систем линейных уравнений",
           "theory": `
	<h1><i>Численные методы решения систем линейных уравнений</i></h1>
        <h2><i>Прямые методы решения СЛАУ</i></h2>\n
	<p>При конструировании многих инженерных сооружений, обработке результатов измерений, решении задач планирования производственного процесса и ряда других задач техники, 
экономики приходится решать системы линейных уравнений с многозначными коэффициентами; при этом встречаются системы с большим числом неизвестных.</p>\n
	<p>Численные методы решения систем линейных уравнений делятся на <font color='#ff0000'>две группы</font>:</p>\n
	<ol>\n    <li>Прямые;</li>\n    
		  <li>Итерационные.</li>\n</ol>\n
	<p><font color='#ff0000'>Прямые методы</font> иногда называют точными, так как решение выражается в виде точных формул через коэффициенты системы.</p>\n
	<p>Однако точное решение может быть получено лишь при точном выполнении вычислений (без округлений промежуточных результатов) и при точных коэффициентах системы. На практике
 коэффициенты являются приближенными числами и при использовании компьютеров вычисления проводятся с погрешностями, поэтому неизбежны погрешности и в окончательных результатах 
(неустранимая погрешность коэффициентов, погрешность округления).</p>\n<p><font color='#ff0000'>Итерационные методы</font> — это методы последовательных приближений.</p>\n
	<p>В них необходимо задать некоторое приближенное решение — начальное приближение, после чего с помощью заданного алгоритма проводится один цикл вычислений, называемый 
<font color='#ff0000'>итерацией</font>. В результате итерации находится новое приближение. Итерации проводят до тех пор, пока не будет получено решение с заданной точностью. Важное 
достоинство итерационных методов состоит в том, что погрешности окончательных результатов не накапливаются, поскольку точность вычислений на каждой итерации определяется результатами 
предыдущей итерации и не зависит от выполненных вычислений.</p>\n
		<br>\n<p>Будем рассматривать систему из трех уравнений, но методы, которые рассмотрим, можно применять для систем с любым числом уравнений.</p>\n
	<p>Неизвестные будем обозначать \\(x_{1},x_{2},...,x_{n}\\), коэффициенты при неизвестных буквой \\(a\\) с двумя индексами.</p>\n
	<p>Система из трех уравнений с тремя неизвестными запишется в виде: \\[\\begin{cases} a_{11}x_{1}+a_{12}x_{2}+a_{13}x_{3} = b_{1} \\\\ a_{21}x_{1}+a_{22}x_{2}+a_{23}x_{3} = b_{2} \\\\ a_{31}x_{1}+a_{32}x_{2}+a_{33}x_{3} = b_{3} \\end{cases}\\tag{1.1}\\]</p>\n
	<p>Решением системы (1.1) называется <font color='#ff0000'>совокупность значений неизвестных</font> \\(x_{1},x_{2},x_{3}\\), которые при подстановке в данную систему обращают все уравнения в равенства.</p>\n\n
	
	<h2><i>Прямые (точные) методы решения СЛАУ</i></h2>\n
	<h2><i>Метод Гаусса</i></h2>\n
	<p><font color='#ff9100'>Суть метода Гаусса</font> состоит в последовательном исключении неизвестных переменных. Сначала исключается \\(x_{1}\\) из всех уравнений системы, 
начиная со второго, далее исключается \\(x_{2}\\) из всех уравнений, начиная с третьего, и так далее до тех пор, пока в последнем уравнении не останется только \\(x_{n}\\). Таким образом 
приходят к треугольной системе. Такой процесс преобразования уравнений называется <font color='#ff0000'>прямым ходом</font>. Пользуясь треугольной системой, находят значения всех 
неизвестных. Эта процедура называется <font color='#ff0000'>обратным ходом</font>.</p>\n\n
	
	<h3><font color='#ff9100'>Вычислительная схема</font></h3>\n
	<p>Рассмотрим систему с тремя неизвестными (неизвестные обозначим \\(x_{1},x_{2},x_{3}\\)). \\[\\begin{cases} a_{11}x_{1}+a_{12}x_{2}+a_{13}x_{3} = b_{1} \\\\
 a_{21}x_{1}+a_{22}x_{2}+a_{23}x_{3} = b_{2} \\\\ a_{31}x_{1}+a_{32}x_{2}+a_{33}x_{3} = b_{3} \\end{cases}\\tag{1.1}\\]</p>\n
	<p>В такой системе один из диагональных коэффициентов \\(a_{11}, a_{22}, a_{33}\\) отличен от нуля.</p>\n
		<ol>\n    <li>Уравнения нужно переставить таким образом, чтобы на месте первого уравнения было уравнение с максимальным отличным от нуля коэффициентом при \\(x_{1}\\);</li>\n    
			  <li>Введем множитель \\(m_{2}=\\dfrac{a_{21}}{a_{11}}\\) для второго уравнения;</li>\n    
			  <li>Умножим первое уравнение системы (1.1) на \\(m_{2}\\) и вычтем его из второго уравнения. При этом получим: \\[(a_{22}-m_{2}a_{12})x_{2}+(a_{23}-m_{2}a_{13})x_{3}=b_{2}-m_{2}b_{1}\\tag{1.2}\\]</li>\n    
	<p>Обозначим: </p>\n    
	<p>\\[a_{22}-m_{2}a_{12}\\rightarrow a_{22}^{(1)}\\]</p>\n    
	<p>\\[a_{23}-m_{2}a_{13}\\rightarrow a_{23}^{(1)}\\]</p>\n    
	<p>\\[b_{2}-m_{2}b_{1}\\rightarrow b_{2}^{(1)}\\]</p>\n    
	<p>(1.2) примет вид: \\[a_{22}^{(1)}x_{2}+a_{23}^{(1)}x_{3}=b_{2}^{(1)}\\tag{1.3}\\]</p>\n    
		<li>Выведем множитель \\(m_{3}=\\dfrac{a_{31}}{a_{11}}\\) для третьего уравнения;</li>\n    
		<li>Умножим первое уравнение системы (1.1) на \\(m_{3}\\) и вычтем его из третьего уравнения. Получим: \\[(a_{32}-m_{3}a_{12})x_{2}+(a_{33}-m_{3}a_{13})x_{3}=b_{3}-m_{3}b_{1}\\tag{1.4}\\]</li>\n    
	<p>Обозначим: \\[a_{32}-m_{3}a_{12}\\rightarrow a_{32}^{(1)}\\]</p>\n    
	<p>\\[a_{33}-m_{3}a_{13}\\rightarrow a_{33}^{(1)}\\]</p>\n    
	<p>\\[b_{3}-m_{3}b_{1}\\rightarrow b_{3}^{(1)}\\]</p>\n    
	<p>Тогда (1.4) примет вид: \\[a_{32}^{(1)}x_{2}+a_{33}^{(1)}x_{3}=b_{3}^{(1)}\\tag{1.5}\\]</p>\n   
		 <li>Система уравнений (1.1) примет вид: \\[\\begin{cases} a_{11}x_{1}+a_{12}x_{2}+a_{13}x_{3} = b_{1} \\\\ a_{22}^{(1)}x_{2}+a_{23}^{(1)}x_{3}=b_{2}^{(1)} \\\\ a_{32}^{(1)}x_{2}+a_{33}^{(1)}x_{3}=b_{3}^{(1)} \\end{cases}\\tag{1.6}\\]</li>\n    
		 <li>Исключаем \\(x_{2}\\) из последнего уравнения системы (1.6) аналогично. При необходимости выполнив перестановку. Для этого введем множитель 
\\(m_{3}^{(1)}=\\dfrac{a_{32}^{(1)}}{a_{22}^{(1)}}\\). Умножим второе уравнение системы (1.6) на \\(m_{3}^{(1)}\\) и вычтем из третьего. Получим: \\[(a_{33}^{(1)}-m_{3}^{(1)}a_{23}^{(1)})x_{3}=b_{3}^{(1)}-m_{3}^{(1)}b_{2}^{(1)}\\tag{1.7}\\]</li>\n    
	<p>Обозначим: \\[a_{33}^{(1)}-m_{3}^{(1)}a_{23}^{(1)}\\rightarrow a_{33}^{(2)}\\]</p>\n    
	<p>\\[b_{3}^{(1)}-m_{3}^{(1)}b_{2}^{(1)}\\rightarrow b_{3}^{(2)}\\]</p>\n    
	<p>Тогда (1.7) примет вид: \\[a_{33}^{(2)}x_{3}=b_{3}^{(2)}\\tag{1.8}\\]</p>\n    
		  <li>Система (1.6) примет вид: \\[\\begin{cases} a_{11}x_{1}+a_{12}x_{2}+a_{13}x_{3} = b_{1} \\\\ a_{22}^{(1)}x_{2}+a_{23}^{(1)}x_{3}=b_{2}^{(1)} \\\\ a_{33}^{(2)}x_{3}=b_{3}^{(2)} \\end{cases}\\tag{1.9}\\]</li>\n</ol>\n
	<p>(1.9) называется <font color='#ff0000'>треугольной</font>.</p>\n
	<p>Для вычисления неизвестных \\(x_{1},x_{2},x_{3}\\) надо выполнить обратную подстановку.</p>\n\n
	
	<h2><i>Обобщение метода Гаусса на системы из \\(n\\)-уравнений с \\(n\\)-неизвестными</i></h2>\n
	<p>В этом случае система будет иметь вид: \\[\\begin{cases} a_{11}x_{1}+a_{12}x_{2}+...+a_{1n}x_{n}=b_{1} \\\\ a_{21}x_{1}+a_{22}x_{2}+...+a_{2n}x_{n}=b_{2} \\\\ ............................... \\\\ a_{n1}x_{1}+a_{n2}x_{2}+...+a_{nn}x_{n}=b_{n} \\end{cases}\\tag{1}\\]</p>\n
	<p>На некотором \\(k\\)-ом этапе исключаем \\(x_{k}\\) с помощью множителей \\[m_{i}^{(k)}=\\frac{a_{ik}^{(k-1)}}{a_{kk}^{(k-1)}},\\;\\;\\;\\;i=k+1,...,n\\tag{2}\\]</p>\n
	<p>\\[a_{ij}^{(k)}=a_{ij}^{(k-1)}-m_{i}^{(k)}a_{kj}^{(k-1)}\\tag{3}\\]</p>\n
	<p>\\[b_{i}^{(k)}=b_{i}^{(k-1)}-m_{i}^{(k)}b_{k}^{(k-1)},\\;\\;\\;\\;i=k+1,...,n,\\;\\;\\;j=k,...,n\\tag{4}\\]</p>\n
	<p>Индекс \\(k\\) принимает целые значения от \\(1\\) до \\(n-1\\) включительно. При \\(k=n-1\\) происходит исключение \\(x_{n-1}\\) из последнего уравнения.</p>\n
	<p>Треугольная система будет иметь вид: \\[\\begin{cases} a_{11}x_{1}+a_{12}x_{2}+...+a_{1n}x_{n}=b_{1} \\\\ a_{22}^{(1)}x_{2}+...+a_{2n}^{(1)}x_{n}=b_{2}^{(1)} \\\\ ..............................\\\\ a_{nn}^{(n-1)}x_{n}=b_{n}^{(n-1)} \\end{cases}\\tag{5}\\]</p>\n
	<p>После приведения системы к треугольному виду надо выполнить <font color='#ff0000'>обратную подстановку</font> по формулам: \\[x_{n}=\\frac{b_{n}^{(n-1)}}{a_{nn}^{(n-1)}}\\tag{6}\\]</p>\n<p>\\[x_{i}=\\frac{b_{i}^{(i-1)}-\\sum_{j=i+1}^{n}{a_{ij}^{(i-1)}x_{j}}}{a_{ii}^{(i-1)}},\\;\\;\\;\\;i=n-1,...,1\\tag{7}\\]</p>\n<p>Индексы \\(i,j,k\\) означают следующее:</p>\n
	<p>\\(k\\) — номер того уравнения, которое вычитается из остальных, а также номер того неизвестного, который исключается из оставшихся \\((n-k)\\) уравнений;</p>\n
	<p>\\(i\\) — номер того уравнения, из которого в данный момент исключается неизвестное;</p>\n	
	<p>\\(j\\) — номер столбца.</p>\n
	<p>Метод Гаусса относится к <font color='#ff0000'>прямым методам решения</font>, поэтому он должен был бы давать точное решение задачи (1.1) за конечное число действий.</p>\n
	<p>Однако при задании на ЭВМ исходной информации (матрицы и вектора) неизбежно вносятся погрешности округления. Поэтому при проведении вычислений на ЭВМ точное решение почти никогда не достигается.
 Результирующая погрешность вычислений тем больше, чем выше порядок матрицы. Кроме того, точность вычислений зависит и от вида матрицы, например, велика погрешность при решении систем 
уравнений с определителем, близким к 0. Но накопление погрешностей округления не говорит о том, что метод Гаусса является непригодным. Ведь часто требуется знать решение не абсолютно 
точно, а лишь с какой-то степенью точности. Важно, чтобы результирующая погрешность вычислений находилась в пределах заданной точности. Для этого необходимо проводить анализ влияния 
погрешностей округления на точность алгоритма. (Полное проведение такого анализа является трудоемким процессом, поэтому его рассматривать не будем).</p>\n\n
	
	<h3>Функция для метода Гаусса на Julia:</h3>
		<div class="code-container">
       		 <div class="code-header">
            		Метод Гаусса
           		 <span class="language-label">JULIA</span>
        	 </div>
       		 <pre><code class="language-julia"># Функция Гаусса
function gauss(mat, arr)
    n = size(mat, 1)
    
    for k in 1:n-1
        # Выбор главного элемента с использованием argmax(мндекс макс эл)
        gl_el = k + argmax(abs.(mat[k:n, k])) - 1
        
        if gl_el != k
            # Перестановка 
            mat[[k, gl_el], :] = mat[[gl_el, k], :]
            arr[[k, gl_el]] = arr[[gl_el, k]]
        end
        
        # Векторизованное исключение переменных
        for i in k+1:n
            factor = mat[i, k] / mat[k, k]
            mat[i, k:n] -= factor * mat[k, k:n]
            arr[i] -= factor * arr[k]
        end
    end
end</code></pre>
	        </div>
	
	<h2><i>Метод простых итераций (метод Якоби)</i></h2>\n
	<p>Для сходимости итерационного процесса достаточно выполнения одного из условий.</p>\n
	<p><font color='#ff9100'><font size=\"4\">Условие 1:</font></font> сумма модулей коэффициентов при неизвестных в каждом уравнении меньше единицы \\[\\sum_{j=1}^{n}{\\left|a_{ij} \\right|}<1 \\;\\;\\;(i=1,2,...,n)\\]</p>\n
	<p><font color='#ff9100'><font size=\"4\">Условие 2:</font></font> сумма квадратов всех коэффициентов при неизвестных меньше единицы \\[\\sum_{i=1}^{n}{}\\sum_{j=1}^{n}a_{ij}^{2} <1\\]</p>\n
	<p>Для того, чтобы проверить выполнение условий, нужно сначала привести систему к виду с диагональным преобладанием, затем к нормальному виду: \\[\\begin{cases} x_{1}=a_{12}x_{2}+...+a_{1n}x_{n}+b_{1} \\\\ x_{2}=a_{21}x_{1}+...+a_{2n}x_{n}+b_{2} \\\\ ........................... \\\\ x_{n}=a_{n1}x_{1}+...+a_{n,n-1}x_{n-1}+b_{n} \\end{cases}\\tag{2.1}\\]</p>\n
	<p>Если для каждого уравнения одно из условий выполняется, значит итерационный процесс сходится. Поэтому можно получить приближенное решение системы методом итераций Якоби.</p>\n
	<p>Рассмотрим систему из трех уравнений с тремя неизвестными: \\[\\begin{cases} a_{11}x_{1}+a_{12}x_{2}+a_{13}x_{3}=b_{1} \\\\ a_{21}x_{1}+a_{22}x_{2}+a_{23}x_{3}=b_{2} \\\\ a_{31}x_{1}+a_{32}x_{2}+a_{33}x_{3}=b_{3} \\end{cases}\\tag{2.2}\\]</p>\n
	<p>Предположим, что диагональные элементы отличны от нуля.</p>\n
	<p>Выразим неизвестные \\(x_{1},x_{2},x_{3}\\) из первого, второго, третьего уравнений системы (2.2):</p>\n
	<p>\\[\\begin{cases}x_{1}=\\frac{1}{a_{11}}(b_{1}-a_{12}x_{2}-a_{13}x_{3}) \\\\ x_{2}=\\frac{1}{a_{22}}(b_{2}-a_{21}x_{1}-a_{23}x_{3}) \\\\ x_{3}=\\frac{1}{a_{33}}(b_{3}-a_{31}x_{1}-a_{32}x_{2})\\end{cases}\\tag{2.3}\\]</p>\n
	<p>С учетом выражений (2.3) построим итерационный процесс метода Якоби, в котором приближение с номером \\(k+1\\) вычисляется на основе приближения с номером \\(k\\) следующим образом:</p>\n
	<p>\\[\\begin{cases}x^{(k+1)}_{1}=\\frac{1}{a_{11}}\\left(b_1-a_{12}x^{(k)}_2-a_{13}x^{(k)}_3-...-a_{1n}x^{(k)}_n\\right)\\\\ x^{(k+1)}_{2}=\\frac
{1}{a_{22}}\\left(b_2-a_{21}x^{(k)}_1-a_{23}x^{(k)}_3-...-a_{2n}x^{(k)}_n\\right)\\\\ ..............................................\\\\ x^{(k+1)}_{n}=\\frac{1}{a_{nn}}\\left(b_n-a_
{n1}x^{(k)}_1-a_{n2}x^{(k)}_2-...-a_{n,n-1}x^{(k)}_{n-1}\\right)\\end{cases}\\tag{2.4}\\]</p>\n
	<p>\\((k=0,1,...,n)\\)</p>\n
	<p>В качестве вектора начальных приближений можно взять любые произвольные значения неизвестных. Иногда берут столбец свободных элементов. Однако наиболее целесообразно в качестве
 компонент вектора \\(x^0\\) взять нулевой вектор.</p>\n
	<p>Итерационный процесс заканчивается, если выполняется условие: \\[\\max\\left|x^{(k+1)}_i-x^{(k)}_i \\right|< \\varepsilon\\tag{2.5}\\]</p>\n<p>\\(i=1,2,...,n\\), \\
(k=0,1,...,n\\), \\(\\varepsilon\\) — заданная точность.</p>\n<p>Абсолютная погрешность приближенного решения \\(x^{(k)}\\) вычисляется по формуле: \\[R\\leq \\frac{1}{1-\\alpha}\\cdot 
\\max\\left|x^{(k+1)}_i-x^{(k)}_i \\right|\\tag{2.6}\\]</p>\n
	<p>где \\(\\alpha\\) — максимальная сумма модулей коэффициентов при неизвестных в каждом уравнении.</p>\n<br>\n
	<p><font color='#ffa726'><font size=\"4\">Пример.</font></font> Решить систему линейных уравнений методом итераций Якоби с точностью \\(10^{-3}\\):</p>\n<p>\\[\\begin{cases} 
20,9x_{1}+1,2x_{2}+2,1x_{3}+0,9x_{4}=21,70 \\\\ 1,2x_{1}+21,2x_{2}+1,5x_{3}+2,5x_{4}=27,46 \\\\ 2,1x_{1}+1,5x_{2}+19,8x_{3}+1,3x_{4}=28,76 \\\\ 0,9x_{1}+2,5x_{2}+1,3x_{3}+32,1x_{4}=49,72 
\\end{cases}\\]</p>\n
	
	<h4><font color='#ffa726'>Решение:</font></h4>\n
	<p>Данная система является системой с диагональным преобладанием, поэтому приведем ее к виду (2.1):</p>\n
	<p>\\[\\begin{cases} x_{1}=0,057x_{2}+0,100x_{3}+0,043x_{4}-1,038 \\\\ x_{2}=0,056x_{1}+0,070x_{3}+0,117x_{4}-1,295 \\\\ x_{3}=0,106x_{1}+0,075x_{2}+0,065x_{4}-1,449 \\\\ 
x_{4}=0,028x_{1}+0,077x_{2}+0,040x_{3}-1,548 \\end{cases}\\]</p>\n
	<p>Проверим условия сходимости №1. Для этого нужно найти норму матрицы, то есть просуммировать по модулю элементы в каждой строке.</p>\n
	<p>\\[\\sum_{j=1}^{4}{\\left|a_{1j} \\right|}=0,057+0,100+0,043\\approx 0,20<1\\]</p>\n<p>\\[\\sum_{j=1}^{4}{\\left|a_{2j} \\right|}=0,056+0,070+0,117\\approx 0,24<1\\]</p>\n
	<p>\\[\\sum_{j=1}^{4}{\\left|a_{3j} \\right|}=0,106+0,075+0,065\\approx 0,25<1\\]</p>\n<p>\\[\\sum_{j=1}^{4}{\\left|a_{4j} \\right|}=0,028+0,077+0,040\\approx 0,15<1\\]</p>\n
	<p>Коэффициенты удовлетворяют условию сходимости, значит, метод итераций сходится.</p>\n<p>Возьмем начальные приближения \\(x_{1}^{(0)}=x_{2}^{(0)}=x_{3}^{(0)}=x_{4}^{(0)}=0\\).</p>\n
	<p>Последовательно по формулам (2.4) получаем (при \\(k=1\\)):</p>\n
	<p>\\[x_{1}^{(1)}=\\frac{1}{20,9}(21,7-1,2\\cdot0-2,1\\cdot0-0,9\\cdot0)=1,038\\]</p>\n
	<p>\\[x_{2}^{(1)}=\\frac{1}{21,2}(27,46-1,2\\cdot0-1,5\\cdot0-2,5\\cdot0)=1,295\\]</p>\n
	<p>\\[x_{3}^{(1)}=\\frac{1}{19,8}(28,76-2,1\\cdot0-1,5\\cdot0-1,3\\cdot0)=1,452\\]</p>\n
	<p>\\[x_{4}^{(1)}=\\frac{1}{32,1}(49,72-0,9\\cdot0-2,5\\cdot0-1,3\\cdot0)=1,548\\]</p>\n
	<p>Вычислим модули разности значений \\(x_{i}^{(k)}\\) при \\(k=1\\):</p>\n
	<p>\\[\\left|x_{1}^{(1)}-x_{1}^{(0)} \\right|=1,038\\]</p>\n<p>\\[\\left|x_{2}^{(1)}-x_{2}^{(0)} \\right|=1,295\\]</p>\n
	<p>\\[\\left|x_{3}^{(1)}-x_{3}^{(0)} \\right|=1,452\\]</p>\n<p>\\[\\left|x_{4}^{(1)}-x_{4}^{(0)} \\right|=1,548\\]</p>\n
	<p>Так как все они больше заданного числа \\(\\varepsilon =10^{-3}\\), вычисляем следующее приближение (при \\(k=2\\)):</p>\n
	<p>\\[x_{1}^{(2)}=\\frac{1}{20,9}(21,7-1,2\\cdot1,295-2,1\\cdot1,452-0,9\\cdot1,548)=0,751\\]</p>\n
	<p>\\[x_{2}^{(2)}=\\frac{1}{21,2}(27,46-1,2\\cdot1,038-1,5\\cdot1,452-2,5\\cdot1,548)=0,951\\]</p>\n
	<p>\\[x_{3}^{(2)}=\\frac{1}{19,8}(28,76-2,1\\cdot1,038-1,5\\cdot1,295-1,3\\cdot1,548)=1,142\\]</p>\n
	<p>\\[x_{4}^{(2)}=\\frac{1}{32,1}(49,72-0,9\\cdot1,038-2,5\\cdot1,295-1,3\\cdot1,452)=1,360\\]</p>\n
	<p>Находим модули разностей \\(x_{i}^{(k)}\\):</p>\n<p>\\[\\left|x_{1}^{(2)}-x_{1}^{(1)} \\right|=0,287\\]</p>\n
	<p>\\[\\left|x_{2}^{(2)}-x_{2}^{(1)} \\right|=0,344\\]</p>\n<p>\\[\\left|x_{3}^{(2)}-x_{3}^{(1)} \\right|=0,310\\]</p>\n
	<p>\\[\\left|x_{4}^{(2)}-x_{4}^{(1)} \\right|=0,188\\]</p>\n<p>Они больше \\(\\varepsilon\\), следует вычислять следующее приближение.</p>\n
	<p>Вычислим абсолютную погрешность по формуле (2.6):</p>\n<p>\\(\\alpha =0,25\\)</p>\n
	<p>\\[R=\\frac{0,25}{1-0,25}\\cdot \\max \\left|x^{(k+1)}_i-x^{(k)}_i \\right|\\]</p>\n\n
	
	<h3>Функция для метода Якоби на Julia:</h3>
		<div class="code-container">
       		 <div class="code-header">
            		Метод Якоби
           		 <span class="language-label">JULIA</span>
        	 </div>
       		 <pre><code class="language-julia"># Метод Якоби 
function jacobi(mat, arr; x0=zeros(size(arr)), max_iter=100, tol=1e-6)
    n = length(arr)
    x = copy(x0)
    x_next = similar(x)
    
    D = Diagonal(diag(mat))
    R = mat - Matrix(D)
    D_inv = inv(D)
    
    for iter in 1:max_iter
        x_next = D_inv * (arr - R * x)    
        # Проверка сходимости
        delta = norm(x_next - x, Inf)
        x, x_next = x_next, x
        
        if delta < tol
            println("\n Сходимость достигнута на итерации $iter")
            return x, iter, true
        end
    end
    
    println("\n Достигнут максимум итераций")
    return x, max_iter, false
end</code></pre>
	        </div>

	<h1><i>Итерационные методы решения СЛАУ</i></h1>\n
	<h2><i>Метод Зейделя</i></h2>\n
	<p>Метод Зейделя является модификацией метода итерации Якоби. Он заключается в том, что при вычислении \\(k+1\\)-го приближения неизвестного \\(x_{i}\\) при \\(i>1\\) используются
 уже вычисленные ранее \\(k+1\\)-е приближения неизвестных \\(x_{1},x_{2},...,x_{i-1}\\). Таким образом, для системы:</p>\n
	<p>\\[\\begin{cases} a_{11}x_{1}+a_{12}x_{2}+...+a_{1n}x_{n}=b_{1} \\\\ a_{21}x_{1}+a_{22}x_{2}+...+a_{2n}x_{n}=b_{2} \\\\ ..............................\\\\ a_{n1}x_{1}+a_{n2}x_{2}+...+a_{nn}x_{n}=b_{n} \\end{cases}\\tag{3.1}\\]</p>\n
	<p>где \\(a_{11}\\neq 0,\\;a_{22}\\neq 0,...,a_{nn}\\neq 0\\).</p>\n
	<p>Вычисления по методу Зейделя ведутся по формулам:</p>\n
	<p>\\[\\begin{cases}x^{(k+1)}_1=\\frac{1}{a_{11}}\\left(b_1-a_{12}x^{(k)}_2-a_{13}x^{(k)}_3 -...-a_{1n}x^{(k)}_n\\right)\\\\ x^{(k+1)}_2=\\frac{1}{a_{22}}\\left(b_2-a_{21}x^{(k+1)}
_1-a_{23}x^{(k)}_3-...-a_{2n}x^{(k)}_n \\right)\\\\........................................\\\\ x^{(k+1)}_n=\\frac{1}{a_{nn}}\\left(b_n-a_{n1}x^{(k+1)}_1-a_{n2}x^{(k+1)}_2-...-a_{n,n-1}
x^{(k+1)}_{n-1}\\right)\\end{cases}\\tag{3.2}\\]</p>\n
	<p>Указанные для итераций Якоби условия сходимости остаются верными и для метода Зейделя. Метод Зейделя дает лучшую сходимость, чем метод Якоби. Кроме того, метод Зейделя
 оказывается более удобным в программировании, так как при вычислении \\(x_{i}^{(k+1)}\\) нет необходимости хранить значения \\(x_{1}^{(k)},...,x_{i-1}^{(k)}\\).</p>\n
	<p>Итерационный процесс заканчивается при выполнении условия \\[\\max\\left|x^{(k+1)}_i-x^{(k)}_i \\right|< \\varepsilon\\tag{3.3}\\]</p>\n
	<p>\\((i=1,2,...,n,\\;k=0,1,...,m\\))</p>\n
	<p>Абсолютная погрешность вычисляется по формуле: \\[R\\leq \\frac{1}{1-\\alpha}\\cdot \\max\\left|x^{(k+1)}_i-x^{(k)}_i \\right|\\tag{3.4}\\]</p>\n
	<p><font color='#ffa726'><font size=\"4\">Пример.</font></font> Решить систему, представленную в предыдущем примере, методом Зейделя с точностью \\(10^{-3}\\).</p>\n

	<h4><font color='#ffa726'>Решение:</font></h4>\n
	<p>В примере эта система была приведена к виду (2.1) и было проверено, что коэффициенты удовлетворяют условию сходимости.</p>\n
	<p>Возьмем начальные приближения \\(x_{1}^{(0)}=x_{2}^{(0)}=x_{3}^{(0)}=x_{4}^{(0)}=0\\).</p>\n
	<p>По формулам (3.2) получим при \\(k=1\\):</p>\n
	<p>\\[x_{1}^{(1)}=\\frac{1}{20,9}\\left (21,70-1,2\\cdot 0-2,1\\cdot 0-0,9\\cdot 0\\right)=1,038\\]</p>\n
	<p>При вычислении \\(x_{2}^{(1)}\\) используем уже полученное значение \\(x_{1}^{(1)}\\):</p>\n
	<p>\\[x_{2}^{(1)}=\\frac{1}{21,2}(27,46-1,2\\cdot1,038-1,5\\cdot0-2,5\\cdot0)=1,236\\]</p>\n
	<p>При вычислении \\(x_{3}^{(1)}\\) используем значения \\(x_{1}^{(1)}\\) и \\(x_{2}^{(1)}\\):</p>\n
	<p>\\[x_{3}^{(1)}=\\frac{1}{19,8}(28,76-2,1\\cdot1,038-1,5\\cdot1,236-1,3\\cdot0)=1,248\\]</p>\n
	<p>Используя \\(x_{1}^{(1)},x_{2}^{(1)},x_{3}^{(1)}\\), получаем:</p>\n
	<p>\\[x_{4}^{(1)}=\\frac{1}{32,1}(49,72-0,9\\cdot1,038-2,5\\cdot1,236-1,3\\cdot1,248)=1,373\\]</p>\n
	<p>Для того, чтобы узнать, на какой итерации будет получено решение, нужно проверить условие (3.3):</p>\n
	<p>\\[\\left|1,038-0 \\right|>0,001\\]</p>\n<p>\\[\\left|1,236-0 \\right|>0,001\\]</p>\n
	<p>\\[\\left|1,248-0 \\right|>0,001\\]</p>\n<p>\\[\\left|1,373-0 \\right|>0,001\\]</p>\n
	<p>Так как все разности получились больше \\(\\varepsilon\\), значит, решение на этой итерации не получено.</p>\n
	<p>Нужно вычислить следующее приближение при \\(k=2\\).</p>

	<h3>Функция для метода Зейделя на Julia:</h3>
		<div class="code-container">
       		 <div class="code-header">
            		Метод Зейделя
           		 <span class="language-label">JULIA</span>
        	 </div>
       		 <pre><code class="language-julia"># Метод Зейделя
function zeidel(mat, arr; x0=zeros(size(arr)), max_iter=50, eps=1e-6)
    n = length(arr)
    x = copy(x0)
    x_old = zeros(n)
    
    for iter in 1:max_iter
        x_old .= x
        for i in 1:n
            sum_val = 0.0
            for j in 1:i-1
                sum_val += mat[i,j] * x[j]
            end
            for j in i+1:n
                sum_val += mat[i,j] * x_old[j]
            end
            
            x[i] = (arr[i] - sum_val) / mat[i,i]
        end
        
        delta = maximum(abs.(x - x_old))
        
        if iter <= 5 || iter % 10 == 0 || delta < eps
            println("Итерация $iter: x = $(round.(x, digits=6)), Δ = $(round(delta, digits=8))")
        end
        
        # Условие остановки
        if delta < eps
            println("\n Сходимость достигнута на итерации $iter")
            return x, iter, true
        end
    end
    
    println("\n Достигнут максимум итераций ($max_iter)")
    return x, max_iter, false
end
</code></pre>
	        </div>
    `,
	"practica": `
	<h1><i>Численные методы решения систем линейных уравнений</i></h1>
        <h2><i>Практическая работа №3</i></h2>

	<caption><h4>Пример 1.</h4></caption>
<p>Найти решение системы линейных уравнений методом Гаусса \\[ \\begin{cases} 0.63x_1 + 0.05x_2 + 0.15x_3 = 0.34 \\\\ 0.05x_1 + 0.34x_2 + 0.1x_3 = 0.32 \\\\ 0.15x_1 + 0.1x_2 + 0.7x_3 = 0.72 \\end{cases} \\]</p>
	
<h4>Алгоритм решения систем линейных уравнений методом Гаусса</h4>

<p>Шаг 1: Чтение данных из файла</p>
<pre><code class="language-julia">
using LinearAlgebra

function read_file(filename)
    data = readlines(filename)
    
    # Чтение размерности
    n = parse(Int, data[1])
    
    # Чтение матрицы
    mat = zeros(Float64, n, n)
    for i in 1:n
        row = split(data[i+1])
        for j in 1:n
            mat[i, j] = parse(Float64, row[j])
        end
    end
    
    # Чтение вектора
    arr = zeros(Float64, n)
    vector = split(data[n+2])
    for i in 1:n
        arr[i] = parse(Float64, vector[i])
    end
    
    return mat, arr
end
</code></pre>

<p>Шаг 2: Метод Гаусса</p>
<pre><code class="language-julia">
function gauss(mat, arr)
    n = size(mat, 1)
    
    for k in 1:n-1
        # Выбор главного элемента по столбцу
        gl_el = k + argmax(abs.(mat[k:n, k])) - 1
        
        # Перестановка строк
        if gl_el != k
            mat[[k, gl_el], :] = mat[[gl_el, k], :]
            arr[[k, gl_el]] = arr[[gl_el, k]]
        end
        
        # Исключение переменных
        for i in k+1:n
            factor = mat[i, k] / mat[k, k]
            mat[i, k:n] -= factor * mat[k, k:n]
            arr[i] -= factor * arr[k]
        end
    end
end
</code></pre>

<p>Шаг 3: Обратный ход</p>
<pre><code class="language-julia">
function back_xod(mat, arr)
    n = size(mat, 1)
    x = zeros(Float64, n)
    
    # Последний элемент
    x[n] = arr[n] / mat[n, n]
    
    # Обратный ход
    for i in n-1:-1:1
        x[i] = (arr[i] - dot(mat[i, i+1:n], x[i+1:n])) / mat[i, i]
    end
    
    return x
end
</code></pre>
<p>Добавляем главную функцию.</p>
<p>Выводим результат.</p>

	
	<caption><h4>Пример 2.</h4></caption>
<p>Найти решение системы линейных уравнений методом Зейделя\\[ \\begin{cases} 0.63x_1 + 0.05x_2 + 0.15x_3 = 0.34 \\\\ 0.05x_1 + 0.34x_2 + 0.1x_3 = 0.32 \\\\ 0.15x_1 + 0.1x_2 + 0.7x_3 = 0.72 \\end{cases} \\]</p>
	
<h4>Алгоритм решения систем линейных уравнений методом Зейделя</h4>
<p>Считываем данные из файла</p>
<p>Шаг 1: Проверка условия сходимости</p>
<pre><code class="language-julia">
function check_cx(mat)
    n = size(mat, 1)
    
    for i in 1:n
        diag_val = abs(mat[i,i])
        sum_row = sum(abs.(mat[i,:])) - diag_val
        
        # Условие диагонального преобладания
        if diag_val <= sum_row
            return false
        end
    end
    return true
end
</code></pre>

<p>Шаг 2: Метод Зейделя</p>
<pre><code class="language-julia">
function zeidel(mat, arr; x0=zeros(size(arr)), max_iter=50, eps=1e-6)
    n = length(arr)
    x = copy(x0)
    x_old = zeros(n)
    
    for iter in 1:max_iter
        x_old .= x
        
        # Итерационная формула Зейделя
        for i in 1:n
            sum_val = 0.0
            
            # Сумма с уже обновленными значениями
            for j in 1:i-1
                sum_val += mat[i,j] * x[j]
            end
            
            # Сумма с предыдущими значениями
            for j in i+1:n
                sum_val += mat[i,j] * x_old[j]
            end
            
            # Вычисление нового значения
            x[i] = (arr[i] - sum_val) / mat[i,i]
        end
        
        # Проверка сходимости
        delta = maximum(abs.(x - x_old))
        if delta < eps
            return x, iter, true
        end
    end
    
    return x, max_iter, false
end
</code></pre>
<p>Добавляем главную функцию.</p>
<p>Выводим результат.</p>


	<caption><h4>Пример 3.</h4></caption>
<p>Найти решение системы линейных уравнений методом Якоби \\[ \\begin{cases} 0.63x_1 + 0.05x_2 + 0.15x_3 = 0.34 \\\\ 0.05x_1 + 0.34x_2 + 0.1x_3 = 0.32 \\\\ 0.15x_1 + 0.1x_2 + 0.7x_3 = 0.72 \\end{cases} \\]</p>

<h4>Алгоритм решения систем линейных уравнений методом Якоби</h4>
<p>Считываем данные из файла.</p>
<p>Шаг 1: Подготовка матричного представления</p>
<pre><code class="language-julia">
function jacobi(mat, arr; x0=zeros(size(arr)), max_iter=100, tol=1e-6)
    n = length(arr)
    
    # Разложение матрицы: A = D + R
    D = Diagonal(diag(mat))      # диагональная часть
    R = mat - Matrix(D)          # недиагональная часть
    D_inv = inv(D)               # обратная диагональная матрица
</code></pre>

<p>Шаг 2: Итерационный процесс метода Якоби</p>
<pre><code class="language-julia">
    x = copy(x0)                 # текущее приближение
    x_next = similar(x)          # следующее приближение
    
    for iter in 1:max_iter
        # Итерационная формула: x⁽ᵏ⁺¹⁾ = D⁻¹(b - R x⁽ᵏ⁾)
        x_next = D_inv * (arr - R * x)
        
        # Проверка сходимости
        delta = norm(x_next - x, Inf)
        x, x_next = x_next, x    # обмен значений
        
        if delta < tol
            return x, iter, true
        end
    end
    
    return x, max_iter, false
end
</code></pre>
<p>Добавляем главную функцию.</p>
<p>Выводим результат.</p>
`,
	"test": {
            "timeLimit": 600,
            "questions": [
      {
        "question": "Какие две основные группы численных методов решения систем линейных уравнений рассматриваются?",
        "answers": [
          {
            "text": "Прямые (точные) методы.",
            "correct": true
          },
          {
            "text": "Итерационные методы.",
            "correct": true
          },
          {
            "text": "Аналитические методы.",
            "correct": false
          }
        ],
        "type": "multiple"
      },
      {
        "question": "Что из перечисленного является этапами метода Гаусса?",
        "answers": [
          {
            "text": "Прямой ход — приведение системы к треугольному виду.",
            "correct": true
          },
          {
            "text": "Обратный ход — последовательное вычисление неизвестных из треугольной системы.",
            "correct": true
          },
          {
            "text": "Приведение системы к диагональному виду с последующей итерацией.",
            "correct": false
          }
        ],
        "type": "multiple"
      },
      {
        "question": "Какое из условий является достаточным для сходимости метода простых итераций (Якоби)?",
        "answers": [
          {
            "text": "Сумма модулей коэффициентов при неизвестных в каждом уравнении меньше единицы.",
            "correct": true
          },
          {
            "text": "Все диагональные элементы матрицы должны быть равны нулю.",
            "correct": false
          },
          {
            "text": "Определитель матрицы коэффициентов должен быть равен единице.",
            "correct": false
          }
        ],
        "type": "single"
      },
      {
        "question": "В чем заключается основное отличие метода Зейделя от метода Якоби?",
        "answers": [
          {
            "text": "В методе Зейделя при вычислении \\((k+1)\\)-го приближения неизвестного \\(x_i\\) используются уже вычисленные ранее \\((k+1)\\)-е приближения неизвестных \\(x_1, ..., x_{i-1}\\).",
            "correct": true
          },
          {
            "text": "Метод Зейделя требует выполнения более строгих условий сходимости, чем метод Якоби.",
            "correct": false
          },
          {
            "text": "Метод Зейделя всегда дает решение за меньшее количество итераций, чем метод Якоби.",
            "correct": true
          }
        ],
        "type": "multiple"
      },
      {
        "question": "Какие из следующих утверждений верны относительно итерационных методов решения СЛАУ?",
        "answers": [
          {
            "text": "В итерационных методах необходимо задавать начальное приближение решения.",
            "correct": true
          },
          {
            "text": "Итерационные процессы продолжаются до тех пор, пока не будет достигнута заданная точность.",
            "correct": true
          },
          {
            "text": "Итерационные методы всегда дают точное решение за конечное число шагов.",
            "correct": false
          }
        ],
        "type": "multiple"
      }
    ]
        }
    },
    topic04: {
            "title": "Численные методы решения систем нелинейных уравнений",
    "theory": `
        <h1><i>Численные методы решения систем нелинейных уравнений</i></h1>\n
	<p>Многие прикладные задачи приводят к необходимости нахождения общего решения системы нелинейных уравнений. Общего аналитического решения системы нелинейных уравнений не найдено.
 Существуют лишь численные методы.</p>\n<p><font color='#ff9100'>Для численного решения применяются итерационные методы:</font></p>\n
		<ol>\n    <li>Последовательных приближений (простой итерации);</li>\n    
			  <li>Метод Ньютона в различных модификациях.</li>\n</ol>\n
	<p>В общем случае систему нелинейных уравнений можно представить в виде:</p>\n
	<p>\\[\\begin{cases} f_1(x_1,x_2,...,x_n)=0 \\\\ f_2(x_1,x_2,...,x_n)=0 \\\\ ........................ \\\\ f_n(x_1,x_2,...,x_n)=0 \\end{cases}\\tag{1}\\]</p>\n
	<p>или \\[f_i(x_1,x_2,...,x_n)=0\\tag{2}\\]</p>\n<p>\\((i=1,2,...,n)\\)</p>\n
	<p>Если неизвестные рассматривать как вектор \\(x=(x_1,x_2,...,x_n)^T\\), а функции рассматривать как вектор \\(F=(f_1,f_2,...,f_n)^T\\), то систему (2) можно записать в виде:</p>\n
	<p>\\[F(x)=0\\tag{3}\\]</p>\n<p>Решением системы (1) будет вектор \\(x=x^{(*)}\\), превращающий систему в тождество.</p>\n
	<p>В подавляющем большинстве случаев для решения систем нелинейных уравнений используются итерационные методы.</p>\n
	<p>В дальнейшем предполагается, что ищется изолированное решение нелинейной системы. Как и в случае одного нелинейного уравнения, локализация решения может осуществляться на 
основе специфической информации по конкретной решаемой задаче (например, по физическим соображениям) или с помощью методов математического анализа.</p>\n
	<p>При решении системы двух уравнений достаточно часто удобным является графический способ, когда месторасположение корней определяется как точки пересечения кривых \\(f_1(x_1,x_2)=0,\\;f_2(x_1,x_2)=0\\) на плоскости \\((x_1,x_2)\\).</p>\n
		<br>\n<h2><i>Метод Ньютона</i></h2>\n
	<p>Это наиболее распространенный метод решения систем нелинейных уравнений. Основная идея метода Ньютона состоит в выделении из уравнений системы линейных частей, которые являются
 главными при малых приращениях аргументов. Это позволяет свести исходную задачу к решению последовательности систем линейных уравнений.</p>\n
	<p>Пусть нам известно некоторое \\(k\\)-ое приближение \\(x^{k}\\) к решению \\(x^{(*)}\\) системы (1). Поэтому решение можно представить так:</p>\n
	<p>\\[x^{k+1}=x^{k}+\\Delta x^k\\tag{4}\\]</p>\n<p>где \\(\\Delta x^k\\) — приращение (поправка, погрешность) к приближенному решению.</p>\n
	<p>В развернутом виде уравнение (4) запишется так:</p>\n
	<p>\\[\\begin{cases} x_1^{k+1}=x_1^{k}+\\Delta x_1^k \\\\ x_2^{k+1}=x_2^{k}+\\Delta x_2^k \\\\ .......... \\\\ x_n^{k+1}=x_n^{k}+\\Delta x_n^k \\end{cases}\\]</p>\n
	<p>\\((k=0,1,..,n)\\)</p>\n
	<p>где значения приращений \\(\\Delta x_1^k,\\Delta x_2^k,...,\\Delta x_n^k\\) определяются из решения системы линейных алгебраических уравнений, все коэффициенты которой
 выражаются через известное предыдущее приближение \\(x^k\\).</p>\n
	<p>Система уравнений (1) запишется в виде:</p>\n
	<p>\\[\\begin{cases} f_1(x_1+\\Delta x_1,x_2+\\Delta x_2,...,x_n+\\Delta x_n)=0 \\\\ f_2(x_1+\\Delta x_1,x_2+\\Delta x_2,...,x_n+\\Delta x_n)=0 \\\\ .......... \\\\ f_n(x_1+\\Delta x_1,x_2+\\Delta x_2,...,x_n+\\Delta x_n)=0 \\end{cases}\\tag{5}\\]</p>\n
	<p>Разложим каждую функцию \\(f\\) в ряд Тейлора, оставив только два первых слагаемых в разложении в силу малости параметра \\(\\Delta\\). И, отбросив слагаемые более высоких 
порядков, получим:</p>\n<p>\\[\\begin{cases} f_1(x^k)+\\Delta x_1^k\\cdot \\dfrac{\\partial f_1(x^k)}{\\partial x_1}+\\Delta x_2^k\\cdot \\dfrac{\\partial f_1(x^k)}{\\partial x_2}+...
+\\Delta x_n^k\\cdot \\dfrac{\\partial f_1(x^k)}{\\partial x_n}\\approx 0 \\\\ f_2(x^k)+\\Delta x_1^k\\cdot \\dfrac{\\partial f_2(x^k)}{\\partial x_1}+\\Delta x_2^k\\cdot \\dfrac{\\partial 
f_2(x^k)}{\\partial x_2}+...+\\Delta x_n^k\\cdot \\dfrac{\\partial f_2(x^k)}{\\partial x_n}\\approx 0 \\\\ ..........................................\\\\ f_n(x^k)+\\Delta x_1^k\\cdot 
\\dfrac{\\partial f_n(x^k)}{\\partial x_1}+\\Delta x_2^k\\cdot \\dfrac{\\partial f_n(x^k)}{\\partial x_2}+...+\\Delta x_n^k\\cdot \\dfrac{\\partial f_n(x^k)}{\\partial x_n}\\approx 0 \\end{cases}\\tag{6}\\]</p>\n
	<p>Или в матричной форме:</p>\n
	<p>\\[J(x^k)\\cdot\\Delta x^k=-F(x^k)\\tag{7}\\]</p>\n
	<p>где</p>\n
	<p>\\[J(x)=\\begin{pmatrix} \\dfrac{\\partial f_1(x)}{\\partial x_1} & \\dfrac{\\partial f_1(x)}{\\partial x_2} & ... & \\dfrac{\\partial f_1(x)}{\\partial x_n} \\\\ \\dfrac{\\partial
 f_2(x)}{\\partial x_1} & \\dfrac{\\partial f_2(x)}{\\partial x_2} & ... & \\dfrac{\\partial f_2(x)}{\\partial x_n} \\\\ ... & ... & ... & ... \\\\ \\dfrac{\\partial f_n(x)}{\\partial x_1} & 
\\dfrac{\\partial f_n(x)}{\\partial x_2} & ... & \\dfrac{\\partial f_n(x)}{\\partial x_n} \\end{pmatrix}\\]</p>\n
	<p>является <font color='#ff0000'>матрицей Якоби</font> первых производных вектор-функции \\(F(x)\\).</p>\n
	<p>Если \\(\\det J(x^k)\\neq 0\\), то выражая из (7) вектор приращений \\(\\Delta x^k\\) и подставляя его в (4), итерационный процесс нахождения решения можно записать в виде:</p>\n
	<p>\\[x^{k+1}=x^k-J^{-1}(x^k)F(x^k)\\tag{8}\\]</p>\n
	<p>\\((k=0,1,...,n)\\)</p>\n
	<p>где \\(J^{-1}(x)\\) — матрица, обратная матрице Якоби.</p>\n
	<p>Формула для нахождения решения является естественным обобщением формулы метода Ньютона для решения нелинейного уравнения:</p>\n
	<p>\\[x^{k+1}=x^k-\\frac{f(x^k)}{f'(x^k)}\\]</p>\n<p>\\((k=0,1,...,n)\\)</p>\n
	<p>Так как процесс вычисления обратной матрицы является трудоемким, преобразуем (8) следующим образом:</p>\n
	<p>\\[\\Delta x^{k}=-J^{-1}(x^k)F(x^k)\\]</p>\n<p>\\((k=0,1,...,n)\\)</p>\n
	<p>где \\(\\Delta x^{k}=x^{k+1}-x^k\\) — поправка к текущему приближению \\(x^k\\).</p>\n
	<p>Умножим последнее выражение слева на матрицу Якоби \\(J(x^k)\\):</p>\n
	<p>\\[J(x^k)\\cdot\\Delta x^{k}=-J(x^k)J^{-1}(x^k)F(x^k)=-F(x^k)\\]</p>\n
	<p>\\((k=0,1,...,n)\\)</p>\n
	<p>В результате получена система линейных алгебраических уравнений относительно поправки \\(\\Delta x^k\\). После ее определения вычисляется следующее приближение \\(x^{k+1}=x^k+\\Delta x^k\\).</p>\n
	<p>Для решения таких линейных систем можно привлекать самые разные методы, как прямые, так и итерационные, с учетом размерности \\(n\\) решаемой задачи и специфики матриц Якоби.</p>\n
	<p>Использование метода Ньютона предполагает дифференцируемость функций \\(f_1(x),f_2(x),...,f_n(x)\\) и невырожденность матрицы Якоби \\((\\det J(x^k)\\neq 0)\\). В случае, если 
начальное приближение выбрано в достаточно малой окрестности искомого корня, итерации сходятся к точному решению, причем сходимость квадратичная.</p>\n
	<p>Процесс вычислений заканчивают, когда выполняется условие:</p>\n
	<p>\\[\\max_i|x_i^{k+1}-x_i^k|\\leq\\varepsilon\\tag{9}\\]</p>\n
	<p>где \\(\\varepsilon\\) — заданная точность.</p>\n
	<p>В методе Ньютона очень важно при решении задать <font color='#ff0000'>достаточно близкое начальное приближение</font>, то есть такой набор переменных, которые близки к решению. 
Если решается система из 2 уравнений, то приближение находится с помощью построения графика двух функций.</p>\n
	<p>К <font color='#ffa726'>недостаткам</font> метода Ньютона следует отнести:</p>\n
		<ol>\n    <li>необходимость задавать достаточно хорошее начальное приближение;</li>\n    
			  <li>отсутствие глобальной сходимости для многих задач;</li>\n    
			  <li>необходимость вычисления матрицы Якоби на каждой итерации;</li>\n    
			  <li>необходимость решения на каждой итерации системы линейных уравнений, которая может быть плохо обусловленной.</li>\n</ol>\n
	<p><font color='#ffa726'>Достоинством</font> метода является квадратичная сходимость из хорошего начального приближения при условии невырожденности матрицы Якоби.</p>\n\n

	<h2><i>Алгоритм метода Ньютона для решения нелинейных систем</i></h2>\n
		<ol>\n    <li>Задать начальное приближение \\(x^0\\) и малое положительное число \\(\\varepsilon\\) (точность). Положить \\(k=0\\);</li>\n    
		 	  <li>Решить систему линейных алгебраических уравнений относительно поправки \\(\\Delta x^k\\):</li>\n    
	<p>\\[J(x^k)\\cdot\\Delta x^k=-F(x^k)\\]</p>\n    
			  <li>Вычислить следующее приближение: \\(x^{k+1}=x^k+\\Delta x^k\\);</li>\n    
			  <li>Если \\(\\Delta^{k+1}=\\max_i|x_i^{k+1}-x_i^k|\\leq\\varepsilon\\), процесс закончить и положить \\(x^{(*)}\\approx x^{k+1}\\). Если \\(\\Delta^{k+1} > 
\\varepsilon\\), то положить \\(k=k+1\\) и перейти к пункту 2.</li>\n</ol>\n
		<br>\n<p><font color='#ffa726'><font size=\"4\">Пример.</font></font> Методом Ньютона найти положительное решение системы нелинейных уравнений</p>\n
	<p>\\[\\begin{cases} 0,1x_1^2+x_1+0,2x_2^2-0,3=0 \\\\ 0,2x_1^2+x_2-0,1x_1x_2-0,7=0 \\end{cases}\\]</p>\n<p>с точностью \\(\\varepsilon=10^{-4}\\).</p>\n
 
	<h4><font color='#ffa726'>Решение:</font></h4>\n
	<p>Перепишем систему в виде:</p>\n<p>\\[\\begin{cases} f_1(x_1,x_2)=0,1x_1^2+x_1+0,2x_2^2-0,3=0 \\\\ f_2(x_1,x_2)=0,2x_1^2+x_2-0,1x_1x_2-0,7=0 \\end{cases}\\]</p>\n
	<p>Для выбора начального приближения применяем графический способ.</p>\n<p>Построим на плоскости \\((x_1,x_2)\\) кривые \\(f_1(x_1,x_2)=0,\\;f_2(x_1,x_2)=0\\).</p>\n
	<p>Определяем, что положительное решение системы уравнений находится в квадрате \\(0&lt;x_1&lt;0,5;\\;0,5&lt;x_2&lt;1\\).</p>\n
	
	<p><font color='#ff9100'><font size=\"4\">1-ая итерация:</font></font></p>\n
		<ol>\n    <li>Зададим начальное приближение \\(x_1^{0}=0,25,\\;x_2^{0}=0,75\\). В поставленной задаче \\(\\varepsilon=0,0001\\). Положим \\(k=0\\).</li>\n    
			  <li>Составим систему \\(J(x^k)\\cdot\\Delta x^{k}=-F(x^k)\\) (\\(k=0,1,...,n\\)). Так как</li>\n    
	<p>\\[J(x^k)=\\begin{pmatrix} \\dfrac{\\partial f_1(x^k_1,x^k_2)}{\\partial x_1} & \\dfrac{\\partial f_1(x^k_1,x^k_2)}{\\partial x_2} \\\\ \\dfrac{\\partial f_2(x^k_1,x^k_2)}{\\partial
 x_1} & \\dfrac{\\partial f_2(x^k_1,x^k_2)}{\\partial x_2} \\end{pmatrix}=\\begin{pmatrix} 0,2x^k_1+1 & 0,4x^k_2 \\\\ 0,4x^k_1-0,1x^k_2 & 1-0,1x^k_1 \\end{pmatrix}\\]</p>\n    
	<p>то система \\(J(x^0)\\cdot\\Delta x^{0}=-F(x^0)\\) имеет вид</p>\n    
	<p>\\[\\begin{pmatrix} 1,050 & 0,300 \\\\ 0,025 & 0,975 \\end{pmatrix}\\cdot\\begin{pmatrix} \\Delta x^0_1 \\\\ \\Delta x^0_2 \\end{pmatrix}=-\\begin{pmatrix} 0,0688 \\\\ 0,0437 \\end{pmatrix}\\]</p>\n    
	<p>Отсюда</p>\n    
	<p>\\[\\Delta x^0=\\begin{pmatrix} \\Delta x^0_1 \\\\ \\Delta x^0_2 \\end{pmatrix}=\\begin{pmatrix} -0,0530 \\\\ -0,0435 \\end{pmatrix}\\]</p>\n    
	<p>Для вычисления \\(\\Delta x^k\\) (\\(k=0,1,...,n\\)) здесь и далее используется <font color='#ff0000'>метод Гаусса</font>.</p>\n    
		<li>Вычислим</li>\n   
	<p>\\[x^1=x^0+\\Delta x^0=\\begin{pmatrix} 0,25 \\\\ 0,75 \\end{pmatrix}+\\begin{pmatrix} -0,0530 \\\\ -0,0435 \\end{pmatrix}=\\begin{pmatrix} 0,1970 \\\\ 0,7065 \\end{pmatrix}\\]</p>\n    
		<li>Так как</li>\n    
	<p>\\[\\Delta^1=\\max\\left\\{|-0,0530|,\\;|-0,0435|\\right\\}=0,0530 > \\varepsilon\\]</p>\n    
	<p>то положим \\(k=1\\) и перейдем к п.2.</p>\n</ol>\n
	
	<p><font color='#ff9100'><font size=\"4\">2-ая итерация:</font></font></p>\n
		<ol>\n    <li>Составим систему \\(J(x^1)\\cdot\\Delta x^{1}=-F(x^1)\\):</li>\n    
	<p>\\[\\begin{pmatrix} 1,0394 & 0,2826 \\\\ 0,0081 & 0,9803 \\end{pmatrix}\\cdot\\Delta x^1=-\\begin{pmatrix} 0,0007 \\\\ 0,0003 \\end{pmatrix}\\]</p>\n    
	<p>Отсюда</p>\n    
	<p>\\[\\Delta x^1=\\begin{pmatrix} -0,0005 \\\\ -0,0003 \\end{pmatrix}\\]</p>\n    
		<li>Вычислим</li>\n   
	<p>\\[x^2=x^1+\\Delta x^1=\\begin{pmatrix} 0,1970 \\\\ 0,7065 \\end{pmatrix}+\\begin{pmatrix} -0,0005 \\\\ -0,0003 \\end{pmatrix}=\\begin{pmatrix} 0,1964 \\\\ 0,7062 \\end{pmatrix}\\]</p>\n    
		<li>Так как \\(\\Delta^2=0,0005 > \\varepsilon\\), то положим \\(k=2\\) и перейдем к п.2.</li>\n
		</ol>\n<p>Результаты вычислений содержатся в таблице</p>\n
	<p>Найденное приближенное решение \\(x\\approx\\begin{pmatrix} 0,1964 & 0,7062 \\end{pmatrix}^T\\). Из анализа решения следует, что количество верных знаков на каждой итерации 
удваивается, что соответствует квадратичной сходимости.</p>\n\n

	<h3>Функция для метода Ньютона систем нелинейных уравнений на Julia:</h3>
		<div class="code-container">
       		 <div class="code-header">
            		Метод Ньютона для систем нелинейных урвнений
           		 <span class="language-label">JULIA</span>
        	 </div>
       		 <pre><code class="language-julia"># Метод Ньютона
function newton_method(v0; epsilon=1e-6, max_iter=100)
    v = copy(v0)
    
    println("Начальное приближение: v = ", round.(v, digits=4))
    
    for iter in 1:max_iter
        # Вычисляем значение функции и якобиан
        f_val = F(v)
        J = jacobian(v)
        
        # Решаем линейную систему: J * Δv = -F(v)
        Δv = J \ (-f_val)
        v .+= Δv
        
        norm_Δv = norm(Δv, Inf)
        norm_f = norm(f_val, Inf)
        
        println("Итерация $(lpad(iter, 3)): x = $(round(v[1], digits=6)), " *
                "y = $(round(v[2], digits=6)), " *
                "‖Δv‖ = $(round(norm_Δv, digits=8)), " *
                "‖F‖ = $(round(norm_f, digits=8))")
        
        if norm_Δv < epsilon && norm_f < epsilon
            return v, true
        end
    end
    
    println("\n Достигнут максимум итераций ($max_iter)")
    return v, false
end</code></pre>
	        </div>

	<h2><i>Метод простой итерации</i></h2>\n
	<p>При использовании метода простой итерации система уравнений (1) приводится к эквивалентной системе специального вида:</p>\n
	<p>\\[\\begin{cases} x_1=\\varphi_1(x_1,x_2,...,x_n) \\\\ x_2=\\varphi_2(x_1,x_2,...,x_n) \\\\ ............... \\\\ x_n=\\varphi_n(x_1,x_2,...,x_n) \\end{cases}\\tag{10}\\]</p>\n
	<p>или в векторной форме</p>\n<p>\\[x=\\varphi(x),\\;\\;\\;\\varphi(x)=\\begin{pmatrix} \\varphi_1(x) \\\\ \\varphi_2(x) \\\\ ... \\\\ \\varphi_n(x) \\end{pmatrix}\\tag{11}\\]</p>\n
	<p>где функции \\(\\varphi_1(x),\\varphi_2(x),...,\\varphi_n(x)\\) определены и непрерывны в некоторой окрестности искомого изолированного решения \\(x^{(*)}=\\left(x_1^{(*)},x_2^{(*)},...,x_n^{(*)}\\right)^T\\).</p>\n
	<p>Если выбрано некоторое начальное приближение \\(x^{(0)}=\\left(x_1^{(0)},x_2^{(0)},...,x_n^{(0)}\\right)^T\\), последующие приближения в методе простой итерации находятся по формулам:</p>\n
	<p>\\[\\begin{cases} x_1^{(k+1)}=\\varphi_1(x_1^{(k)},x_2^{(k)},...,x_n^{(k)}) \\\\ x_2^{(k+1)}=\\varphi_2(x_1^{(k)},x_2^{(k)},...,x_n^{(k)}) \\\\ ...............
 \\\\ x_n^{(k+1)}=\\varphi_n(x_1^{(k)},x_2^{(k)},...,x_n^{(k)}) \\end{cases}\\tag{12}\\]</p>\n<p>\\((k=0,1,...,n)\\)</p>\n
	<p>или в векторной форме</p>\n
	<p>\\[x^{(k+1)}=\\varphi(x^{(k)})\\tag{13}\\]</p>\n<p>\\((k=0,1,...,n)\\)</p>\n
	<p>Если последовательность векторов \\(x^{(k)}=\\left(x_1^{(k)},x_2^{(k)},...,x_n^{(k)}\\right)^T\\) сходится, то она сходится к решению \\(x^{(*)}=\\left(x_1^{(*)},x_2^{(*)},...,x_n^{(*)}\\right)^T\\).</p>\n
	<p>Достаточное условие сходимости итерационного процесса (12) формулируется следующим образом:</p>\n
	<p><font color='#ff9100'><font size=\"4\">Теорема 1.</font></font> Пусть вектор-функция \\(\\varphi(x)\\) непрерывна вместе со своей производной</p>\n
	<p>\\[\\varphi'(x)=\\begin{pmatrix} \\dfrac{\\partial \\varphi_1(x)}{\\partial x_1} & \\dfrac{\\partial \\varphi_1(x)}{\\partial x_2} & ... & \\dfrac{\\partial \\varphi_1(x)}
{\\partial x_n} \\\\ \\dfrac{\\partial \\varphi_2(x)}{\\partial x_1} & \\dfrac{\\partial \\varphi_2(x)}{\\partial x_2} & ... & \\dfrac{\\partial \\varphi_2(x)}{\\partial x_n} \\\\ ... & ... & 
... & ... \\\\ \\dfrac{\\partial \\varphi_n(x)}{\\partial x_1} & \\dfrac{\\partial \\varphi_n(x)}{\\partial x_2} & ... & \\dfrac{\\partial \\varphi_n(x)}{\\partial x_n} \\end{pmatrix}\\]</p>\n
	<p>в ограниченной выпуклой замкнутой области \\(G\\). Если</p>\n
	<p>\\[\\max_{x\\in G}|\\varphi'(x)|=\\max_{x\\in G}\\left\\{\\max_i\\sum_{j=1}^n\\left|\\frac{\\partial \\varphi_i(x_1,x_2,...,x_n)}{\\partial x_j}\\right|\\right\\}\\leq q&lt;1\\tag{14}\\]</p>\n
	<p>где \\(q\\) — постоянная, и если \\(x^{(0)}\\in G\\) и все последовательные приближения</p>\n
	<p>\\[x^{(k+1)}=\\varphi(x^{(k)})\\]</p>\n<p>\\((k=0,1,...,n)\\)</p>\n
	<p>остаются в области \\(G\\), то последовательность \\(\\{x^{(k)}\\}\\) сходится к решению \\(x^{(*)}\\in G\\).</p>\n<p>Справедливы оценки погрешности \\((\\forall k\\in\\mathbb{N})\\):</p>\n
	<p>\\[\\left|x^{(*)}-x^{(k+1)}\\right|\\leq\\frac{q^{k+1}}{1-q}\\left|x^{(1)}-x^{(0)}\\right|\\]</p>\n
	<p>\\[\\left|x^{(*)}-x^{(k+1)}\\right|\\leq\\frac{q}{1-q}\\left|x^{(k+1)}-x^{(k)}\\right|\\tag{15}\\]</p>\n
	<p>Итерационный процесс заканчивается, когда выполняется <font color='#ff9100'>условие</font>:</p>\n
	<p>\\[\\max_i\\left|x_i^{(k+1)}-x_i^{(k)}\\right|\\leq\\varepsilon\\tag{16}\\]</p>\n
	<p>\\((i=1,2,...,n)\\)</p>\n
	<p>При подсчёте вручную, например, с точностью до \\(10^{-4}\\) это условие сводится к проверке совпадения всех приближений с точностью до единицы в четвёртом разряде. Если условие 
(16) выполнено, то решение считается найденным на \\(k+1\\)-ом шаге и итерационный процесс закончен, в противном случае полагаем \\(k=k+1\\) и переходим к вычислению следующего приближения.</p>\n\n
	
	<h2><i>Алгоритм метода простых итераций для нелинейных систем уравнений</i></h2>\n
		<ol>\n    <li>Задать начальное приближение \\(x^0=\\left(x_{10},x_{20},...,x_{n0}\\right)^T\\) и малое положительное число \\(\\varepsilon\\) (точность). Положить \\(k=0\\).</li>\n    
			  <li>Вычислить \\(x^{k+1}\\) по формуле</li>\n    
	<p>\\[x^{(k+1)}=\\varphi(x^{(k)})\\tag{17}\\]</p>\n    
	<p>или</p>\n    
	<p>\\[x_i^{(k+1)}=\\varphi_i(x_1^{k},x_2^{k},...,x_n^{k})\\tag{18}\\]</p>\n    
			   <li>Если \\(\\Delta^{(k+1)}=\\max_i\\left|x_i^{(k+1)}-x_i^{(k)}\\right|\\leq\\varepsilon\\), процесс завершен и \\(x^{(*)}\\approx x^{(k+1)}\\). Если 
\\(\\Delta^{(k+1)} > \\varepsilon\\), то положить \\(k=k+1\\) и перейти к п.2.</li>\n</ol>\n
	<p><font color='#ff9100'><font size=\"4\">Замечания:</font></font></p>\n
		  <ol>\n    <li>Итерационный процесс, реализуемый согласно (18), соответствует параллельному интегрированию, так как для вычисления \\(k+1\\)-го приближения всех 
неизвестных учитываются вычисленные ранее их \\(k\\)-е приближения;</li>\n    
		            <li>Система (1) может быть преобразована к виду (10) различными способами, например, с помощью выражения переменных \\(x_i\\) (\\(i=1,2,...,n\\)) таким образом, чтобы выполнялось условие сходимости.</li>\n</ol>\n
		<br>\n<p><font color='#ffa726'><font size=\"4\">Пример.</font></font> Найти корни нелинейной системы уравнений</p>\n<p>\\[\\begin{cases} 2x_1^2-x_1x_2-5x_1+1=0 \\\\ x_1+3\\lg x_1-x_2^2=0 \\end{cases}\\]</p>\n
	<p>расположенные в первом квадранте, методом простых итераций с точностью \\(\\varepsilon=0,001\\).</p>\n
	
	<h4><font color='#ffa726'>Решение:</font></h4>\n
	<p>Преобразуем систему к виду (10) так, чтобы выполнялось условие сходимости:</p>\n
	<p>\\[x_1=\\sqrt{\\frac{x_1(x_2+5)-1}{2}}=\\varphi_1(x)\\]</p>\n<p>\\[x_2=\\sqrt{x_1+3\\lg x_1}=\\varphi_2(x)\\]</p>\n
	<p>Найдем частные производные:</p>\n
	<p>\\[\\frac{\\partial\\varphi_1}{\\partial x_1}=\\frac{x_2+5}{4\\sqrt{\\frac{x_1(x_2+5)-1}{2}}}\\]</p>\n
	<p>\\[\\frac{\\partial\\varphi_1}{\\partial x_2}=\\frac{x_1}{4\\sqrt{\\frac{x_1(x_2+5)-1}{2}}}\\]</p>\n
	<p>\\[\\frac{\\partial\\varphi_2}{\\partial x_1}=\\frac{1+\\frac{3\\cdot 0,43429}{x_1}}{2\\sqrt{x_1+3\\lg x_1}}\\]</p>\n
	<p>\\[\\frac{\\partial\\varphi_2}{\\partial x_2}=0\\]</p>\n<p>Здесь принято \\(\\lg e\\approx 0,43429\\). Далее воспользуемся методикой решения задачи.</p>\n
		<ol>\n    <li>Для выбора начального приближения найдем координаты точек пересечения кривых, соответствующих первому и второму уравнениям. Находим приближенные значения 	координат решения (по условию задачи нас интересуют только корни с положительными координатами): \\(x^{(0)}=\\begin{pmatrix}3,5 & 2,2\\end{pmatrix}^T\\). Проверим выполнение 
условий сходимости. Будем рассматривать окрестность найденной точки \\(x^{(0)}\\):</li>\n    <p>\\[G=\\left\\{|x_1-3,5|\\le 0,1;\\;|x_2-2,2|\\le 0,1\\right\\}\\]</p>\n    <p>Тогда</p>\n    <p>\\[\\left|\\frac{\\partial\\varphi_1}{\\partial x_1}\\right|\\le\\frac{2,3+5}{4\\sqrt{\\frac{3,4\\cdot(2,1+5)-1}{2}}}=0,536&lt;0,54\\]</p>\n    <p>\\[\\left|\\frac{\\partial\\varphi_1}{\\partial x_2}\\right|\\le\\frac{3,6}{4\\sqrt{\\frac{3,4\\cdot(2,1+5)-1}{2}}}=0,265&lt;0,27\\]</p>\n    <p>\\[\\left|\\frac{\\partial\\varphi_2}{\\partial x_1}\\right|\\le\\frac{1+\\frac{3\\cdot 0,43429}{3,4}}{2\\sqrt{3,4+3\\lg 3,4}}=0,309&lt;0,31\\]</p>\n    <p>\\[\\left|\\frac{\\partial\\varphi_2}{\\partial x_2}\\right|=0\\]</p>\n    <p>Следовательно, можно получить оценки:</p>\n    <p>\\[\\left|\\frac{\\partial\\varphi_1(x)}{\\partial x_1}\\right|+\\left|\\frac{\\partial\\varphi_2(x)}{\\partial x_1}\\right|&lt;0,54+0,31=0,85&lt;1\\]</p>\n    <p>\\[\\left|\\frac{\\partial\\varphi_1(x)}{\\partial x_2}\\right|+\\left|\\frac{\\partial\\varphi_2(x)}{\\partial x_2}\\right|&lt;0,27+0=0,27&lt;1\\]</p>\n    
	<p>Очевидно, условие (14) выполняется. Если последовательные приближения не будут выходить из области \\(G\\), то итерационный процесс будет сходящимся. В поставленной задаче \\(\\varepsilon=0,001\\).</p>\n    
			   <li>Выполним расчеты по формулам:</li>\n    
	<p>\\[x_1^{(k+1)}=\\sqrt{\\frac{x_1^{(k)}\\cdot(x_2^{(k)}+5)-1}{2}}\\]</p>\n    
	<p>\\[x_2^{(k+1)}=\\sqrt{x_1^{(k)}+3\\lg x_1^{(k)}}\\]</p>\n    
	<p>а результаты поместим в таблицу.</p>\n    
			   <li>Заметим, что величина \\(\\Delta^{(k+1)}\\) при увеличении номера итерации уменьшается, что характерно для любого сходящегося процесса. Найдено приближенное 
решение: \\(x^{*}\\approx\\begin{pmatrix}3,4857 & 2,2608\\end{pmatrix}^T\\). При этом \\(f_1(x^{*})=-0,0083;\\;f_2(x^{*})=-0,00126\\).</li>\n</ol>\n\n

	<h3>Функция для метода простой итерации систем нелинейных уравнений на Julia:</h3>
		<div class="code-container">
       		 <div class="code-header">
            		Метод простой итерации для систем нелинейных урвнений
           		 <span class="language-label">JULIA</span>
        	 </div>
       		 <pre><code class="language-julia"># Метод простой итерации 
function simple_iter(u0::Vector{T}; 
                               tolerance::T=1e-3, 
                               max_iterations::Int=100) where T
    
    u = copy(u0)
    converged = false
    iteration_count = 0
    
    println("Начальное приближение: u₀ = ", round.(u, digits=4))
    
    for k in 1:max_iterations
        u_prev = copy(u)
        u = it_function(u)  # теперь получаем вектор
        Δu = norm(u - u_prev, Inf)
        
        @printf "Итерация %3d: x = %.6f, y = %.6f, Δu = %.2e\n" k u[1] u[2] Δu 
        
        # Проверка сходимости
        if Δu < tolerance
            converged = true
            iteration_count = k
            break
        end
    end
    
    return u, converged, iteration_count
end
</code></pre>
	        </div>
    `,
	"practica": `
	<h1><i>Численные методы решения систем нелинейных уравнений</i></h1>
        <h2><i>Практическая работа №4</i></h2>

	<caption><h4>Пример 1.</h4></caption>
<p>Решить систему нелинейных уравнений методом Ньютона с точностью \\( 0.001 \\): \\[ \\begin{cases} \\sin(x - 0.6) - y = 1.6 \\\\ 3x - \\cos y = 0.9 \\end{cases} \\]</p>
	
<h4>Алгоритм решения системы нелинейных уравнений методом Ньютона</h4>

<p>Шаг 1: Определение системы уравнений</p>
<pre><code class="language-julia">
using ForwardDiff  
using LinearAlgebra

function F(v)
    x, y = v
    return [sin(x - 0.6) - y - 1.6,
            3x - cos(y) - 0.9]
end
</code></pre>

<p>Шаг 2: Вычисление якобиана</p>
<pre><code class="language-julia">
# Автоматическое вычисление матрицы Якоби
function jacobian(v)
    return ForwardDiff.jacobian(F, v)
end
</code></pre>

<p>Шаг 3: Метод Ньютона для систем</p>
<pre><code class="language-julia">
function newton_method(v0; epsilon=1e-6, max_iter=100)
    v = copy(v0)
    
    for iter in 1:max_iter
        # Значение функции в текущей точке
        f_val = F(v)
        
        # Матрица Якоби
        J = jacobian(v)
        
        # Решение линейной системы: J·Δv = -F(v)
        Δv = J \ (-f_val)
        
        # Обновление решения
        v .+= Δv
        
        # Проверка условий сходимости
        norm_Δv = norm(Δv, Inf)  # норма приращения
        norm_f = norm(f_val, Inf) # норма невязки
        
        if norm_Δv < epsilon && norm_f < epsilon
            return v, true  # сходимость достигнута
        end
    end
    
    return v, false  # превышено максимальное число итераций
end
</code></pre>

<p>Шаг 4: Анализ решения</p>
<pre><code class="language-julia">
function analyze(v)
    J = jacobian(v)
    println("Матрица Якоби в решении:")
    println(J)
    
    detJ = det(J)
    println("Определитель якобиана: $(round(detJ, digits=6))")
    
    if abs(detJ) < 1e-10
        println("Внимание: якобиан близок к вырожденной матрице")
    end
end
</code></pre>

<p>Шаг 5: Визуализация </p>
<pre><code class="language-julia">
using Plots
using LaTeXStrings

function plot_graph(solution)
    # Область построения вокруг решения
    x_sol, y_sol = solution
    x_range = range(x_sol-1, x_sol+1, length=200)
    y_range = range(y_sol-1, y_sol+1, length=200)
    
    # Построение линий уровня для каждого уравнения
    Z1 = [sin(x - 0.6) - y - 1.6 for x in x_range, y in y_range]
    Z2 = [3x - cos(y) - 0.9 for x in x_range, y in y_range]
    
    # График пересечений линий уровня
    p = contour(x_range, y_range, Z1', levels=[0], color=:red, label="f₁(x,y)=0")
    contour!(p, x_range, y_range, Z2', levels=[0], color=:blue, label="f₂(x,y)=0")
    scatter!(p, [x_sol], [y_sol], markersize=8, markercolor=:green, label="Решение")
    
    return p
end
</code></pre>
<p>Добавляем главную функцию.</p>
<p>Выводим результат.</p>

	<caption><h4>Пример 2.</h4></caption>
<p>Решить систему нелинейных уравнений методом простой итерации с точностью \\( 0.001 \\): \\[ \\begin{cases} \\sin(x - 0.6) - y = 1.6 \\\\ 3x - \\cos y = 0.9 \\end{cases} \\]</p>

<h4>Алгоритм решения системы нелинейных уравнений методом простой итерации</h4>
<p>Вводим в программу данные о системе уравнений</p>
<p>Шаг 1: Преобразование к виду x = φ(x)</p>
<pre><code class="language-julia">
function it_function(u)
    x, y = u
    # Преобразование уравнений:
    # x = (cos(y) + 0.9)/3
    # y = sin(x - 0.6) - 1.6
    return [(cos(y) + 0.9) / 3, sin(x - 0.6) - 1.6]  
end
</code></pre>

<p>Шаг 2: Метод простой итерации</p>
<pre><code class="language-julia">
function simple_iter(u0::Vector{T}; 
                     tolerance::T=1e-3, 
                     max_iterations::Int=100) where T
    
    u = copy(u0)
    
    for k in 1:max_iterations
        u_prev = copy(u)
        u = it_function(u)  # итерационная формула
        
        # Контроль сходимости
        Δu = norm(u - u_prev, Inf)
        
        if Δu < tolerance
            return u, true, k  # сходимость достигнута
        end
    end
    
    return u, false, max_iterations  # не сошлось
end
</code></pre>

<p>Шаг 3: Визуализация системы</p>
<pre><code class="language-julia">
function plot_graph(solution=nothing)
    # Построение кривых для каждого уравнения
    
    # Первое уравнение: sin(x-0.6) - y - 1.6 = 0 → y = sin(x-0.6) - 1.6
    x1 = range(-2, 2, length=200)
    y1 = sin.(x1 .- 0.6) .- 1.6
    
    # Второе уравнение: 3x - cos(y) - 0.9 = 0 → x = (cos(y) + 0.9)/3
    y2 = range(-3, 2, length=200)
    x2 = (cos.(y2) .+ 0.9) ./ 3
    
    # Создание графика
    p = plot(x1, y1, linewidth=2, color=:red, label="y = sin(x-0.6) - 1.6")
    plot!(p, x2, y2, linewidth=2, color=:blue, label="x = (cos(y) + 0.9)/3")
    
    # Добавление точки решения
    if solution !== nothing
        scatter!(p, [solution[1]], [solution[2]], 
                markersize=8, markercolor=:green, 
                label="Решение")
    end
    
    return p
end
</code></pre>
<p>Добавляем главную функцию.</p>
<p>Выводим результат.</p>

`,
	"test": {
            "timeLimit": 600,
            "questions": [
      {
        "question": "Какие из перечисленных методов относятся к численным методам решения систем нелинейных уравнений?",
        "answers": [
          {
            "text": "Метод последовательных приближений (простой итерации).",
            "correct": true
          },
          {
            "text": "Метод Ньютона в различных модификациях.",
            "correct": true
          },
          {
            "text": "Метод Гаусса для линейных систем.",
            "correct": false
          }
        ],
        "type": "multiple"
      },
      {
        "question": "Что из перечисленного характерно для метода Ньютона решения систем нелинейных уравнений?",
        "answers": [
          {
            "text": "Требует вычисления матрицы Якоби на каждой итерации.",
            "correct": true
          },
          {
            "text": "Обеспечивает квадратичную сходимость при удачном начальном приближении.",
            "correct": true
          },
          {
            "text": "Не требует решения систем линейных уравнений на каждой итерации.",
            "correct": false
          }
        ],
        "type": "multiple"
      },
      {
        "question": "Какое условие является достаточным для сходимости метода простой итерации для систем нелинейных уравнений?",
        "answers": [
          {
            "text": "Норма матрицы Якоби вектор-функции \\(\\varphi(\\mathbf{x})\\) должна быть меньше единицы в некоторой области.",
            "correct": true
          },
          {
            "text": "Определитель матрицы Якоби должен быть равен нулю.",
            "correct": false
          },
          {
            "text": "Все частные производные функций \\(\\varphi_i(\\mathbf{x})\\) должны быть равны нулю.",
            "correct": false
          }
        ],
        "type": "single"
      },
      {
        "question": "Что представляет собой матрица Якоби в методе Ньютона для системы n нелинейных уравнений?",
        "answers": [
          {
            "text": "Матрицу первых частных производных вектор-функции \\(\\mathbf{f}(\\mathbf{x})\\).",
            "correct": true
          },
          {
            "text": "Матрицу вторых частных производных вектор-функции \\(\\mathbf{f}(\\mathbf{x})\\).",
            "correct": false
          },
          {
            "text": "Матрицу, элементами которой являются сами функции \\(f_i(\\mathbf{x})\\).",
            "correct": false
          }
        ],
        "type": "single"
      },
      {
        "question": "Какие из перечисленных утверждений верны относительно начального приближения в методах решения систем нелинейных уравнений?",
        "answers": [
          {
            "text": "В методе Ньютона очень важно задать достаточно близкое к решению начальное приближение.",
            "correct": true
          },
          {
            "text": "Для выбора начального приближения можно использовать графический способ построения кривых \\(f_i(\\mathbf{x}) = 0\\).",
            "correct": true
          },
          {
            "text": "Начальное приближение можно выбирать произвольно, оно не влияет на сходимость методов.",
            "correct": false
          }
        ],
        "type": "multiple"
      }
    ]
        }
    },
    topic05: {
            "title": "Аппроксимация",
            "theory": `
        <h1><i>Аппроксимация</i></h1>\n
	<h2><i>Построение аппроксимирующей зависимости</i></h2>\n
	<p>В научных и инженерных расчетах часто приходится сталкиваться с наборами значений, полученных опытным путем. По этим опытным данным составляется таблица, в соответствии с которой
 подбирается формула, приближенно выражающая исследуемую зависимость, то есть строится функция, значения которой близки к значениям, найденным опытным путем.</p>\n
	<p>Полученная таким образом формула называется <font color='#ff0000'>эмпирической</font>.</p>\n
	<p>Задача нахождения формулы, полученной на основании анализа опытных данных, называется <font color='#ff0000'>аппроксимацией</font>.</p>\n
	<p>Построение аппроксимирующей зависимости по экспериментальным данным состоит из двух этапов:</p>\n
		<ol>\n    <li>Подбор общего вида аппроксимирующей зависимости;</li>\n    
			  <li>Определение наилучших значений параметров этой зависимости.</li>\n</ol>\n
	<p>Если характер зависимости не известен, то экспериментальные точки наносят на график и примерно выбирают зависимость из геометрических соображений путем сравнения ее с известными
 функциями (показательной, логарифмической и др.).</p>\n
	<p>Пусть в результате эксперимента получены значения \\(y_1,y_2,...,y_n\\) величины \\(y\\), соответствующие значениям \\(x_1,x_2,...,x_n\\) величины \\(x\\). Эти данные записывают в таблицу.</p>\n
	<p>Нужно подобрать формулу, выражающую приближенно зависимость \\(y\\) от \\(x\\). Конечно, существует «точная» функция \\(y=f(x)\\), но так как она неизвестна, то нужно подобрать 
функцию, близкую к \\(f(x)\\).</p>\n
	<p>Для этого необходимо:</p>\n
		<ol>\n    <li>Рассмотреть точечную диаграмму, построенную на основе значений функции, заданных в таблице и, заметив особенности расположения точек, подобрать тип аналитически выраженной функции, соответствующей этому расположению точек;</li>\n    
			  <li>Записать выбранную функцию с параметрами. Параметры подбирают так, чтобы точки, полученные экспериментально, были как можно ближе к кривой (но не обязательно 
должны лежать на кривой). Поиск параметров осуществляют по способу наименьших квадратов.</li>\n</ol>\n
	<p>При подборе вида аппроксимирующей (приближающей) функции нужно учесть следующее: рассматривая точки на чертеже, намечают плавную линию, проходящую вблизи этих точек, при этом 
не стремятся к тому, чтобы линия проходила через эти точки, так как случайные отклонения при измерении бывают в ту и другую сторону. Поэтому плавную кривую (аппроксимирующую линию) нужно 
проводить так, чтобы точки располагались по обе стороны от кривой. Вид проведенной линии позволяет сделать заключение, какая же аналитически заданная функция подходит в качестве 
приближения (линейная, степенная, логарифмическая, показательная, квадратичная).</p>\n\n
	
	<h2><i>Виды аппроксимирующей зависимости</i></h2>\n
	<h3><font color='#ff9100'>Линейная аппроксимация</font></h3>\n
	<p>Используется при моделировании характеристик, значения которых увеличиваются или убывают с постоянной скоростью. Это наиболее простая в построении модель исследуемого процесса. Она строится в соответствии с уравнением:</p>\n
	<p>\\[y=kx+b\\]</p>\n<p>где \\(k\\) — тангенс угла наклона линейной аппроксимации к оси абсцисс, \\(b\\) — координата точки пересечения линейной аппроксимации с осью ординат.</p>\n
	<p>Параметры \\(k\\) и \\(b\\) можно определить, используя метод наименьших квадратов.</p>\n
	<p><font color='#ff9100'><font size=\"4\">Суть метода наименьших квадратов:</font></font> Задача заключается в нахождении коэффициентов линейной зависимости, при которых функция 
двух переменных \\(k\\) и \\(b\\)</p>\n<p>\\[F(k,b)=\\sum_{i=1}^{n}\\left(y_i-(kx_i+b)\\right)^{2}\\]</p>\n
	<p>принимает наименьшее значение, то есть при данных \\(k\\) и \\(b\\) сумма квадратов отклонений экспериментальных данных от проведенной прямой будет наименьшей.</p>\n
	<p>Таким образом, решение задачи сводится к нахождению экстремума функции двух переменных.</p>\n
	<p>Формулы для вычисления коэффициентов имеют вид:</p>\n
	<p>\\[k=\\frac{n\\sum_{i=1}^{n}x_i y_i-\\sum_{i=1}^{n}x_i\\sum_{i=1}^{n}y_i}{n\\sum_{i=1}^{n}x_i^2-\\left(\\sum_{i=1}^{n}x_i\\right)^2}\\]</p>\n
	<p>\\[b=\\frac{1}{n}\\left(\\sum_{i=1}^{n}y_i-k\\sum_{i=1}^{n}x_i\\right)\\]</p>\n<p>Абсолютную погрешность (разность между значениями аппроксимирующей функции и экспериментальными
 данными) во всех точках \\(x_i\\) вычисляют по формуле:</p>\n
	<p>\\[R_i=\\left|y_i-(kx_i+b)\\right|\\]</p>\n<p>\\((i=1,2,...,n)\\)</p>\n
	<p>Обозначим \\(\\tilde{y}_i=kx_i+b\\) и перепишем абсолютную погрешность в виде:</p>\n
	<p>\\[R_i=\\left|y_i-\\tilde{y}_i\\right|\\]</p>\n<p>где \\(\\tilde{y}_i\\) — значения, полученные по аппроксимирующей функции.</p>\n
	<p>Суммарную квадратичную погрешность (сумма квадратов отклонений исходных данных от аппроксимирующей функции) вычисляют по формуле:</p>\n
	<p>\\[R^{2}=1-\\frac{\\sum_{i=1}^{n}\\left(y_i-(kx_i+b)\\right)^{2}}{\\sum_{i=1}^{n}\\left(kx_i+b\\right)^{2}-\\frac{1}{n}\\left(\\sum_{i=1}^{n}\\left(kx_i+b\\right)\\right)^{2}}\\]</p>\n
	<p>Она характеризует достоверность аппроксимации: чем ближе значение \\(R^2\\) к единице, тем надежнее выбранная функция аппроксимирует исследуемый процесс.</p>\n\n

	<h3>Пример вычисления линейной аппроксимации на Julia:</h3>
		<div class="code-container">
       		 <div class="code-header">
            		 Линейная аппроксимация 
           		 <span class="language-label">JULIA</span>
        	 </div>
       		 <pre><code class="language-julia"># Данные
x = [1, 2, 3, 4, 5]
y = [2, 4, 5, 4, 5]

#(y = a + b*x)
coeffs = hcat(fill!(similar(x), 1), x) \ y #матрица </code></pre>
	        </div>

	<h3><font color='#ff9100'>Степенная аппроксимация</font></h3>\n
	<p>Дает хорошие результаты, если значения исследуемой зависимости характеризуются постоянным изменением скорости роста. Примером такой зависимости может служить график равноускоренного 
движения автомобиля. Если среди данных встречаются нулевые или отрицательные значения, использовать степенную аппроксимацию нельзя. Строится в соответствии с уравнением:</p>\n
	<p>\\[y=k\\cdot x^b\\]</p>\n
	<p>где коэффициенты \\(k\\) и \\(b\\) — константы.</p>\n
	<p>Формулы для вычисления коэффициентов имеют вид:</p>\n
	<p>\\[b=\\frac{n\\sum_{i=1}^{n}\\ln x_i\\ln y_i-\\sum_{i=1}^{n}\\ln x_i\\sum_{i=1}^{n}\\ln y_i}{n\\sum_{i=1}^{n}(\\ln x_i)^2-\\left(\\sum_{i=1}^{n}\\ln x_i\\right)^2}\\]</p>\n
	<p>\\[k=\\exp\\left(\\frac{1}{n}\\left(\\sum_{i=1}^{n}\\ln y_i-b\\sum_{i=1}^{n}\\ln x_i\\right)\\right)\\]</p>\n
	<p>Суммарную квадратичную погрешность вычисляют по формуле:</p>\n
	<p>\\[R^{2}=1-\\frac{\\sum_{i=1}^{n}\\left(y_i-\\left(k\\cdot x_i^b\\right)\\right)^{2}}{\\sum_{i=1}^{n}\\left(k\\cdot x_i^b\\right)^{2}-\\frac{1}{n}\\left(\\sum_{i=1}^{n}\\left(k\\cdot x_i^b\\right)\\right)^{2}}\\]</p>\n\n

	<h3>Пример вычисления степенной аппроксимации на Julia:</h3>
		<div class="code-container">
       		 <div class="code-header">
            		 Степенная аппроксимация 
           		 <span class="language-label">JULIA</span>
        	 </div>
       		 <pre><code class="language-julia"># Данные
x = [1, 2, 3, 4, 5]
y = [2, 4, 5, 4, 5]

# Логарифмируем для линейной модели: ln(y) = ln(a) + b*ln(x)
ln_x = log.(x)
ln_y = log.(y)

# Линейная аппроксимация в логарифмических координатах
coeffs_log = hcat(fill!(similar(ln_x), 1), ln_x) \ ln_y

# Преобразуем обратно
a = exp(coeffs_log[1])
b = coeffs_log[2]</code></pre>
	        </div>
	
	<h3><font color='#ff9100'>Полиномиальная аппроксимация</font></h3>\n
	<p>Используется для описания характеристик, имеющих несколько ярко выраженных экстремумов (максимумов и минимумов). Выбор степени полинома определяется количеством экстремумов 
исследуемой характеристики. Так, полином второй степени может хорошо описать процесс, имеющий только один максимум или минимум; полином третьей степени – не более двух экстремумов; полином
 четвертой степени – не более трех экстремумов и т. д. В этом случае аппроксимация строится в соответствии с уравнением:</p>\n
	<p>\\[y=a_0+a_1x+a_2x^2+a_3x^3+a_4x^4+a_5x^5+a_6x^6\\]</p>\n<p>где коэффициенты \\(a_0,a_1,a_2,a_3,a_4,a_5,a_6\\) — константы, значения которых определяются в ходе построения.</p>\n\n

	<h3>Пример вычисления полиномиальной аппроксимации на Julia:</h3>
		<div class="code-container">
       		 <div class="code-header">
            		 Полиномиальная аппроксимация 
           		 <span class="language-label">JULIA</span>
        	 </div>
       		 <pre><code class="language-julia"># Данные
x = [1, 2, 3, 4, 5]
y = [2, 4, 5, 4, 5]

# Полиномиальная аппроксимация 2-й степени (y = a + b*x + c*x²)
coeffs = hcat(fill!(similar(x), 1), x, x.^2) \ y </code></pre>
	        </div>

	<h3><font color='#ff9100'>Логарифмическая аппроксимация</font></h3>\n
	<p>Применяется при моделировании характеристик, значения которых вначале быстро меняются, а затем постепенно стабилизируются. Строится в соответствии с уравнением:</p>\n
	<p>\\[y=k\\ln x+b\\]</p>\n<p>где коэффициенты \\(k\\) и \\(b\\) — константы.</p>\n
	<p>Формулы для вычисления коэффициентов имеют вид:</p>\n
	<p>\\[b=\\frac{n\\sum_{i=1}^{n}y_i\\ln x_i-\\sum_{i=1}^{n}\\ln x_i\\sum_{i=1}^{n}y_i}{n\\sum_{i=1}^{n}\\ln^2 x_i-\\left(\\sum_{i=1}^{n}\\ln x_i\\right)^2}\\]</p>\n
	<p>\\[k=\\frac{1}{n}\\sum_{i=1}^{n}y_i-\\frac{b}{n}\\sum_{i=1}^{n}\\ln x_i\\]</p>\n
	<p>Суммарную квадратичную погрешность вычисляют по формуле:</p>\n
	<p>\\[R^{2}=1-\\frac{\\sum_{i=1}^{n}\\left(y_i-\\left(k\\ln x_i+b\\right)\\right)^{2}}{\\sum_{i=1}^{n}\\left(k\\ln x_i+b\\right)^{2}-\\frac{1}{n}\\left(\\sum_{i=1}^{n}\\left(k\\ln x_i+b\\right)\\right)^{2}}\\]</p>\n\n

	<h3>Пример вычисления логарифмической аппроксимации на Julia:</h3>
		<div class="code-container">
       		 <div class="code-header">
            		 Логарифмическая аппроксимация 
           		 <span class="language-label">JULIA</span>
        	 </div>
       		 <pre><code class="language-julia"># Данные
x = [1, 2, 3, 4, 5]
y = [2, 4, 5, 4, 5]

# Логарифмическая аппроксимация (y = a + b*ln(x))
coeffs = hcat(fill!(similar(x), 1), log.(x)) \ y </code></pre>
	        </div>

	<h3><font color='#ff9100'>Экспоненциальная аппроксимация</font></h3>\n
	<p>Используется в том случае, если скорость изменения данных непрерывно возрастает. Для данных, содержащих нулевые или отрицательные значения, этот вид приближения также неприменим.Строится в соответствии с уравнением:</p>\n<p>\\[y=e^{k+bx}\\]</p>\n
	<p>где коэффициенты \\(k\\) и \\(b\\) — константы.</p>\n
	<p>Формулы для вычисления коэффициентов имеют вид:</p>\n
	<p>\\[b=\\frac{n\\sum_{i=1}^{n}x_i\\ln y_i-\\sum_{i=1}^{n}x_i\\sum_{i=1}^{n}\\ln y_i}{n\\sum_{i=1}^{n}x_i^2-\\left(\\sum_{i=1}^{n}x_i\\right)^2}\\]</p>\n
	<p>\\[k=\\frac{1}{n}\\sum_{i=1}^{n}\\ln y_i-\\frac{b}{n}\\sum_{i=1}^{n}x_i\\]</p>\n
	<p>Суммарную квадратичную погрешность вычисляют по формуле:</p>\n
	<p>\\[R^{2}=1-\\frac{\\sum_{i=1}^{n}\\left(y_i-\\left(e^{k+bx_i}\\right)\\right)^{2}}{\\sum_{i=1}^{n}\\left(e^{k+bx_i}\\right)^{2}-\\frac{1}{n}\\left(\\sum_{i=1}^{n}\\left(e^{k+bx_i}\\right)\\right)^{2}}\\]</p>\n\n

	<h3>Пример вычисления экспоненциальной аппроксимации на Julia:</h3>
		<div class="code-container">
       		 <div class="code-header">
            		 Экспоненциальная аппроксимация 
           		 <span class="language-label">JULIA</span>
        	 </div>
       		 <pre><code class="language-julia"># Данные
x = [1, 2, 3, 4, 5]
y = [2, 4, 5, 4, 5]

# Экспоненциальная аппроксимация (y = a*exp(b*x))
# Логарифмируем: ln(y) = ln(a) + b*x
coeffs = hcat(fill!(similar(x), 1), x) \ log.(y)

# Возвращаем обратно
a = exp(coeffs[1])
b = coeffs[2]</code></pre>
	        </div>

	<h3><font color='#ff9100'>Показательная аппроксимация</font></h3>\n
	<p>Используется в том случае, когда экспериментальные данные представлены набором положительных чисел. Строится в соответствии с уравнением:</p>\n
	<p>\\[y=k\\cdot b^x\\]</p>\n<p>где коэффициенты \\(k\\) и \\(b\\) — константы.</p>\n
	<p>Формулы для вычисления коэффициентов имеют вид:</p>\n
	<p>\\[b=\\exp\\left(\\frac{n\\sum_{i=1}^{n}x_i\\ln y_i-\\sum_{i=1}^{n}x_i\\sum_{i=1}^{n}\\ln y_i}{n\\sum_{i=1}^{n}x_i^2-\\left(\\sum_{i=1}^{n}x_i\\right)^2}\\right)\\]</p>\n
	<p>\\[k=\\exp\\left(\\frac{1}{n}\\sum_{i=1}^{n}\\ln y_i-\\frac{\\ln b}{n}\\sum_{i=1}^{n}x_i\\right)\\]</p>\n
	<p>Суммарную квадратичную погрешность вычисляют по формуле:</p>\n
	<p>\\[R^{2}=1-\\frac{\\sum_{i=1}^{n}\\left(y_i-\\left(k\\cdot b^{x_i}\\right)\\right)^{2}}{\\sum_{i=1}^{n}\\left(k\\cdot b^{x_i}\\right)^{2}-\\frac{1}{n}\\left(\\sum_{i=1}^{n}\\left(k\\cdot b^{x_i}\\right)\\right)^{2}}\\]</p>\n
	<p><font color='#ff9100'><font size=\"4\">Примечание.</font></font> Экспоненциальная и степенная виды аппроксимации недоступны, если значения функции \\(f(x)\\) содержат отрицательные или нулевые значения.
 Кроме того, логарифмическая и степенная виды аппроксимации недоступны, если значения аргумента функции \\(x\\) содержат отрицательные или нулевые значения.</p>\n\n

	<h3>Пример вычисления показательной аппроксимации на Julia:</h3>
		<div class="code-container">
       		 <div class="code-header">
            		 Показательная аппроксимация 
           		 <span class="language-label">JULIA</span>
        	 </div>
       		 <pre><code class="language-julia"># Данные
x = [1, 2, 3, 4, 5]
y = [2, 4, 5, 4, 5]

# Показательная аппроксимация (y = a * b^x)
# Логарифмируем: ln(y) = ln(a) + x*ln(b)
coeffs = hcat(fill!(similar(x), 1), x) \ log.(y)

# Возвращаем обратно 
a = exp(coeffs[1])
b = exp(coeffs[2])</code></pre>
	        </div>

	<h2><i>Квадратичная аппроксимация</i></h2>\n
	<p><font color='#ff0000'>Метод квадратичной аппроксимации</font> относится к семейству методов полиномиальной аппроксимации. Идея <font color='#ff0000'>метода полиномиальной 
аппроксимации</font> состоит в том, что в некоторой окрестности минимума функции она аппроксимируется полиномом достаточно высокого порядка, и в качестве точки минимума функции (или в 
качестве очередного приближения к этой точке) принимается точка минимума аппроксимирующего полинома.</p>\n
	<p>Будем искать эмпирическую формулу вида:</p>\n
	<p>\\[y=ax^2+bx+c\\]</p>\n
	<p>Задача заключается в нахождении коэффициентов квадратичной зависимости, при которых функция трех переменных \\(a, b, c\\) принимает наименьшее значение:</p>\n
	<p>\\[F(a,b,c)=\\sum_{i=1}^{n}\\left(y_i-\\left(ax_i^2+bx_i+c\\right)\\right)^2\\tag{1}\\]</p>\n\n
	<h2><i>Вывод формул для нахождения коэффициентов</i></h2>\n
	<p>Найдем частные производные функции (1) по переменным \\(a,b,c\\) и приравняем эти производные к нулю:</p>\n
	<p>\\[\\frac{\\partial F}{\\partial a}=2\\sum_{i=1}^{n}\\left(y_i-\\left(ax_i^2+bx_i+c\\right)\\right)x_i^2=0\\]</p>\n
	<p>\\[\\frac{\\partial F}{\\partial b}=2\\sum_{i=1}^{n}\\left(y_i-\\left(ax_i^2+bx_i+c\\right)\\right)x_i=0\\]</p>\n
	<p>\\[\\frac{\\partial F}{\\partial c}=2\\sum_{i=1}^{n}\\left(y_i-\\left(ax_i^2+bx_i+c\\right)\\right)=0\\]</p>\n
	<p>Раскрыв скобки и перегруппировав слагаемые, получим систему нормальных уравнений:</p>\n
	<p>\\[\\begin{cases}\na\\sum_{i=1}^{n}x_i^4 + b\\sum_{i=1}^{n}x_i^3 + c\\sum_{i=1}^{n}x_i^2 = \\sum_{i=1}^{n}x_i^2 y_i \\\\\na\\sum_{i=1}^{n}x_i^3 + b\\sum_{i=1}^{n}x_i^2 + c\\sum_{i=1}^{n}x_i = \\sum_{i=1}^{n}x_i y_i \\\\\na\\sum_{i=1}^{n}x_i^2 + b\\sum_{i=1}^{n}x_i + n c = \\sum_{i=1}^{n}y_i\n\\end{cases}\\tag{2}\\]</p>\n
	<p>Найденная система уравнений (2) служит для нахождения коэффициентов \\(a,b,c\\). Решение этой системы определяет параболу, которая представляет найденную экспериментальную функцию.</p>\n
	<p>Абсолютная погрешность (разность между значениями аппроксимирующей функции и экспериментальными данными) во всех точках вычисляется по формуле:</p>\n
	<p>\\[R_i=\\left|\\left(ax_i^2+bx_i+c\\right)-y_i\\right|\\tag{3}\\]</p>\n<p>\\((i=1,2,...,n)\\)</p>\n
	<p>Обозначим \\(ax_i^2+bx_i+c=\\tilde{y}_i\\) и (3) перепишем в виде:</p>\n
	<p>\\[R_i=\\left|\\tilde{y}_i-y_i\\right|\\tag{4}\\]</p>\n
	<p>\\((i=1,2,...,n)\\)</p>\n<p>Суммарная квадратичная погрешность вычисляется по формуле:</p>\n
	<p>\\[R^2=1-\\frac{\\sum_{i=1}^{n}\\left(y_i-\\left(ax_i^2+bx_i+c\\right)\\right)^2}{\\sum_{i=1}^{n}\\left(ax_i^2+bx_i+c\\right)^2-\\frac{1}{n}\\left(\\sum_{i=1}^{n}\\left(ax_i^2+bx_i+c\\right)\\right)^2}\\tag{5}\\]</p>\n
	<p>\\((i=1,2,...,n)\\)</p>
	
	<h3>Пример вычисления квадратичной аппроксимации на Julia:</h3>
		<div class="code-container">
       		 <div class="code-header">
            		 Квадратичная аппроксимация 
           		 <span class="language-label">JULIA</span>
        	 </div>
       		 <pre><code class="language-julia"># Данные
x = [1, 2, 3, 4, 5]
y = [2, 4, 5, 4, 5]

# Квадратичная аппроксимация
coeffs = hcat(fill!(similar(x), 1), x, x.^2) \ y </code></pre>
	        </div>

`,
	"practica": `
	<h1><i>Аппроксимация</i></h1>
        <h2><i>Практическая работа №5</i></h2>

	<caption><h4>Пример 1.</h4></caption>
<p>Пусть в результате эксперимента получена таблица значений.</p>
<table> <thead> 
<tr> <th>\\( x \\)</th> <th>\\(1.1\\)</th> <th>\\(1.7\\)</th> <th>\\(2.4\\)</th> <th>\\(3.0\\)</th> <th>\\(3.7\\)</th> <th>\\(4.5\\)</th> <th>\\(5.1\\)</th> <th>\\(5.8\\)</th> </tr> </thead> 
<tbody> <tr> <td>\\( y \\)</td> <td>\\(0.3\\)</td> <td>\\(0.6\\)</td> <td>\\(1.1\\)</td> <td>\\(1.7\\)</td> <td>\\(2.3\\)</td> <td>\\(3.0\\)</td> <td>\\(3.8\\)</td> <td>\\(4.6\\)</td> </tr> </tbody> </table>

<h4>Алгоритм линейной регрессии методом наименьших квадратов (МНК)</h4>
<p>Добавляем входные данные</p>
<p>Шаг 1: Решение нормальных уравнений</p>
<pre><code class="language-julia">
function lin_regres(x::Vector{T}, y::Vector{T}) where T
    n = length(x)
    
    # Матрица плана: X = [1 x]
    X = [ones(n) x]
    
    # Нормальные уравнения: (XᵀX)β = Xᵀy
    β = (X'X) \ (X'y)
    
    # Возвращаем коэффициенты: β[1] - свободный член, β[2] - наклон
    return β[2], β[1]  # наклон, свободный член
end
</code></pre>

<p>Шаг 2: Вычисление статистик регрессии</p>
<pre><code class="language-julia">
function regres_stat(x::Vector{T}, y::Vector{T}, 
                     slope::T, intercept::T) where T
    
    n = length(x)
    
    # Предсказанные значения
    ŷ = intercept .+ slope .* x
    
    # Остатки (ошибки)
    residuals = y - ŷ
    
    # Суммы квадратов
    SST = sum((y .- mean(y)).^2)  
    SSR = sum((ŷ .- mean(y)).^2)   
    SSE = sum(residuals.^2)       
    
    # Коэффициенты качества
    R² = SSR / SST                # коэффициент детерминации
    RMSE = sqrt(SSE / (n - 2))    # среднеквадратическая ошибка
    
    # Стандартные ошибки коэффициентов
    σ_slope = sqrt(SSE / ((n - 2) * sum((x .- mean(x)).^2)))
    σ_intercept = σ_slope * sqrt(sum(x.^2) / n)
    
    return (R² = R², RMSE = RMSE,
            σ_slope = σ_slope, σ_intercept = σ_intercept,
            residuals = residuals)
end
</code></pre>

<p>Шаг 3: Визуализация и анализ</p>
<pre><code class="language-julia">
function analyze_and_plot(x_data, y_data)
    # Оценка коэффициентов
    slope, intercept = lin_regres(x_data, y_data)
    
    # Вычисление статистик
    stats = regres_stat(x_data, y_data, slope, intercept)
    
    # Вывод результатов
    println("Уравнение регрессии:")
    println("y = ($(round(slope, digits=4)) ± $(round(stats.σ_slope, digits=4)))·x + " *
            "($(round(intercept, digits=4)) ± $(round(stats.σ_intercept, digits=4)))")
    println("R² = $(round(stats.R², digits=4))")
    println("RMSE = $(round(stats.RMSE, digits=4))")
    
    # Построение графика
    x_range = range(minimum(x_data)-0.5, maximum(x_data)+0.5, length=200)
    y_pred = intercept .+ slope .* x_range
    
    p = scatter(x_data, y_data, label="Данные", color=:blue)
    plot!(p, x_range, y_pred, label="Линия регрессии", color=:red)
    
    return (slope = slope, intercept = intercept, 
            R² = stats.R², RMSE = stats.RMSE,
            residuals = stats.residuals)
end
</code></pre>

<p>Шаг 4: Прогнозирование</p>
<pre><code class="language-julia">
function main()
    # Анализ данных
    results = analyze_and_plot(x_data, y_data)
    
    # Прогноз для новых значений
    test_x = [2.0, 3.5, 5.0, 6.0]
    println("\nПрогнозные значения:")
    
    for x_val in test_x
        y_pred = results.intercept + results.slope * x_val
        println("при x = $x_val: ŷ = $(round(y_pred, digits=3)) ± $(round(results.RMSE, digits=3))")
    end
end
</code></pre>
<p>Добавляем главную функцию.</p>
<p>Выводим результат.</p>
	
	<caption><h4>Пример 2.</h4></caption>
<p>При исследовании влияния температуры на ход хронометра \\( \\omega \\) получены следующие результаты, приведенные в таблице.</p>
<table> <thead> <tr> <th>\\( t^\\circ, C \\)</th> <th>\\(5.0\\)</th> <th>\\(9.6\\)</th> <th>\\(16.0\\)</th> <th>\\(19.6\\)</th> <th>\\(24.4\\)</th> <th>\\(29.8\\)</th> <th>\\(34.4\\)</th> </tr> </thead> 
<tbody> <tr> <td>\\( \\omega \\)</td> <td>\\(2.60\\)</td> <td>\\(2.01\\)</td> <td>\\(1.34\\)</td> <td>\\(1.08\\)</td> <td>\\(0.94\\)</td> <td>\\(1.06\\)</td> <td>\\(1.25\\)</td> </tr> </tbody> </table>

<h4>Алгоритм квадратичной регрессии методом наименьших квадратов</h4>
<p>Добавляем входные данные.</p>
<p>Шаг 1: Полиномиальная регрессия</p>
<pre><code class="language-julia">
function polynom_regres(x::Vector{T}, y::Vector{T}, degree::Int) where T
    n = length(x)
    
    # Матрица Вандермонда: V = [1 x x² ... xᵈ]
    V = hcat([x.^k for k in 0:degree]...)  
    
    # Решение нормальных уравнений: VᵀVβ = Vᵀy
    β = V \ y
    
    return β  # коэффициенты полинома [c, b, a] для y = a·x² + b·x + c
end
</code></pre>

<p>Шаг 2: Статистика регрессии</p>
<pre><code class="language-julia">
function regres_stat(x::Vector{T}, y::Vector{T}, 
                     coefficients::Vector{T}) where T
    
    n = length(x)
    degree = length(coefficients) - 1
    
    # Предсказанные значения
    V = hcat([x.^k for k in 0:degree]...)
    ŷ = V * coefficients
    
    # Остатки
    residuals = y - ŷ
    
    # Коэффициенты качества
    SST = sum((y .- mean(y)).^2)           # общая вариация
    SSE = sum(residuals.^2)                # необъяснённая вариация
    R² = 1 - SSE/SST                       # коэффициент детерминации
    RMSE = sqrt(SSE / (n - degree - 1))    # среднеквадратическая ошибка
    
    # Стандартные ошибки коэффициентов
    σ² = SSE / (n - degree - 1)
    covβ = σ² * inv(V'V)                   # ковариационная матрица
    σ_coefficients = sqrt.(diag(covβ))     # стандартные ошибки
    
    return (R² = R², RMSE = RMSE, 
            residuals = residuals,
            σ_coefficients = σ_coefficients)  
end
</code></pre>

<p>Шаг 2: Анализ экстремума квадратичной функции</p>
<pre><code class="language-julia">
function quadr_extr(a::T, b::T, c::T) where T  
    # Для y = a·x² + b·x + c экстремум при x = -b/(2a)
    x_extremum = -b / (2a)
    y_extremum = a * x_extremum^2 + b * x_extremum + c
    
    # Определение типа экстремума
    extremum_type = a > 0 ? "минимум" : "максимум"
    
    return (x = x_extremum, y = y_extremum, type = extremum_type) 
end
</code></pre>

<p>Шаг 4: Визуализация и анализ</p>
<pre><code class="language-julia">
function analyze_and_plot(x_data, y_data)
    # Квадратичная регрессия (степень 2)
    β = polynom_regres(x_data, y_data, 2)
    a, b, c = β[3], β[2], β[1]  # y = a·x² + b·x + c
    
    # Статистика
    stats = regres_stat(x_data, y_data, β)
    
    # Нахождение экстремума
    extremum = quadr_extr(a, b, c)
    
    # Вывод результатов
    println("Уравнение регрессии:")
    println("y = ($(round(a, digits=6)) ± $(round(stats.σ_coefficients[3], digits=6)))·x² + " *
            "($(round(b, digits=6)) ± $(round(stats.σ_coefficients[2], digits:6)))·x + " *
            "($(round(c, digits=6)) ± $(round(stats.σ_coefficients[1], digits=6)))")
    println("R² = $(round(stats.R², digits=4))")
    println("Экстремум при x = $(round(extremum.x, digits=2)) (тип: $(extremum.type))")
    
    # Построение графика
    x_range = range(minimum(x_data)-2, maximum(x_data)+2, length=200)
    y_pred = c .+ b .* x_range .+ a .* x_range.^2
    
    p = scatter(x_data, y_data, label="Данные", color=:blue)
    plot!(p, x_range, y_pred, label="Квадратичная регрессия", color=:red)
    scatter!(p, [extremum.x], [extremum.y], label="Экстремум", color=:green)
    
    return (a = a, b = b, c = c, 
            extremum = extremum,
            R² = stats.R², RMSE = stats.RMSE)
end
</code></pre>
<p>Добавляем главную функцию.</p>
<p>Выводим результат.</p>
`,
	"test": {
            "timeLimit": 600,
            "questions": [
      {
        "question": "Что из перечисленного является целью построения эмпирической формулы на основе экспериментальных данных?",
        "answers": [
          {
            "text": "Найти аналитическое выражение, приближенно описывающее исследуемую зависимость.",
            "correct": true
          },
          {
            "text": "Получить точную математическую модель, проходящую через все экспериментальные точки.",
            "correct": false
          },
          {
            "text": "Определить функцию, значения которой близки к экспериментальным данным.",
            "correct": true
          }
        ],
        "type": "multiple"
      },
      {
        "question": "В каком случае следует использовать полиномиальную аппроксимацию?",
        "answers": [
          {
            "text": "Когда скорость изменения данных непрерывно возрастает.",
            "correct": false
          },
          {
            "text": "Когда исследуемая характеристика имеет несколько ярко выраженных экстремумов.",
            "correct": true
          },
          {
            "text": "Когда значения данных увеличиваются или убывают с постоянной скоростью.",
            "correct": false
          }
        ],
        "type": "single"
      },
      {
        "question": "Какие из перечисленных типов аппроксимации НЕЛЬЗЯ использовать, если среди данных встречаются нулевые или отрицательные значения?",
        "answers": [
          {
            "text": "Степенная аппроксимация.",
            "correct": true
          },
          {
            "text": "Экспоненциальная аппроксимация.",
            "correct": true
          },
          {
            "text": "Линейная аппроксимация.",
            "correct": false
          }
        ],
        "type": "multiple"
      },
      {
        "question": "Что характеризует коэффициент R² (суммарная квадратичная погрешность) в аппроксимации?",
        "answers": [
          {
            "text": "Сумму квадратов отклонений экспериментальных данных от аппроксимирующей функции.",
            "correct": false
          },
          {
            "text": "Достоверность аппроксимации: чем ближе к 1, тем надежнее функция аппроксимирует процесс.",
            "correct": true
          },
          {
            "text": "Среднее абсолютное отклонение между теоретическими и экспериментальными значениями.",
            "correct": false
          }
        ],
        "type": "single"
      },
      {
        "question": "Какие из следующих утверждений верны относительно метода наименьших квадратов при линейной аппроксимации?",
        "answers": [
          {
            "text": "Он находит коэффициенты k и b, при которых сумма квадратов отклонений экспериментальных данных от прямой минимальна.",
            "correct": true
          },
          {
            "text": "Он гарантирует, что аппроксимирующая прямая пройдет через все экспериментальные точки.",
            "correct": false
          },
          {
            "text": "Он сводится к нахождению экстремума функции двух переменных \\(F(k, b)\\).",
            "correct": true
          }
        ],
        "type": "multiple"
      }
    ]
        }
    },
    topic06: {
            "title": "Интерполяция",
            "theory": `
	<h1><i>Интерполяция</i></h1>\n
	<h2><i>Виды интерполяции</i></h2>\n
	<p>Пусть имеются значения функции, измеренные в нескольких точках, возникает задача, как найти значения функции в промежуточных точках. Такая задача называется задачей 
<font color = '#ff0000'>интерполяции</font> и часто возникает на практике.</p>\n
	<p>Например, в ходе медицинских исследований исследователь замеряет концентрацию вещества в крови исследуемого через определенные промежутки времени и ему известно, что 
концентрация находится в некоторой зависимости от времени. Исследователя интересует вопрос, какова была концентрация заданного вещества в любой из моментов в промежутках между взятием 
анализов. Для того чтобы ответить на этот вопрос строится интерполяционная кривая, которая помогает «восстановить» информацию о концентрации вещества на всем временном промежутке от 
первого до последнего анализа.</p>\n
	<p>В демографии проводится перепись населения через каждые 10 лет, с помощью интерполяции можно определить численность населения в промежуточных точках.</p>\n
	<p>В геологии проводится опробование месторождения и определяется концентрация полезных ископаемых в определенных точках, с помощью интерполяции можно оценить концентрацию в 
промежуточных точках.</p>\n
	<p>Интерполяция является частным случаем аппроксимации. Это – задача о нахождении такой аналитической функции \\(L(x)\\), которая принимает в точках (узлах) 
\\(x_{i}\\) заданные значения \\(y_{i}\\). Иными словами, аппроксимирующая функция в случае интерполяции обязательно проходит через заданные точки.</p>\n
	<p>Пусть табличная функция \\(y_{i}(x_{i})\\) задана координатами своих точек в плоскости \\(xy\\) на интервале \\(x\\in [a;b]\\). Внутри интервала \\([a;b]\\) собрано множество
 точек табличной функции. Требуется найти функцию \\(L(x)\\) в любых других точках, принадлежащих данному интервалу. Это – <font color = '#ff0000'>задача интерполяции</font>.</p>\n
	<p><font color = '#ff0000'>Интерполяцией</font> называют такую разновидность аппроксимации, при которой кривая построенной функции проходит точно через имеющиеся точки данных.</p>\n
	<p>На практике часто возникает задача о восстановлении непрерывной функции по ее табличным значениям, например, полученным в ходе некоторого эксперимента. Для вычисления многих 
функций оказывается эффективно приблизить их полиномами.</p>\n
	
	<h3><font color = '#ff9100'>Различают 2 вида интерполяции:</font></h3>\n
	<ol>\n    <li>Локальную (кусочную) – соединение точек отрезками прямой (по двум точкам), отрезками парабол (по трем точкам);</li>\n    
		  <li>Глобальную – соединение всех точек непрерывной функцией (единым интерполяционным полиномом).</li>\n</ol>\n
	<p>Методы глобальной интерполяции обычно применяют для функций, заданных небольшим количеством точек, т.к. при увеличении количества точек увеличивается порядок интерполирующего 
полинома, что отрицательно сказывается на гладкости получаемой функции.</p>\n
	<p>Для локальной интерполяции количество точек может быть произвольным.</p>\n
	<p>Термин «интерполяция» впервые ввел Джон Валлис в 1656г. при составлении астрономических и математических таблиц.</p>\n
	<p>Наибольшее распространение из методов глобальной интерполяции имеют полиномы Лагранжа, первая и вторая формулы Ньютона.</p>\n
	<p>Для локального интерполирования применяется линейная, квадратичная интерполяция и интерполяция кубическими сплайнами.</p>\n
	<p><font color = '#ffa726'>Полиномом</font> от \\(x\\) называется функция вида: \\[L(x)=a_{n}x^{n}+a_{n-1}x^{n-1}+...+a_{1}x+a_{0}\\] где \\(a_{0},a_{1},...,a_{n}\\) - постоянные 
числа (коэффициенты), \\(n\\) - целое неотрицательное число (степень полинома).</p>\n
	<p>Экспериментальные табличные данные очень часто удобно интерпретировать как некоторую функцию, например, полиномиальную или сплайн – гладкую функцию, которая на отрезках области
 определения равна полиномам определенной степени.</p>\n
	
	<h3><font color = '#ff9100'>Различают 2 критерия приближения табличных функций:</font></h3>\n<ol>\n    
		<li>Интерполирование, при котором аппроксимирующая функция совпадает с табличной в узлах (точках);</li>\n    
		<li>Сглаживание, основанное на минимизации суммы квадратов отклонений в точках таблицы.</li>\n</ol>\n
	<p>Самым простым способом интерполяции является аппроксимация данных сплайном нулевого порядка (на каждом отрезке степень полинома = 0), при которой значение в каждой промежуточной
 точке принимается равным ближайшему значению, заданному в таблице. В результате данные приближаются ступенчатой функцией, а приближение называется <font color = '#ff0000'>интерполяцией по
 соседним точкам</font>.</p>\n
	<p><font color = '#ff0000'>Линейная интерполяция</font> основана на соединении соседних точек отрезками прямых – табличные данные приближаются ломаной линией.</p>\n

	<h3>Функция для линейной интерполяции на Julia:</h3>
		<div class="code-container">
       		 <div class="code-header">
            		Линейная интерполяция
           		 <span class="language-label">JULIA</span>
        	 </div>
       		 <pre><code class="language-julia">function linear_interp(x_nodes::Vector{T}, y_nodes::Vector{T}, 
                                    x_interp::Vector{T}) where T
    results = T[]
    for x in x_interp
        # Находим интервал
        idx = 1
        for i in 1:length(x_nodes)-1
            if x_nodes[i] <= x <= x_nodes[i+1]
                idx = i
                break
            end
        end
        
        # Линейная интерполяция
        x1, x2 = x_nodes[idx], x_nodes[idx+1]
        y1, y2 = y_nodes[idx], y_nodes[idx+1]
        V = y1 + (y2 - y1) * (x - x1) / (x2 - x1)
        push!(results, V)
    end
    return results
end
</code></pre>
	        </div>

	<p>Для получения более гладкой функции нужно применять <font color = '#ff0000'>интерполяцию кубическими сплайнами</font>.</p>\n
	<p>Пусть на отрезке \\([a;b]\\) заданы функции \\(y=f(x)\\) в точках \\(a\\leq x_{0} < x_{1} < x_{2}<...< x_{n}\\leq b\\), тогда \\(f(x_{0})=y_{0},f(x_{1})=y_{1},...,f(x_{n})=y_{n}\\)</p>\n

		<p><font color = '#ff0000'>Интерполяция</font> - нахождение полинома не выше \\(n\\) - ой степени. \\[L_{n}(x)=a_{0}x^{n}+a_{1}x^{n-1}+a_{2}x^{n-2}+...+a_{n-1}x+a_{n}\\tag{1}\\] который в точках \\(x_{0},x_{1},...,x_{n}\\) 
принимает те же значения, что и данная функция, т.е. выполняется равенство: \\[L_{n}(x_{i})=f(x_{i})=y_{i}\\tag{2}\\] \\((i=0,1,...,n)\\)</p>\n
	<p>Т.е. интерполяция – нахождение полинома вида (1), который на отрезке \\([a;b]\\) являлся бы приближением для функции \\(y=f(x)\\).</p>\n
	<p>Функция \\(L_{n}(x)\\) называется <font color = '#ff0000'>интерполирующей</font>, процесс ее построения – <font color = '#ff0000'>интерполированием</font>, а точки 
\\(x_{0},x_{1},...,x_{n}\\), в которых значения интерполирующей функции должны совпадать с заданными значениями данной функции – <font color = '#ff0000'>узлами интерполирования</font>.</p>\n\n

	<h1><i>Глобальное интерполирование</i></h1>\n
	<p>Вариант интерполяции, когда интерполяционный полином строится сразу по всем узлам интерполяции называется <font color = '#ff0000'>глобальной интерполяцией</font>.</p>\n
	<p>При этом увеличение числа узлов автоматически приводит к повышению степени полинома, и как следствие, к проявлению его колебательных свойств</p>\n
	<img src = \"https://sun9-69.userapi.com/impg/YZftkeOYHZwYOsYwSkyYDNkakedjhPBJw3GANg/sfjgPQDxVIQ.jpg?size=340x225&quality=96&sign=c51a72561bf72f688e0780edc825ed4e&type=album\">\n

	<h2><i>Интерполяционный  полином  Лагранжа</i></h2>\n
	<p>При глобальной интерполяции на всем интервале \\([a,b]\\) строится единый полином. Одной из форм записи интерполяционного многочлена для глобальной интерполяции является 
многочлен Лагранжа.</p>\n
	<p>Интерполяционный полином Лагранжа - это математическая функция, позволяющая записать полином \\(n\\) - ой степени, который будет соединять все заданные точки из набора значений, 
полученных опытным путем в различные моменты времени с непостоянным временным шагом измерений.</p>\n
	<p>Пусть функция \\(y=f(x)\\) задана таблицей</p>\n
	<img src = \"https://sun9-1.userapi.com/impg/g9rt0m5rPMtMWbf0f73scalvP2fvpEkm-QHDAQ/PYLiPUrmBUU.jpg?size=594x77&quality=96&sign=054eb6f80f53919f0bdffabfdc5990b1&type=album\">\n
	<p>Задачей интерполяции является построение полинома \\(L(x)\\), значения которого в точках \\(x_{k}\\) равны соответствующим значениям заданной функции, т.е. \\[L(x_{k})=y_{k},\\;\\; k=0,1,...,n\\tag{1.1}\\]</p>\n
	<p>Интерполяционной формулой Лагранжа называется формула, представляющая полином \\(n\\) - ой степени \\(L_{n}(x)\\) в виде: \\[L_{n}(x)=\\sum_{k=0}^{n}{y_{k}p_{k}(x)}\\tag{1.2}\\] 
где \\(p_{k}(x)\\) - полином \\(n\\) - ой степени, принимающей значения, равное 1 в точке \\(x_{k}\\) и равное 0 – в остальных точках \\(x_{j}, j\\neq k,k,j=0,1,...,n\\) и имеющей вид: 
\\[p_{k}(x)=\\prod_{k,j\\neq 0;j\\neq k}^{n}\\frac{x-x_{j}}{x_{k}-x_{j}}={\\frac{(x-x_{0})(x-x_{1})...(x-x_{k-1})(x-x_{k+1})...(x-x_{n})}{(x_{k}-x_{0})(x_{k}-x_{1})...(x_{k}-x_{k-1})(x_{k}-x_{k+1})...(x_{k}-x_{n})}}\\tag{1.3}\\]</p>\n
	<p>Полином \\(L_{n}(x)\\) называется <font color = '#ff0000'>интерполяционным полиномом Лагранжа</font>.</p>\n
	<p>В узлах интерполяции погрешность интерполяционного полинома \\(L_{n}(x)\\) равна нулю, т.е. \\(L_{n}(x)-y_i=0,\\;\\;i=0,1,...,n\\).</p>\n
	<p>Погрешность \\(L_{n}(x)-f(x)\\), представляющая собой разность между значением интерполяционного полинома \\(L_{n}(x)\\) и значением функции \\(f(x)\\) в точке \\(x\\), не 
совпадающей с узлом интерполяции, имеет вид: \\[f(x)-L_n(x) =\\frac{f^{(n+1)}({\\xi} )}{(n+1)!}(x-x_0)\\cdot (x-x_1)\\cdot ...\\cdot (x-x_n),\\;\\;{\\xi} \\in [x_0;x_n]\\tag{1.4}\\] 
где \\(x\\) - точка, в которой ищется погрешность (не совпадает с узлами интерполяции).</p>\n<p>Поскольку точка \\({\\xi} \\in [x_0;x_n]\\) неизвестна, то вместо погрешности, определяемой 
выражением (1.4) , вводится верхняя оценка погрешности в виде: \\[\\left| R_{n}(x)\\right|=\\left| f(x)-L_n(x)\\right| \\leq \\frac{M_{n+1}}{(n+1)!}\\left|(x-x_0)\\cdot (x-x_1)\\cdot ...\\cdot
 (x-x_n)\\right|\\tag{1.5}\\] где \\(M_{n+1}= \\max |f^{(n+1)}({\\xi})|,\\;\\;{\\xi}\\in [x_0;x_n]\\), которая обычно используется на практике.</p>\n
	<p>Выражение  (1.4)  может служить оценкой погрешности \\(f(x)\\) от \\(L_{n}(x)\\), если производная \\(f^{(n+1)}(x)\\) может быть определена.</p>\n
	<p>Таким образом, <font color = '#ff0000'>погрешность интерполяции</font> зависит как от величины, соответствующей производной приближаемой функции, так и от расположения узлов.
 (1.5) дает хорошие результаты только внутри отрезка, содержащего узлы интерполяции, и в непосредственной окрестности его границ. При этом точность тем выше, чем более гладко ведет себя 
\\((n+1)\\)-я производная рассматриваемой функции.</p>\n<p><font color = '#ff0000'>Интерполяционные полиномы Лагранжа</font> используются в <font color = '#ff0000'>методе конечных 
элементов</font>, широко применяемом при решении задач строительства.</p>\n
	
	<h3>Функция для интерполяции полиномом Лагранжа на Julia:</h3>
		<div class="code-container">
       		 <div class="code-header">
            		Интерполяция полиномом Лагранжа
           		 <span class="language-label">JULIA</span>
        	 </div>
       		 <pre><code class="language-julia">function lagrange_interp(x_nodes::Vector{T}, y_nodes::Vector{T}, 
                               x_interp::Vector{T}) where T
    n = length(x_nodes)
    
    # Базисные полиномы Лагранжа: Lᵢ(x) = Πⱼ≠ᵢ (x - xⱼ)/(xᵢ - xⱼ)
    function lagrange_basis(i::Int, x::T)
        product = one(T)
        for j in 1:n
            if j != i
                product *= (x - x_nodes[j]) / (x_nodes[i] - x_nodes[j])
            end
        end
        return product
    end
    
    # Интерполяционный полином: Pₙ(x) = Σᵢ yᵢ•Lᵢ(x)
    results = T[]
    for x in x_interp
        P = zero(T)
        for i in 1:n
            P += y_nodes[i] * lagrange_basis(i, x)
        end
        push!(results, P)
    end
    
    return results
end
</code></pre>
</div>	
	
	<p>Глобальная интерполяция полиномом высокой \\((n>10)\\) степени нежелательна, поскольку</p>\n<ol>\n    
		<li>при вычислении полинома высокой степени могут накапливаться ошибки округления;</li>\n    
		<li>интерполяционный полином может плохо приближать исходную функцию;</li>\n    
		<li>задача интерполяции может быть плохо обусловлена  (интерполяционный полином чувствителен к возмущениям значений в узлах).</li>\n</ol>\n
	<p><font color = '#ffa726'><font size=\"4\">Пример.</font></font> Построить полином Лагранжа второй степени, аппроксимирующий функцию \\(y=\\sin x\\) на отрезке 
\\([0;\\dfrac{\\pi}{4}]\\), если заданы функции в трех узлах интерполяции</p>\n<img src = \"https://sun9-7.userapi.com/impg/AOhTbLPJA5YudWb0CyQMCEbFiIsjkzHXqs7eCg/Otb6jvc-xQk.jpg?size=505x99&quality=96&sign=4c4be4b33ae5ef473060951e317c33d8&type=album\">\n
	<p>С помощью интерполяционной формулы вычислить приближенное значение \\(\\sin(\\dfrac{\\pi}{12})\\) и оценить погрешность результата вычислений.</p>\n


	<h4><font color = '#ffa726'>Решение:</font></h4>\n
	<p>Полином Лагранжа для трех узлов интерполяции запишется в виде \\((n=2)\\): \\[L_{2}(x)=y_{0}\\frac{(x-x_{1})(x-x_{2})}{(x_{0}-x_{1})(x_{0}-x_{2})}+y_{1}\\frac{(x-x_{0})(x-x_{2})}
{(x_{1}-x_{0})(x_{1}-x_{2})}+y_{2}\\frac{(x-x_{0})(x-x_{1})}{(x_{2}-x_{0})(x_{2}-x_{1})}\\] \\[L_{2}(x)=0,5\\frac{x\\left(x- \\frac{\\pi }{4}\\right)}{\\frac{\\pi }{6}\\left( \\frac{\\pi }
{6}-\\frac{\\pi }{4}\\right)}+0,707\\frac{x\\left( x-\\frac{\\pi }{6}\\right)}{\\frac{\\pi }{4}\\left( \\frac{\\pi }{4}-\\frac{\\pi }{6}\\right)}=-2,064\\frac{x^{2}}{\\pi ^{2}}+3,344\\frac
{x}{\\pi}\\] при \\(x=\\dfrac{\\pi }{12}=0,2617994\\) получим \\(L(\\dfrac{\\pi }{12})=0,264298\\).</p>\n
	<p>С помощью неравенства (1.5) находим оценку погрешности: \\[\\left|\\sin\\left( \\frac{\\pi }{12}\\right)-L\\left( \\frac{\\pi}{12} \\right)\\right|\\leq \\frac{M_{3}}{3!}\\left
|x\\left( x-\\frac{\\pi }{6}\\right)\\left( x-\\frac{\\pi }{4}\\right) \\right|\\]</p>\n<p>Так как \\(f(x)=\\sin x\\), \\(f'(x)=\\cos x\\), \\(f''(x)=-\\sin x\\), \\(f'''(x)=-\\cos x\\), 
то \\[M_3=\\max|f'''(x)|=\\max|-\\cos x|=1\\;\\;0\\leq x\\leq \\frac{\\pi }{4}\\] следовательно, \\[\\left|\\sin\\left( \\frac{\\pi }{12}\\right)-L\\left( \\frac{\\pi }{12}\\right) \\right
|\\leq \\frac{1}{3}\\left( \\frac{\\pi }{12}\\right)^{3}\\approx 0,006\\]</p>\n
	<p><font color = '#008000'><font size=\"4\">Ответ:</font></font> \\(\\sin\\left(\\dfrac{\\pi }{12} \\right)\\approx 0,264\\pm 0,006\\)</p>\n\n\n

	<h1><i>Альтернатива глобальной интерполяции</i></h1>\n
	<h2><i>Интерполяция сплайнами</i></h2>\n
	<p>Естественная потребность в наличии функций, которые сочетали бы в себе локальную простоту полинома невысокой степени и глобальную на всем отрезке \\([a,b])\\ гладкость привела к 
появлению в 1946 г. так называемых <font color = '#ff0000'>сплайн-функций</font> или <font color = '#ff0000'>сплайнов</font> &mdash; специальным образом построенных гладких кусочно-полиномиальных 
функций.   Получив в 60-х годах распространение как средство интерполяции сложных кривых, сплайны к настоящему времени стали важной составной частью самых различных вычислительных методов
 и нашли широчайшее применение в решении разнообразных научно-технических и инженерных задач.</p>\n
<p>Примером таких задач является исследование участка грунта на других планетах, форм небесных тел, информация о которых получена в результате спутниковых съемок, микрообъектов, снятых с
 помощью электронных микроскопов.</p>\n<p>Принципиальное отличие идеи сплайн-интерполяции от интерполяции полиномом состоит в том, что полином один, а сплайн состоит из нескольких полиномов
, а именно их количество равно количеству интервалов, внутри которых производят интерполяцию.</p>\n
	<p><font color = '#ff0000'>Сплайн</font> &mdash; это функция, которая вместе с несколькими производными непрерывна на всем заданном отрезке \\([a,b]\\), а на каждом частичном 
отрезке \\([x_i;x_{i+1}]\\) в отдельности является некоторым алгебраическим полиномом.</p>\n
	<p><font color = '#ff0000'>Сплайном степени \\(m\\)</font> называется функция , обладающая следующими свойствами:</p>\n
		<ol>\n    <li>Функция \\(S_{m}(x)\\) непрерывна на отрезке \\([a,b]\\) вместе со всеми производными \\(S'_m(x),\\;S''_m(x),...,S^{(p)}_m(x)\\) до некоторого порядка \\(p\\);<\/li>\n   
			  <li>На каждом частичном отрезке \\([x_{i-1};x_i]\\) функция \\(S_{m}(x)\\) совпадает с некоторым алгебраическим полиномом \\(P_{m,i}(x)\\) степени \\(m\\).<\/li>\n<\/ol>\n
	<p><font color = '#ff0000'>Степенью сплайна</font> называется максимальная по всем частичным отрезкам степень полинома.</p>\n
	<p><font color = '#ff0000'>Дефектом сплайна</font> называется разность \\(m-p\\) между степенью сплайна и наивысшим порядком  непрерывной на \\([a,b]\\) производной.</p>\n
	<p>Простейший пример сплайна дает непрерывная кусочно-полиномиальная функция, являющаяся сплайном первой степени <font color = '#ff0000'>(линейным сплайном)</font> с дефектом,
 равным единице.  Действительно, на отрезке \\([a,b]\\) сама функция \\(s_{1}(x)\\) (нулевая производная) непрерывна. В то же время на каждом частичном отрезке \\(S_{1}(x)\\) совпадает с 
некоторым полиномом первой степени.</p>\n
	<img src = \"https://sun9-40.userapi.com/impg/KgfJkWWedzWrtdBdNTmRPV_hUZjvCAuo9BRaSQ/UZsU9m6PQ7Y.jpg?size=241x151&quality=96&sign=9d9e68339216904e0412dc71c87eed68&type=album\">\n
	
	<h3>Функция для интерполяции кубическими сплайнами на Julia:</h3>
		<div class="code-container">
       		 <div class="code-header">
            		Интерполяция кубическими сплайнами
           		 <span class="language-label">JULIA</span>
        	 </div>
       		 <pre><code class="language-julia">function cub_interp(x_nodes::Vector{T}, y_nodes::Vector{T}, 
                            x_interp::Vector{T}) where T
    n = length(x_nodes)
    results = T[]
    
    # Для каждой точки интерполяции
    for x in x_interp
        # Находим интервал
        idx = 1
        for i in 1:n-1
            if x_nodes[i] <= x <= x_nodes[i+1]
                idx = i
                break
            end
        end
        
        if idx < n-1
            # Используем кубический полином по 4 точкам
            idxs = max(1, idx-1):min(n, idx+2)
            x4 = x_nodes[idxs]
            y4 = y_nodes[idxs]
    end
    
    return results
end

</code></pre>
</div>

	<p>Наиболее широкое распространение на  практике получили сплайны \\(S_{3}(x)\\) третьей степени <font color = '#ff0000'>(кубические сплайны)</font> с дефектом, равным 1 или 2, т.е.
 интерполяция происходит отрезками кубических парабол. При этом величина \\(m_i=S_3'(x_i)\\), называется <font color = '#ff0000'>наклоном сплайна</font> в точке (узле).</p>\n
	<p>Такие сплайны на каждом из частичных отрезков \\([x_{i-1};x_i]\\) совпадают с кубическим полиномом: \\[S_3(x)=P_{3,i}(x)=a_i+b_i(x-x_{i-1})+c_i(x-x_{i-1})^2+d_i(x-x_{i-1})^3\\]\\((i=1,2,...,n,\\;\\;x\\in [x_i; x_{i+1}])\\)</p>\n
	<p>и имеют на отрезке \\([a,b]\\) по крайней мере одну непрерывную производную \\(S'_3(x)\\).</p>\n<p>Термин «сплайны» происходит от английского слова \"spline\" (гибкая линейка, 
стержень) &mdash; названия приспособления, использовавшегося чертежниками для проведения гладких кривых через заданные точки. Если гибкую стальную линейку поставить на ребро и, изогнув, 
зафиксировать ее положение в узловых точках, то получится механический аналог кубического сплайна</p>\n
	<img src = \"https://sun9-71.userapi.com/impg/CVmdYGQ4Yy_Ls1ulUXDl3cyyoMjOuv-m9awEaA/qSLhdySkXUQ.jpg?size=288x158&quality=96&sign=cf1f91c33e80a0490662708aa1d3e255&type=album\">\n
	<p>В самом деле, из курса сопротивления материалов известно, что уравнение свободного равновесия профиля \\(S(x)\\) линейки такого: \\(S^{(4)}(x)=0\\). Следовательно, в промежутке 
между двумя соседними узлами \\(S(x)\\) представляет собой полином третьей степени. В то же время отсутствие у линейки изломов свидетельствует о непрерывности касательной к графику функции
 \\(S(x)\\) и кривизны, т.е. производных \\(S'(x)\\) и \\(S''(x)\\). Сплайны широко применяются в авиа-, судо- и автомобилестроении, где форма поверхности объекта является очень сложной 
(имеет большое количество интерполяционных точек).</p>\n
	<p><font color = '#ff0000'>Кубическим сплайном</font> на отрезке \\([a,b]\\) называется функция \\(S_{3}(x)\\), которая удовлетворяет краевым условиям:</p>\n
	<ol>\n    <li>Она совпадает с интерполируемой функцией в узлах интерполяции, т.е. \\[S_{3i}(x_i)=f_{i}(x_i),\\;\\; i=1,2,...,n\\]<\/li>\n    
		<li>Выполняется условие равенства первых производных в точках \\(x_{i}\\) \\[S'_{3i}(x_i)=S'_{3(i+1)}(x_i),\\;\\;i=1,2,...,n\\]<\/li>\n   
		<li>выполняется равенство вторых производных в точках \\(x_{i}\\) \\[S''_{3i}(x_i)=S''_{3(i+1)}(x_i),\\;\\;i=1,2,...,n.\\]<\/li>\n<\/ol>\n
	<p>Основным достоинством интерполяционного <font color = '#ff0000'>кубического сплайна дефекта один</font> является следующее: этот сплайн обладает <font color = '#ff0000'>
минимумом интегральной кривизны</font> на всем заданном отрезке \\([a,b]\\) по сравнению с другими интерполяционными функциями.</p>\n
	<p>Геометрически это означает, что если тяжелую упругую нить повесить на ряд гвоздей, то она примет форму кубического сплайна дефекта 1</p>\n
	<img src = \"https://sun9-22.userapi.com/impg/oXGUlQIoHTO_mk7yjaPmKSLj1NoRjCUh4UC22g/WKWq9j2_kPU.jpg?size=456x100&quality=96&sign=6a04f5459da1d3a82a23606e299a3a6e&type=album\">\n
	<p>Метод сплайн-интерполяции приводит к удовлетворительным результатам в процессе интерполяции непрерывных функций с гладкими первой и второй производными. При этом кубический 
интерполяционный сплайн  будет обладать минимальной кривизной по сравнению с кривизной любой интерполяционной функции, имеющей непрерывные первую и вторую производные. Сплайн-интерполяция
 функций с резким изменением производных сплайна может давать большие погрешности. Сплайны более высокого порядка, чем третий, используются редко, так как при вычислении большого числа 
коэффициентов может накапливаться погрешность, приводящая к значительным отклонениям.</p>\n\n\n

	<h2><i>Применение интерполирования</i></h2>\n
	<p>Многие формулы численного дифференцирования можно получить как следствие интерполяционных формул. Для этого достаточно заменить функцию \\(f(x)\\) ее интерполяционным 
многочленом \\(L_n(x)\\) и вычислить производные многочлена \\(L_n(x)\\), используя его явное представление.</p>\n
	<p>Положим \\(h_i=x_i-x_i-1,\\;i=1:n\\). Величину \\(H=x_n-x_0\\) будем считать достаточно малой. По значениям функции \\(f(x)\\) в этих узлах построим интерполяционный многочлен 
\\(L_n(x)\\). По формуле Лагранжа \\[L_n(x)=\\sum_{i=0}^{n}f(x_i)l_i(x),\\;l_i(x)=\\prod_{j=0,j\\neq i}^{n}\\frac{x-x_j}{x_i-x_j}=\\frac{\\omega_{n+1}(x)}{(x-x_i)\\omega'_{n+1}(x_i)}\\tag{21}\\]</p>\n
	<p>где \\(\\omega_{n+1}(x)=(x-x_0)...(x-x_n)\\). Для \\(k\\le n\\) изучим аппроксимацию \\[f^{(k)}\\approx L_n^{(k)}(x),\\;x\\in [x_0,x_n]\\tag{22}\\]</p>\n
	<p>Для погрешности нами была получена формула \\[f(x)-L_n(x)=\\frac{f^{(n+1)}(\\xi(x))}{(n+1)!}\\omega_{n+1}(x)\\tag{23}\\]</p>\n
	<p>Для рассматриваемых \\(x\\in [x_0,x_n]\\), очевидно, \\(\\left| \\omega_{n+1}(x) \\right|\\le H^{n+1}\\). Это грубая оценка. Для ее уточнения надо сделать предположение о законе
 распределения узлов сетки. Для узлов с равномерным шагом \\(h=\\dfrac{H}{n}\\) имеем \\(\\left| \\omega_{n+1}(x) \\right|\\le \\dfrac{n!}{4h^{n+1}}\\)</p>\n
	<p>Из (23) следует оценка \\[\\left| f(x)-L_n(x) \\right|\\le \\frac{M_{n+1}H^{n+1}}{(n+1)!}\\tag{24}\\]</p>\n<p><font color = '#ff9100'>Теорема 1.</font> Если \\(f\\in C^{n+1}[a,b]
\\), то для любого \\(x\\in [x_0,x_n]\\) \\[\\left| f^{(k)}(x)-L^{(k)}_n(x) \\right|\\le \\frac{M_{n+1}H^{n+1-k}}{(n+1-k)!},\\;\\;k=0:n\\tag{25}\\]</p>\n
	<p><font color = '#ffa726'><font size=\"4\">Пример 1.</font></font> \\(n=1\\). В этом случае \\[L_1(x)=\\frac{x-x_1}{x_0-x_1}f(x_0)+\\frac{x-x_0}{x_1-x_0}f(x_1)\\]</p>\n
	<p>и для любого \\(x\\in [x_0,x_1]\\) имеем \\[f'(x)\\approx L'_1(x)=\\frac{f(x_1)-f(x_0)}{x_1-x_0}\\]</p>\n
	<p>Правая часть совпадает с разностью вперед в точке \\(x\\), если точки \\(x_0\\) и \\(x_1\\) выбрать следующим образом: \\(x_0=x,\\;x_1=x+h\\). При \\(x_1=x,\\;x_0=x-h\\) 
получаем аппроксимацию \\(f'(x)\\) разностью назад, при \\(x_0=x-h,\\;x_1=x+h\\) &mdash; центральную разность.</p>\n
	<p><font color = '#ffa726'><font size=\"4\">Пример 2.</font></font> n=2. В этом случае для любого \\(x\\in [x_0,x_2]\\) имеем: \\[f'(x)\\approx L'_2(x)=\\frac{2}{x_2-x_0}((x-x_{1/2}
)\\frac{f(x_2)-f(x_1)}{x_2-x_1}+(x_{3/2}-x)\\frac{f(x_1)-f(x_0)}{x_1-x_0})\\] \\[f''(x)\\approx L''_2(x)=\\frac{2}{x_2-x_0}(\\frac{f(x_2)-f(x_1)}{x_2-x_1}-\\frac{f(x_1)-f(x_0)}{x_1-x_0})\\]</p>\n
	<p>где \\(x_{1/2}=\\dfrac{(x_0+x_1)}{2},\\;x_{3/2}=\\dfrac{(x_1+x_2)}{2}\\). Если \\(x_0=x-h,\\;x_1=x,\\;x_2=x+h\\), то получаем аппроксимацию \\(f'(x)\\) центральной разностью и 
аппроксимацию \\(f''(x)\\) разностью \\(fS_{x\\overline{x}}(x)\\).</p>
    `,
	"practica": `
	<h1><i>Интерполяция</i></h1>
        <h2><i>Практическая работа №6</i></h2>

	<caption><h4>Пример 1.</h4></caption>
<p>Дана таблица для термопары с показаниями \\(V \\)вольтметра:</p>

<table>
<thead>
<tr>
<th>\\( T \\)</th>
<th>\\(0°\\)</th>
<th>\\(20°\\)</th>
<th>\\(40°\\)</th>
<th>\\(60°\\)</th>
<th>\\(80°\\)</th>
</tr>
</thead>
<tbody>
<tr>
<td>\\( V \\)</td>
<td>\\(-0.67\\)</td>
<td>\\(-0.25\\)</td>
<td>\\(0.17\\)</td>
<td>\\(0.61\\)</td>
<td>\\(1.08\\)</td>
</tr>
</tbody>
</table>

<p>Найти показания вольтметра при температуре \\( T = 15^\\circ \\) и \\( T = 55^\\circ \\), используя линейную, квадратичную и полиномиальную интерполяцию.</p>

<h4>Алгоритм интерполяции данных различными методами</h4>
<p>Добавляем входные данные.</p>
<p>Шаг 1: Интерполяция Лагранжа</p>
<pre><code class="language-julia">
function lagrange_interp(x_nodes::Vector{T}, y_nodes::Vector{T}, 
                         x_interp::Vector{T}) where T
    n = length(x_nodes)
    
    function lagrange_basis(i::Int, x::T)
        product = one(T)
        for j in 1:n
            if j != i
                product *= (x - x_nodes[j]) / (x_nodes[i] - x_nodes[j])
            end
        end
        return product
    end
    
    # Интерполяционный полином Лагранжа: Pₙ(x) = Σᵢ yᵢ·Lᵢ(x)
    results = T[]
    for x in x_interp
        P = zero(T)
        for i in 1:n
            P += y_nodes[i] * lagrange_basis(i, x)
        end
        push!(results, P)
    end
    return results
end
</code></pre>

<p>Шаг 2: Интерполяция Ньютона</p>
<pre><code class="language-julia">
function newton_interp(x_nodes::Vector{T}, y_nodes::Vector{T}, 
                       x_interp::Vector{T}) where T
    n = length(x_nodes)
    
    # Таблица разделенных разностей
    f = copy(y_nodes)
    for j in 2:n
        for i in n:-1:j
            f[i] = (f[i] - f[i-1]) / (x_nodes[i] - x_nodes[i-j+1])
        end
    end
    
    # Интерполяционный полином Ньютона
    results = T[]
    for x in x_interp
        P = f[n]
        for i in n-1:-1:1
            P = f[i] + (x - x_nodes[i]) * P
        end
        push!(results, P)
    end
    return results
end
</code></pre>

<p>Шаг 3: Линейная интерполяция</p>
<pre><code class="language-julia">
function linear_interp(x_nodes::Vector{T}, y_nodes::Vector{T}, 
                       x_interp::Vector{T}) where T
    results = T[]
    for x in x_interp
        # Поиск интервала, содержащего x
        idx = 1
        for i in 1:length(x_nodes)-1
            if x_nodes[i] ≤ x ≤ x_nodes[i+1]
                idx = i
                break
            end
        end
        
        # Линейная интерполяция
        x1, x2 = x_nodes[idx], x_nodes[idx+1]
        y1, y2 = y_nodes[idx], y_nodes[idx+1]
        y = y1 + (y2 - y1) * (x - x1) / (x2 - x1)
        push!(results, y)
    end
    return results
end
</code></pre>

<p>Шаг 4: Кубическая интерполяция</p>
<pre><code class="language-julia">
function cub_interp(x_nodes::Vector{T}, y_nodes::Vector{T}, 
                    x_interp::Vector{T}) where T
    n = length(x_nodes)
    results = T[]
    
    for x in x_interp
        # Поиск интервала
        idx = 1
        for i in 1:n-1
            if x_nodes[i] ≤ x ≤ x_nodes[i+1]
                idx = i
                break
            end
        end
        
        if idx < n-1
            # Кубическая интерполяция по 4 точкам
            idxs = max(1, idx-1):min(n, idx+2)
            x4 = x_nodes[idxs]
            y4 = y_nodes[idxs]
            
            # Полином Лагранжа 3-й степени
            y = zero(T)
            for i in 1:length(x4)
                term = y4[i]
                for j in 1:length(x4)
                    if j ≠ i
                        term *= (x - x4[j]) / (x4[i] - x4[j])
                    end
                end
                y += term
            end
            push!(results, y)
    end
    return results
end
</code></pre>

<p>Шаг 5: Визуализация</p>
<pre><code class="language-julia">
function plot_graph(x_data, y_data, x_interp)
    # Плотная сетка для построения кривых
    x_dense = range(minimum(x_data), maximum(x_data), length=200)
    
    # Интерполяция 
    V_lagrange_dense = lagrange_interp(x_data, y_data, collect(x_dense))
    V_linear_dense = linear_interp(x_data, y_data, collect(x_dense))
    V_cubic_dense = cub_interp(x_data, y_data, collect(x_dense))
    
    # Построение графика
    p = plot(x_dense, V_lagrange_dense, label="Лагранж", color=:red, linewidth=2)
    plot!(p, x_dense, V_linear_dense, label="Линейная", color=:blue, linestyle=:dash)
    plot!(p, x_dense, V_cubic_dense, label="Кубическая", color=:green, linestyle=:dashdot)
    scatter!(p, x_data, y_data, label="Данные", color=:black, markersize=6)
    scatter!(p, x_interp, lagrange_interp(x_data, y_data, x_interp), 
             label="Точки интерполяции", color=:red, markersize=8)
    
    return p
end
</code></pre>
<p>Добавляем главную функцию.</p>
<p>Выводим результат.</p>

	
	<caption><h4>Пример 2.</h4></caption>
<p>Построить интерполяционный полином Лагранжа для функции, заданной таблично. Найти приближенные значения функции \\( y = f(x) \\) в точках, смещенных относительно 
экспериментальных данных на величину \\( h \\), где \\[ h = \\dfrac{x_1 - x_0}{2}. \\]</p>
<table>
    <tbody>
        <tr>
            <td style="border: 1px solid black;">\\(x\\)</td><td style="border: 1px solid black;">\\(0,75\\)</td><td style="border: 1px solid black;">\\(1,5\\)</td><td style="border: 1px solid black;">\\(2,25\\)</td><td style="border: 1px solid black;">\\(3\\)</td><td style="border: 1px solid black;">\\(3,75\\)</td>
        </tr>
        <tr>
            <td style="border: 1px solid black;">\\(y\\)</td><td style="border: 1px solid black;">\\(2,5\\)</td><td style="border: 1px solid black;">\\(1,2\\)</td><td style="border: 1px solid black;">\\(1,12\\)</td><td style="border: 1px solid black;">\\(2,25\\)</td><td style="border: 1px solid black;">\\(4,48\\)</td>
        </tr>
    </tbody>
</table>

<h4>Алгоритм интерполяции полиномом Лагранжа с анализом производной</h4>
<p>Добавляем входные данные.</p>
<p>Шаг 1: Построение интерполяционного полинома Лагранжа</p>
<pre><code class="language-julia">
function lagrange_polynom(x_nodes::Vector{T}, y_nodes::Vector{T}) where T
    n = length(x_nodes)
    
    # Начинаем с нулевого полинома
    P = Polynomial(T[0])
    
    for i in 1:n
        # Базисный полином Лагранжа Lᵢ(x)
        Lᵢ = Polynomial(T[1])
        
        for j in 1:n
            if j != i
                # Lᵢ(x) = Πⱼ≠ᵢ (x - xⱼ)/(xᵢ - xⱼ)
                denominator = x_nodes[i] - x_nodes[j]
                Lᵢ *= Polynomial(T[-x_nodes[j]/denominator, 1/denominator])
            end
        end
        
        # P(x) += yᵢ·Lᵢ(x)
        P += y_nodes[i] * Lᵢ
    end
    
    return P
end
</code></pre>

<p>Шаг 2: Интерполяция в точках xᵢ + h</p>
<pre><code class="language-julia">
# Построение полинома
P_lagrange = lagrange_polynom(x_dano, y_dano)

# Вычисление значений в точках интерполяции
y_interp = P_lagrange.(x_interp)

# Вывод результатов
println("Полином Лагранжа:")
println("P(x) = ", P_lagrange)

println("\nИнтерполяция в точках xᵢ + h:")
for i in 1:length(x_dano)
    println("x$i = $(x_dano[i]) → P($(x_interp[i])) = $(y_interp[i])")
end
</code></pre>

<p>Шаг 3: Визуализация интерполяции</p>
<pre><code class="language-julia">
function plot_interp(x_data, y_data, poly, x_interp)
    # Плотная сетка для построения кривой
    x_dense = range(minimum(x_data)-0.5, maximum(x_data)+0.5, length=200)
    y_dense = poly.(x_dense)
    
    # Значения в точках интерполяции
    y_interp_vals = poly.(x_interp)
    
    # Построение графика
    p = plot(x_dense, y_dense, label="P(x)", color=:blue, linewidth=2)
    scatter!(p, x_data, y_data, label="Данные", color=:red, markersize=8)
    scatter!(p, x_interp, y_interp_vals, label="xᵢ + h", color=:green, markersize=10)
    
    # Соединение соответствующих точек
    for i in 1:length(x_data)
        plot!(p, [x_data[i], x_interp[i]], [y_data[i], y_interp_vals[i]], 
              color=:gray, linestyle=:dash, label="")
    end
    
    return p
end
</code></pre>

<p>Шаг 4: Анализ производной</p>
<pre><code class="language-julia">
# Вычисление производной полинома
P_prime = derivative(P_lagrange)

# Анализ поведения функции в точках интерполяции
println("\nАнализ производной:")
for (i, x_val) in enumerate(x_interp)
    deriv = P_prime(x_val)
    behavior = if deriv > 0
        "возрастает"
    elseif deriv < 0
        "убывает"
    else
        "экстремум"
    end
    println("P'($(x_val)) = $(deriv) → функция $behavior")
end
</code></pre>

<p>Шаг 5: Проверка интерполяции в исходных точках</p>
<pre><code class="language-julia">
# Проверка, что полином точно проходит через исходные точки
y_check = P_lagrange.(x_dano)
residuals = y_dano - y_check

println("\nПроверка интерполяции:")
println("Среднее отклонение: $(mean(abs.(residuals)))")
</code></pre>

<p>Добавляем главную функцию.</p>
<p>Выводим результат.</p>

	
	<caption><h4>Пример 3.</h4></caption>
<p>Найти приближенное значение функции при данном значении аргумента \\( x = 1.3833 \\) с помощью интерполяционного полинома Лагранжа, если функция задана таблично в конечном числе точек.</p>
<table>
    <tbody>
        <tr>
            <td style="border: 1px solid black;">\\(x\\)</td><td style="border: 1px solid black;">\\(1,375\\)</td><td style="border: 1px solid black;">\\(1,38\\)</td><td style="border: 1px solid black;">\\(1,385\\)</td><td style="border: 1px solid black;">\\(1,39\\)</td><td style="border: 1px solid black;">\\(1,395\\)</td><td style="border: 1px solid black;">\\(1,4\\)</td>
        </tr>
        <tr>
            <td style="border: 1px solid black;">\\(y\\)</td><td style="border: 1px solid black;">\\(2,04192\\)</td><td style="border: 1px solid black;">\\(2,17744\\)</td><td style="border: 1px solid black;">\\(2,32016\\)</td><td style="border: 1px solid black;">\\(2,47069\\)</td><td style="border: 1px solid black;">\\(2,62968\\)</td><td style="border: 1px solid black;">\\(2,79788\\)</td>
        </tr>
    </tbody>
</table>
<p>Ответ: Результат = \\(2.271\\)</p>

<h4>Алгоритм интерполяции полиномом Лагранжа</h4>
<p>Добавляем входные данные.</p>
<p>Шаг 1: Интерполяция Лагранжа</p>
<pre><code class="language-julia">
function lagrange_interp(x_nodes, y_nodes, x_val)
    n = length(x_nodes)
    result = 0.0
    
    for i in 1:n
        # Базисный полином Лагранжа Lᵢ(x)
        term = y_nodes[i]
        for j in 1:n
            if j != i
                term *= (x_val - x_nodes[j]) / (x_nodes[i] - x_nodes[j])
            end
        end
        result += term  # L(x) = Σ yᵢ·Lᵢ(x)
    end
    
    return result
end
</code></pre>

<p>Шаг 2: Вычисление значения в целевой точке</p>
<pre><code class="language-julia">
# Интерполяция в заданной точке
y_target = lagrange_interp(x, y, x_target)
println("L($x_target) = $y_target")
</code></pre>

<p>Шаг 3: Построение полинома </p>
<pre><code class="language-julia">
# Используем встроенную функцию для получения полинома
P = fit(x, y, length(x)-1)  # полином степени n-1
println("Полином: $P")
</code></pre>

<p>Шаг 4: Визуализация</p>
<pre><code class="language-julia">
function plot_interpolation(x_nodes, y_nodes, x_target, y_target)
    # Создаем сетку для построения графика
    x_min, x_max = minimum(x_nodes), maximum(x_nodes)
    x_range = range(x_min-0.005, x_max+0.005, length=300)
    
    # Вычисляем значения полинома на сетке
    y_range = [lagrange_interp(x_nodes, y_nodes, xi) for xi in x_range]
    
    # Строим график
    p = plot(x_range, y_range, 
             label="Полином Лагранжа", 
             color=:blue, 
             linewidth=2)
    
    # Исходные точки
    scatter!(p, x_nodes, y_nodes, 
             label="Узлы интерполяции", 
             color=:red, 
             markersize=6)
    
    # Точка интерполяции
    scatter!(p, [x_target], [y_target], 
             label="Интерполированное значение", 
             color=:green, 
             markersize=8, 
             marker=:star)
    
    return p
end
</code></pre>
<p>Добавляем главную функцию.</p>
<p>Выводим результат.</p>       
`,
	"test": {
            "timeLimit": 600,
            "questions": [
      {
        "question": "Что такое интерполяция в контексте обработки экспериментальных данных?",
        "answers": [
          {
            "text": "Нахождение аналитической функции, которая принимает в узлах интерполяции заданные значения.",
            "correct": true
          },
          {
            "text": "Разновидность аппроксимации, при которой кривая функции проходит точно через имеющиеся точки данных.",
            "correct": true
          },
          {
            "text": "Сглаживание данных с помощью минимизации суммы квадратов отклонений от приближающей функции.",
            "correct": false
          }
        ],
        "type": "multiple"
      },
      {
        "question": "Какие из следующих утверждений верны относительно глобальной интерполяции?",
        "answers": [
          {
            "text": "При глобальной интерполяции строится единый интерполяционный полином по всем узлам.",
            "correct": true
          },
          {
            "text": "Глобальную интерполяцию обычно применяют для функций с большим количеством точек.",
            "correct": false
          },
          {
            "text": "Увеличение числа узлов в глобальной интерполяции приводит к повышению степени полинома.",
            "correct": true
          }
        ],
        "type": "multiple"
      },
      {
        "question": "Что такое сплайн-функция?",
        "answers": [
          {
            "text": "Функция, состоящая из нескольких полиномов, каждый из которых определен на своем частичном отрезке.",
            "correct": true
          },
          {
            "text": "Единый полином высокой степени, проходящий через все точки данных.",
            "correct": false
          },
          {
            "text": "Гладкая кусочно-полиномиальная функция, непрерывная вместе с несколькими производными на всем отрезке.",
            "correct": true
          }
        ],
        "type": "multiple"
      },
      {
        "question": "Какие из перечисленных свойств характеризуют кубический сплайн (сплайн третьей степени) дефекта 1?",
        "answers": [
          {
            "text": "Непрерывность самой функции и ее первой производной на всем отрезке.",
            "correct": true
          },
          {
            "text": "На каждом частичном отрезке функция совпадает с кубическим полиномом.",
            "correct": true
          },
          {
            "text": "Обладает минимальной интегральной кривизной среди всех интерполяционных функций.",
            "correct": true
          }
        ],
        "type": "multiple"
      },
      {
        "question": "В чем заключается основное отличие метода сплайн-интерполяции от интерполяции полиномом Лагранжа?",
        "answers": [
          {
            "text": "В сплайн-интерполяции используется несколько полиномов низкой степени вместо одного полинома высокой степени.",
            "correct": true
          },
          {
            "text": "Полином Лагранжа дает более гладкую функцию, чем сплайн.",
            "correct": false
          },
          {
            "text": "Сплайн-интерполяция лучше подходит для большого количества точек данных.",
            "correct": true
          }
        ],
        "type": "multiple"
      }
    ]
        }
    },
    topic07: {
            "title": "Численные методы решения задачи Коши для обыкновенных дифференциальных уравнений",
            "theory": `
	<h1><i>Численные методы решения задачи Коши для обыкновенных дифференциальных уравнений</i></h1>
	<h2><i>Одношаговые методы решения ОДУ</i></h2>\n
	<p><font color='#ff0000'>Обыкновенным дифференциальным уравнением (ОДУ) \\(n\\)-го порядка</font> называется уравнение, связывающее между собой значения независимой переменной 
\\(x\\), неизвестной функции \\(y=y(x)\\) и её производных (или дифференциалов):</p>\n
	<p>\\[F(x,y,y',y'',...,y^{(n)})=0\\]</p>\n<p>или</p>\n
	<p>\\[F\\left(x,y,\\frac{dy}{dx},\\frac{d^2y}{dx^2},...,\\frac{d^ny}{dx^n}\\right)=0\\tag{8.1}\\]</p>\n
	<p><font color='#ff0000'>Порядком уравнения</font> называется максимальный порядок \\(n\\) входящей в него производной (или дифференциала).</p>\n
	<p><font color='#ff0000'>Решением (интегралом) обыкновенного дифференциального уравнения \\(n\\)-го порядка</font> называется функция \\(y(x)\\), имеющая на некотором интервале 
\\((a,b)\\) производные до порядка \\(n\\) включительно и удовлетворяющая этому уравнению.</p>\n
	<p>Любое дифференциальное уравнение имеет бесконечное множество решений. Процедура нахождения решений дифференциального уравнения называется <font color='#ff0000'>интегрированием
 уравнения</font>.</p>\n
	<p>Если для искомой функции \\(y\\) удалось получить формулу, которая дает все решения, это означает, что найдено его <font color='#ff0000'>общее решение</font> или 
<font color='#ff0000'>общий интеграл</font>.</p>\n
	<p>Общее решение уравнения (8.1) содержит \\(n\\) произвольных постоянных \\(C_1,C_2,...,C_n\\) и имеет вид:</p>\n
	<p>\\[y=y(x,C_1,C_2,...,C_n)\\tag{8.2}\\]</p>\n
	<p>Каждое конкретное решение, т.е. каждая конкретная функция, которая удовлетворяет данному дифференциальному уравнению и не зависит от произвольных постоянных, называется 
<font color='#ff0000'>частным решением</font>. Чтобы получить частные решения (интегралы) из общих, надо постоянным \\(C_1,C_2,...,C_n\\) задать конкретные числовые значения.</p>\n
	<p>График частного решения называется <font color='#ff0000'>интегральной кривой</font>. Общее решение уравнения (8.1) представляет собой семейство интегральных кривых, полученных
 при заданных значениях \\(C_1,C_2,...,C_n\\).</p>\n
	<p>Нередко на решение, которое требуется найти, накладывают дополнительные условия. Особый интерес представляют такие условия, которые гарантируют единственное решение уравнения. 
В зависимости от вида дополнительных условий в дифференциальных уравнениях различают:</p>\n
		<ol>\n    <li><font color='#ff0000'>задачу Коши</font> — в случае, если все дополнительные условия заданы в одной (чаще начальной) точке интервала;</li>\n    
		          <li><font color='#ff0000'>краевую задачу</font> — в случае, когда дополнительные условия заданы на границах интервала.</li>\n</ol>\n
	<p><font color='#ff0000'>Задача Коши</font> заключается в нахождении частного решения для уравнения (8.1), удовлетворяющего начальным условиям:</p>\n
	<p>\\[y(x_0)=y_0,\\;y'(x_0)=y'_0,\\;...\\;,\\;y^{(n-1)}(x_0)=y^{(n-1)}_0\\tag{8.3}\\]</p>\n
	<p>где \\(x_0,y_0,y'_0,...,y^{(n-1)}_0\\) — заданные числа.</p>\n
	<p>Геометрически задача Коши состоит в том, чтобы из всего множества интегральных кривых, представляющих собой общее решение, выделить ту интегральную кривую, которая проходит 
через точку с координатами \\((x_0;y_0)\\).</p>\n
	<p><font color='#ff0000'>Задача Коши для системы обыкновенных дифференциальных уравнений</font>:</p>\n
	<p>\\[\\begin{cases} y'_1=f_1(x,y_1,y_2,...,y_n) \\\\ y'_2=f_2(x,y_1,y_2,...,y_n) \\\\ ............ \\\\ y'_n=f_n(x,y_1,y_2,...,y_n) \\end{cases}\\tag{8.4}\\]</p>\n
	<p>заключается в нахождении функций \\(y_1,y_2,...,y_n\\), удовлетворяющих этой системе и начальным условиям:</p>\n
	<p>\\[y_1(x_0)=y_{10},\\;y_2(x_0)=y_{20},\\;...\\;,\\;y_n(x_0)=y_{n0}\\tag{8.5}\\]</p>\n
	<p>Дифференциальные уравнения высших порядков решаются сведением к системе уравнений первого порядка путем замены переменных \\(y_1=y',y_2=y'',...,y_{n-1}=y^{(n-1)}\\), что дает следующую систему:</p>\n
	<p>\\[\\begin{cases} y'=y_1 \\\\ y'_1=y_2 \\\\ ...... \\\\ y'_{n-1}=f(x,y_1,y_2,...,y_{n-1}) \\end{cases}\\]</p>\n
	<p>Задача Коши для практических и инженерных расчетов может быть решена только приближенными методами, которые делятся на две группы:</p>\n
		<ol>\n    <li><font color='#ff0000'>Аналитические</font>, позволяющие получить решение в виде аналитического выражения;</li>\n    
		<li><font color='#ff0000'>Численные</font>, в результате применения которых получается приближенное решение в виде таблицы значений искомой функции \\(y_0,y_1,...,y_n\\).</li>\n</ol>\n
	<p>Существуют два класса численных методов:</p>\n	
		<ol>\n    <li><font color='#ff0000'>Одношаговые методы</font>, в которых для нахождения каждой новой точки на кривой \\(y=y(x)\\) требуется информация лишь об одном 
предыдущем шаге (методы Эйлера, метод Рунге-Кутты);</li>\n    
		<li><font color='#ff0000'>Многошаговые методы (методы прогноза и коррекции)</font>, в которых для нахождения каждой точки кривой \\(y=y(x)\\) требуется информация более 
чем об одной из предыдущих точек (метод Адамса, метод Гира).</li>\n</ol>\n
	<p>Многошаговыми методами нельзя начать решать задачу Коши, это всегда делают одношаговыми методами.</p>\n\n
	
	<h2><i>Модифицированный (усовершенствованный) метод Эйлера</i></h2>\n
	<p>Модифицированный метод Эйлера имеет <font color='#ff0000'>точность второго порядка</font>.</p>\n
	<p>Пусть дано дифференциальное уравнение первого порядка:</p>\n
	<p>\\[y'=f(x,y)\\tag{2.1}\\]</p>\n
	<p>и задано начальное условие \\(y(x_0)=y_0,\\;x=x_0\\), где \\(x_0,y_0\\) — заданные числа. Требуется найти решение \\(y(x)\\) уравнения (2.1) на отрезке \\([a,b]\\).</p>\n
	<p>Модификация метода состоит в том, чтобы более точно определить направление перехода из точки \\((x_i,y_i)\\) в точку \\((x_{i+1},y_{i+1})\\). Для этого проводятся 
<font color='#ff0000'>дополнительные промежуточные вычисления</font>, в результате которых определяются координаты промежуточной точки.</p>\n
	<p>Разделим отрезок \\([a,b]\\) на \\(n\\) равных частей точками \\(x_{i+1}=x_i+h,\\;(i=0,1,...,n-1)\\), где \\(h\\) — шаг интегрирования. Найдем вспомогательное значение искомой 
функции \\(y_{i+\\frac{1}{2}}\\) в промежуточной точке \\(x_{i+\\frac{1}{2}}=x_i+\\dfrac{h}{2}\\) при помощи формулы:</p>\n
	<p>\\[y_{i+\\frac{1}{2}}=y_i+\\frac{h}{2}y'_i\\]</p>\n<p>где \\(y'_i=f(x_i,y_i)\\).</p>\n
	<p>Затем вычислим значение \\(y'_{i+\\frac{1}{2}}=f(x_{i+\\frac{1}{2}},y_{i+\\frac{1}{2}})\\).</p>\n
	<p>В результате получим формулу:</p>\n<p>\\[y_{i+1}=y_i+h y'_{i+\\frac{1}{2}}\\tag{2.2}\\]</p>\n
	<p>Геометрически это означает, что сначала определяется направление интегральной кривой в исходной точке \\((x_i,y_i)\\) и во вспомогательной точке \\((x_{i+\\frac{1}{2}},y_{i+\\frac{1}{2}})\\), 
а в качестве окончательного направления берется среднее значение этих направлений.</p>\n
	<p><font color='#ff0000'>Абсолютная погрешность</font> модифицированного метода Эйлера вычисляется с помощью двойного пересчета по формуле:</p>\n
	<p>\\[R=\\frac{\\left|y_n^*-y_n\\right|}{3}\\tag{2.3}\\]</p>\n
	<p>где \\(y_n\\) — приближенное значение решения с шагом \\(h\\);</p>\n
	<p>\\(y_n^*\\) — приближенное значение решения с шагом \\(\\dfrac{h}{2}\\).</p>\n
	<p><font color='#ff9100'>Замечание.</font> Модифицированный метод Эйлера распространяется на системы дифференциальных уравнений и дифференциальные уравнения высших порядков при их 
приведении к системам первого порядка.</p>\n
	<p>Рассмотрим систему двух дифференциальных уравнений:</p>\n
	<p>\\[\\begin{cases} y'=f_1(x,y,p) \\\\ p'=f_2(x,y,p) \\end{cases}\\]</p>\n
	<p>с начальными условиями \\(y(x_0)=y_0,\\;p(x_0)=p_0\\).</p>\n
	<p>Приближенные значения \\(y(x_i)\\approx y_i,\\;p(x_i)\\approx p_i\\) вычисляются по формулам:</p>\n
	<p>\\[\\begin{cases} y_{i+1}=y_i+h f_1(x_{i+\\frac{1}{2}},y_{i+\\frac{1}{2}},p_{i+\\frac{1}{2}}) \\\\ p_{i+1}=p_i+h f_2(x_{i+\\frac{1}{2}},y_{i+\\frac{1}{2}},p_{i+\\frac{1}{2}}) \\end{cases}\\]</p>\n
	<p>\\[x_{i+\\frac{1}{2}}=x_i+\\frac{h}{2}\\]</p>\n
	<p>\\[y_{i+\\frac{1}{2}}=y_i+\\frac{h}{2}f_1(x_i,y_i,p_i)\\]</p>\n
	<p>\\[p_{i+\\frac{1}{2}}=p_i+\\frac{h}{2}f_2(x_i,y_i,p_i)\\]</p>\n\n


		<h3>Функции для методов Эйлера и его модифицированного варианта для ОДУ 1-го порядка на Julia:</h3>
		<div class="code-container">
       		 <div class="code-header">
            		Метод Эйлера и модифицированный метод Эйлера 
           		 <span class="language-label">JULIA</span>
        	 </div>
       		 <pre><code class="language-julia"># Метод Эйлера
function euler_method(f, a, b, h, y0)
    x = range(a, stop=b, step=h)
    n = length(x)
    y = zeros(n)
    y[1] = y0
    
    for i in 1:n-1
        y[i+1] = y[i] + h * f(x[i], y[i])
    end
    
    return collect(x), y
end


# Модифицированный метод Эйлера 
function modified_euler(f, a, b, h, y0)
    x = range(a, stop=b, step=h) |> collect
    n = length(x)
    y = zeros(n)
    y[1] = y0
    
    x_half = x[1:end-1] .+ h/2
    y_half = zeros(n-1)
    
    for i in 1:n-1
        # Полушаг
        y_half[i] = y[i] + (h/2) * f(x[i], y[i])
        # Полный шаг
        y[i+1] = y[i] + h * f(x_half[i], y_half[i])
    end
    
    return x, x_half, y, y_half
end

</code></pre>
	        </div>


	<h1><i>Методы Рунге-Кутты</i></h1>\n
	<p>Наиболее популярными среди одношаговых методов являются методы Рунге-Кутты. Эти методы были разработаны около 1900 года немецкими математиками Карлом Рунге и Мартином Куттой.</p>\n
	<p>Методы Эйлера, Эйлера-Коши и усовершенствованный метод Эйлера можно рассматривать как простейших представителей этого класса методов.</p>\n\n

	<h2><i>Метод Рунге-Кутты третьего порядка точности</i></h2>\n
	<p>Пусть дано дифференциальное уравнение первого порядка:</p>\n
	<p>\\[y'=f(x,y)\\tag{1.1}\\]</p>\n
	<p>Требуется найти решение \\(y=y(x)\\) уравнения (1.1), удовлетворяющее начальным условиям \\(y(x_0)=y_0\\), где \\(x_0,y_0\\) — заданные числа.</p>\n
	<p>Для вывода формул метода Рунге-Кутты третьего порядка используем метод разложения в ряд Тейлора.</p>\n
	<p>Пусть \\(y_i\\) — приближенное значение решения уравнения в точке \\(x_i\\). Значение \\(y_{i+1}\\) в точке \\(x_{i+1}=x_i+h\\), где \\(h\\) — шаг интегрирования (\\(h=(b-a)/n\\)), будет равно:</p>\n
	<p>\\[y_{i+1}=y_i+\\Delta y_i\\tag{1.2}\\]</p>\n<p>Для определения \\(\\Delta y_i\\) разложим функцию \\(y(x)\\) в ряд Тейлора в окрестности точки \\(x\\):</p>\n
	<p>\\[\\Delta y=y(x+h)-y(x)=h y'(x)+\\frac{h^2}{2!}y''(x)+\\frac{h^3}{3!}y'''(x)+...\\]</p>\n
	<p>Производные \\(y'(x),y''(x),y'''(x)\\) можно найти последовательным дифференцированием уравнения (1.1).</p>\n
	<p>Рассматривая первые четыре элемента ряда Тейлора, значение \\(\\Delta y_i\\) определится по формуле:</p>\n
	<p>\\[\\Delta y_i=\\frac{1}{6}(k_1+4k_2+k_3)+O(h^4)\\]</p>\n
	<p>где \\(O(h^4)\\) — бесконечно малая величина, которая означает, что метод Рунге-Кутты согласуется с разложением в ряд Тейлора вплоть до элементов степени \\(h^4\\).</p>\n
	<p>\\[k_1=h f(x_i,y_i)\\]</p>\n
	<p>\\[k_2=h f\\left(x_i+\\frac{h}{2},\\;y_i+\\frac{k_1}{2}\\right)\\]</p>\n
	<p>\\[k_3=h f\\left(x_i+h,\\;y_i-k_1+2k_2\\right)\\]</p>\n
	<p>Таким образом, метод Рунге-Кутты третьего порядка сводится к последовательному вычислению значений:</p>\n
	<p>\\[k_{1i}=h f(x_i,y_i)\\]</p>\n
	<p>\\[k_{2i}=h f\\left(x_i+\\frac{h}{2},\\;y_i+\\frac{k_{1i}}{2}\\right)\\tag{1.3}\\]</p>\n
	<p>\\[k_{3i}=h f\\left(x_i+h,\\;y_i-k_{1i}+2k_{2i}\\right)\\]</p>\n<p>\\[\\Delta y_i=\\frac{1}{6}(k_{1i}+4k_{2i}+k_{3i})\\tag{1.4}\\]</p>\n
	<p>\\[y_{i+1}=y_i+\\Delta y_i\\tag{1.5}\\]</p>\n
	<p>\\((i=0,1,...,n)\\)</p>\n
	<p><font color='#ff0000'>Абсолютная погрешность метода Рунге-Кутты</font> третьего порядка точности вычисляется по формуле:</p>\n
	<p>\\[R=\\left|\\frac{y_n^*-y_n}{7}\\right|\\]</p>\n<p>где \\(y_n\\) — приближенные значения, вычисленные с шагом \\(h\\) в точке \\(x_n\\);</p>\n
	<p>\\(y_n^*\\) — приближенные значения, вычисленные с шагом \\(\\dfrac{h}{2}\\) в точке \\(x_n\\).</p>\n\n

	<h3>Функция для метода Рунге-Кутты третьего порядка точности на Julia:</h3>
		<div class="code-container">
       		 <div class="code-header">
            		Метод Рунге-Кутты третьего порядка
           		 <span class="language-label">JULIA</span>
        	 </div>
       		 <pre><code class="language-julia"># Метод Рунге-Кутты 3-го порядка
function runge_kutta_3(f, a, b, h, y0)
    x = range(a, stop=b, step=h) |> collect
    n = length(x)
    y = zeros(n)
    delta_y = zeros(n)
    y[1] = y0
    
    for i in 1:n-1
        # Коэффициенты 
        k1 = h * f(x[i], y[i])
        k2 = h * f(x[i] + h/2, y[i] + k1/2)
        k3 = h * f(x[i] + h, y[i] - k1 + 2*k2)
        
        delta_y[i] = (k1 + 4*k2 + k3) / 6
        y[i+1] = y[i] + delta_y[i]
    end
    
    return x, y, delta_y
end

</code></pre>
	        </div>

	<h2><i>Метод Рунге-Кутты четвертого порядка точности</i></h2>\n
	<p>Метод Рунге-Кутты четвертого порядка является одним из самых широко используемых методов для решения задачи Коши. Его часто называют просто «методом Рунге-Кутты» без указаний на тип и порядок.</p>\n
	<p>Пусть дано дифференциальное уравнение первого порядка с начальными условиями:</p>\n
	<p>\\[y'=f(x,y),\\;\\;y(x_0)=y_0\\]</p>\n<p>Этот метод Рунге-Кутты записывается формулами:</p>\n
	<p>\\[k_{1i}=h f(x_i,y_i)\\]</p>\n
	<p>\\[k_{2i}=h f\\left(x_i+\\frac{h}{2},\\;y_i+\\frac{k_{1i}}{2}\\right)\\]</p>\n
	<p>\\[k_{3i}=h f\\left(x_i+\\frac{h}{2},\\;y_i+\\frac{k_{2i}}{2}\\right)\\]</p>\n
	<p>\\[k_{4i}=h f\\left(x_i+h,\\;y_i+k_{3i}\\right)\\]</p>\n
	<p>\\[\\Delta y_i=\\frac{1}{6}(k_{1i}+2k_{2i}+2k_{3i}+k_{4i})\\]</p>\n
	<p>\\[y_{i+1}=y_i+\\Delta y_i,\\;\\;x_{i+1}=x_i+h\\]</p>\n
	<p>\\((i=0,1,...,n)\\)</p>\n
	<p><font color='#ff0000'>Абсолютная погрешность</font> находится по формуле:</p>\n
	<p>\\[R=\\left|\\frac{y_n^*-y_n}{15}\\right|\\]</p>\n
	<p>где \\(y_n\\) — приближенные значения, вычисленные с шагом \\(h\\) в точке \\(x_n\\);</p>\n
	<p>\\(y_n^*\\) — приближенные значения, вычисленные с шагом \\(\\dfrac{h}{2}\\) в точке \\(x_n\\).</p>\n
	<p><font color='#ff9100'><font size=\"4\">Замечание 1.</font></font> Метод Рунге-Кутты распространяется на дифференциальные уравнения 2-го порядка.</p>\n
	<p>Рассмотрим дифференциальное уравнение 2-го порядка с начальными условиями:</p>\n
	<p>\\[y''=f(x,y,y'),\\;\\;y(x_0)=y_0,\\;\\;y'(x_0)=y'_0\\]</p>\n
	<p>Приближенные значения \\(y_i\\approx y_i(x_i),\\;y'_i\\approx y'_i(x_i)\\) вычисляются по формулам:</p>\n
	<p>\\[k_{1i}=h f(x_i,y_i,y'_i)\\]</p>\n<p>\\[k_{2i}=h f\\left(x_i+\\frac{h}{2},\\;y_i+\\frac{h}{2}y'_i,\\;y'_i+\\frac{k_{1i}}{2}\\right)\\]</p>\n
	<p>\\[k_{3i}=h f\\left(x_i+\\frac{h}{2},\\;y_i+\\frac{h}{2}y'_i+\\frac{h}{4}k_{1i},\\;y'_i+\\frac{k_{2i}}{2}\\right)\\]</p>\n
	<p>\\[k_{4i}=h f\\left(x_i+h,\\;y_i+h y'_i+\\frac{h}{2}k_{2i},\\;y'_i+k_{3i}\\right)\\]</p>\n
	<p>\\[\\Delta y'_i=\\frac{1}{6}(k_{1i}+2k_{2i}+2k_{3i}+k_{4i})\\]</p>\n
	<p>\\[y'_{i+1}=y'_i+\\Delta y'_i\\]</p>\n
	<p>\\[y_{i+1}=y_i+h y'_i+\\frac{h}{6}(k_{1i}+k_{2i}+k_{3i})\\]</p>\n
	<p>\\[x_{i+1}=x_i+h\\]</p>\n<p>\\((i=0,1,...,n)\\)</p>\n
	<p><font color='#ff9100'><font size=\"4\">Замечание 2.</font></font> Если в условии задачи не задан шаг интегрирования, и требуется найти решение дифференциального уравнения с 
заданной точностью, то \\(n\\) — число точек деления выбирается так, чтобы шаг \\(h=\\dfrac{b-a}{n}\\) удовлетворял условию:</p>\n
	<p>\\[h^4&lt;\\varepsilon\\]</p>


		<h3>Функция для метода Рунге-Кутты четвертого порядка точности на Julia:</h3>
		<div class="code-container">
       		 <div class="code-header">
            		Метод Рунге-Кутты четвертого порядка
           		 <span class="language-label">JULIA</span>
        	 </div>
       		 <pre><code class="language-julia"># Метод Рунге-Кутты 4-го порядка
function runge_kutta_4(a, b, h, y0)
    n = Int(round((b - a) / h)) + 1
    x = zeros(n)
    y = zeros(n)
    delta_y = zeros(n)
    
    x[1] = a
    y[1] = y0
    
    for i in 1:n-1
        x[i+1] = x[i] + h
        k1 = h * f(x[i], y[i])
        k2 = h * f(x[i] + h/2, y[i] + k1/2)
        k3 = h * f(x[i] + h/2, y[i] + k2/2)
        k4 = h * f(x[i] + h, y[i] + k3)
        delta_y[i] = (k1 + 2*k2 + 2*k3 + k4) / 6
        y[i+1] = y[i] + delta_y[i]
    end
    
    return x, y, delta_y
end
</code></pre>
	        </div>
  `,
	"practica": `
	<h1><i>Численные методы решения задачи Коши для обыкновенных дифференциальных уравнений</i></h1>
        <h2><i>Практическая работа №7</i></h2>

	<caption><h4>Пример 1.</h4></caption>
<p>Численно решить дифференциальное уравнение \\[ y' = y - \\dfrac{2x}{y}, \\quad y(0) = 1, \\] на отрезке \\([0; 1]\\) с шагом \\(h = 0.2\\) методом Эйлера. 
Найти точное решение \\(y = y(x)\\) и сравнить значения точного и приближенного решений в точке \\(x = 1\\). Вычислить абсолютную и относительную погрешности в этой точке. 
Все вычисления вести с четырьмя десятичными знаками.</p>

<h4>Алгоритм численного решения дифференциальных уравнений методом Эйлера</h4>

<p>Шаг 1: Определение дифференциального уравнения</p>
<pre><code class="language-julia">
using Printf, LinearAlgebra, Statistics

# Дифференциальное уравнение
f(x, y) = y - 2x / y

# Точное решение (для сравнения)
exact_solution(x) = sqrt(2x + 1)
</code></pre>

<p>Шаг 2: Метод Эйлера</p>
<pre><code class="language-julia">
function euler_method(f, a, b, h, y0)
    # Сетка по x
    x = range(a, stop=b, step=h)
    n = length(x)
    
    # Инициализация массива y
    y = zeros(n)
    y[1] = y0  # начальное условие
    
    # Итерационный процесс
    for i in 1:n-1
        y[i+1] = y[i] + h * f(x[i], y[i])
    end
    
    return collect(x), y
end
</code></pre>

<p>Шаг 3: Задание параметров решения</p>
<pre><code class="language-julia">
# Параметры
A = 0.0      # начальная точка
B = 1.0      # конечная точка
H = 0.2      # шаг
Y0 = 1.0     # начальное условие y(0) = 1
</code></pre>

<p>Шаг 4: Численное решение</p>
<pre><code class="language-julia">
# Применение метода Эйлера
x_points, y_approx = euler_method(f, A, B, H, Y0)

# Точное решение в тех же точках
y_exact = exact_solution.(x_points)
</code></pre>

<p>Шаг 5: Анализ погрешности</p>
<pre><code class="language-julia">
# Абсолютные погрешности
abs_errors = abs.(y_approx .- y_exact)

# Относительные погрешности
rel_errors = abs_errors ./ y_exact
</code></pre>
<p>Добавляем главную функцию.</p>
<p>Выводим результат.</p>

	<caption><h4>Пример 2.</h4></caption>
<p>Численно решить дифференциальное уравнение \\[ y'' + 4y = \\cos 3x, \\quad y(0) = 0.8, \\quad y'(0) = 2, \\] на отрезке \\([0; 1]\\) с шагом \\(h = 0.1\\) методом Эйлера. 
Найти абсолютную и относительную погрешности в точке \\(x = 1\\), если известно точное решение: \\[ y_{\\text{точн}}(x) = \\cos 2x + \\sin 2x - 0.2 \\cos 3x. \\]</p>
	
<h4>Алгоритм численного решения ОДУ 2-го порядка методом Эйлера</h4>

<p>Шаг 1: Приведение к системе ОДУ 1-го порядка</p>
<pre><code class="language-julia">
using Printf, LinearAlgebra, QuadGK

# Исходное уравнение: y'' + 4y = cos(3x)
# Преобразуем в систему:
# u₁ = y, u₂ = y'
# u₁' = u₂
# u₂' = -4u₁ + cos(3x)

function ode_system!(du, u, p, x)
    y, yprime = u
    du[1] = yprime       # y' = y'
    du[2] = -4y + cos(3x)  # y'' = -4y + cos(3x)
    return nothing
end
</code></pre>

<p>Шаг 2: Метод Эйлера для систем</p>
<pre><code class="language-julia">
function euler_system(f!, a, b, h, u0)
    # Сетка по x
    x = a:h:b
    n = length(x)
    m = length(u0)  # размерность системы
    
    # Матрица решений
    U = zeros(n, m)
    U[1, :] = u0  # начальные условия
    
    du = zeros(m)
    for i in 1:n-1
        # Вычисление производных в текущей точке
        f!(du, U[i, :], nothing, x[i])
        
        # Формула Эйлера
        U[i+1, :] = U[i, :] + h * du
    end
    
    return x, U
end
</code></pre>

<p>Шаг 3: Точное решение (для сравнения)</p>
<pre><code class="language-julia">
# Точное решение y(x)
function exact_solution(x)
    # y'(t) = -2sin(2t) + 2cos(2t) + 0.6sin(3t)
    integr(t) = -2sin(2t) + 2cos(2t) + 0.6sin(3t)
    # y(x) = y(0) + ∫₀ˣ y'(t)dt
    return 0.8 + quadgk(integr, 0, x)[1]
end

# Точная производная y'(x)
function exact_proizv(x)
    return -2sin(2x) + 2cos(2x) + 0.6sin(3x)
end
</code></pre>

<p>Шаг 4: Задание параметров</p>
<pre><code class="language-julia">
# Параметры решения
a = 0.0      # начальная точка
b = 1.0      # конечная точка
h = 0.1      # шаг

# Начальные условия: y(0) = 0.8, y'(0) = 2.0
u0 = [0.8, 2.0]
</code></pre>

<p>Шаг 5: Численное решение</p>
<pre><code class="language-julia">
# Решение методом Эйлера
x_points, U = euler_system(ode_system!, a, b, h, u0)

# Извлечение компонент решения
y_approx = U[:, 1]  # приближенное y(x)
p_approx = U[:, 2]  # приближенное y'(x)

# Точные значения
y_exact = [exact_solution(xi) for xi in x_points]
p_exact = exact_proizv.(x_points)
</code></pre>

<p>Шаг 6: Анализ погрешности</p>
<pre><code class="language-julia">
# Погрешности для y(x)
abs_errors_y = abs.(y_approx .- y_exact)
rel_errors_y = abs_errors_y ./ abs.(y_exact)

# Погрешности для y'(x)
abs_errors_p = abs.(p_approx .- p_exact)
</code></pre>
<p>Добавляем главную функцию.</p>
<p>Выводим результат.</p>

	<caption><h4>Пример 3.</h4></caption>
<p>Численно решить дифференциальное уравнение \\[ y' = y - \\dfrac{2x}{y}, \\quad y(0) = 1, \\] на отрезке \\([0; 1]\\) с шагом \\(h = 0.2\\) модифицированным методом Эйлера. 
Найти точное решение \\(y = y(x)\\) и сравнить значения точного и приближенного решений в точке \\(x = 1\\). Вычислить абсолютную и относительную погрешности в этой точке. 
Все вычисления вести с четырьмя десятичными знаками.</p>

<h4>Алгоритм численного решения ОДУ модифицированным методом Эйлера</h4>
<p>Определяем дифференциальное уравнение и точное решение</p>
<p>Шаг 1: Модифицированный метод Эйлера</p>
<pre><code class="language-julia">
function modified_euler(f, a, b, h, y0)
    # Сетка по x
    x = range(a, stop=b, step=h) |> collect
    n = length(x)
    
    # Массивы для решения
    y = zeros(n)
    y[1] = y0  # начальное условие
    
    # Промежуточные точки (полушаги)
    x_half = x[1:end-1] .+ h/2
    y_half = zeros(n-1)
    
    for i in 1:n-1
        # 1. Полушаг: предсказание в середине интервала
        y_half[i] = y[i] + (h/2) * f(x[i], y[i])
        
        # 2. Полный шаг: коррекция с использованием полушага
        y[i+1] = y[i] + h * f(x_half[i], y_half[i])
    end
    
    return x, x_half, y, y_half
end
</code></pre>

<p>Шаг 2: Геометрическая интерпретация метода</p>
<p>Метод состоит из двух этапов:</p>
<ol>
    <li>Вычисление наклонов в начале интервала</li>
    <li>Использование усредненного наклона для шага</li>
</ol>

<p>Шаг 3: Задание параметров решения</p>
<pre><code class="language-julia">
# Параметры решения
a = 0.0      # начальная точка
b = 1.0      # конечная точка
h = 0.2      # шаг
y0 = 1.0     # начальное условие y(0) = 1
</code></pre>

<p>Шаг 4: Численное решение</p>
<pre><code class="language-julia">
# Применение модифицированного метода Эйлера
x_points, x_half, y_approx, y_half = modified_euler(f, a, b, h, y0)

# Точное решение для сравнения
y_exact = exact_solution.(x_points)
</code></pre>

<p>Шаг 6: Анализ погрешности</p>
<pre><code class="language-julia">
# Абсолютные погрешности
abs_errors = abs.(y_approx .- y_exact)

# Относительные погрешности
rel_errors = abs_errors ./ y_exact
</code></pre>
<p>Добавляем главную функцию.</p>
<p>Выводим результат.</p>

	<caption><h4>Пример 4.</h4></caption>
<p>Дано дифференциальное уравнение \\[ y'' + 4y = \\cos 3x, \\quad y(0) = 0.8, \\quad y'(0) = 2. \\] Численно найти решение этого уравнения на отрезке \\([0; 1]\\) с шагом \\(h = 0.1\\) 
модифицированным методом Эйлера. Найти абсолютную и относительную погрешности в точке \\(x = 1\\), если известно точное решение: \\[ y_{\\text{точн}}(x) = \\cos 2x + \\sin 2x - 0.2 \\cos 3x. \\]</p>
	
<h4>Алгоритм решения системы ОДУ модифицированным методом Эйлера</h4>

<p>Шаг 1: Приведение ОДУ 2-го порядка к системе 1-го порядка</p>
<pre><code class="language-julia">
using Printf, LinearAlgebra, Statistics

# Исходное уравнение: y'' + 4y = cos(3x)
# Преобразование в систему:
# u₁ = y, u₂ = y'
# u₁' = u₂
# u₂' = -4u₁ + cos(3x)

function ode_system(du, u, p, x)
    y, yprime = u
    du[1] = yprime                # y' = y'
    du[2] = -4y + cos(3x)         # y'' = -4y + cos(3x)
    return nothing
end
</code></pre>

<p>Шаг 2: Точные решения (для сравнения)</p>
<pre><code class="language-julia">
# Точное решение y(x)
exact_solution(x) = cos(2x) + sin(2x) - 0.2cos(3x)

# Точная производная y'(x)
exact_d_s(x) = -2sin(2x) + 2cos(2x) + 0.6sin(3x)
</code></pre>

<p>Шаг 3: Модифицированный метод Эйлера для систем</p>
<pre><code class="language-julia">
function modified_euler_method(f!, a, b, h, u0)
    # Сетка по x
    x = range(a, stop=b, step=h) |> collect
    n = length(x)
    m = length(u0)  # размерность системы
    
    # Основные решения
    U = zeros(n, m)
    U[1, :] = u0  # начальные условия
    
    # Промежуточные решения (полушаги)
    U_half = zeros(n-1, m)
    x_half = x[1:end-1] .+ h/2
    
    # Вспомогательные массивы для производных
    du = zeros(m)
    du_half = zeros(m)
    
    for i in 1:n-1
        # 1. Вычисление производной в начале интервала
        f!(du, U[i, :], nothing, x[i])
        
        # 2. Полушаг: прогноз в середине интервала
        U_half[i, :] = U[i, :] + (h/2) * du
        
        # 3. Вычисление производной в середине интервала
        f!(du_half, U_half[i, :], nothing, x_half[i])
        
        # 4. Полный шаг с использованием усредненного наклона
        U[i+1, :] = U[i, :] + h * du_half
    end
    
    return x, x_half, U, U_half
end
</code></pre>

<p>Шаг 4: Задание параметров решения</p>
<pre><code class="language-julia">
# Параметры решения
a = 0.0      # начальная точка
b = 1.0      # конечная точка
h = 0.1      # шаг

# Начальные условия: y(0) = 0.8, y'(0) = 2.0
u0 = [0.8, 2.0]
</code></pre>

<p>Шаг 5: Численное решение</p>
<pre><code class="language-julia">
# Применение метода
x_points, x_half, U, U_half = modified_euler_method(ode_system, a, b, h, u0)

# Извлечение компонент решения
y_approx = U[:, 1]    # приближенное y(x)
p_approx = U[:, 2]    # приближенное y'(x)
y_half = U_half[:, 1] # промежуточные значения y
</code></pre>

<p>Шаг 6: Сравнение с точным решением</p>
<pre><code class="language-julia">
# Точные значения
y_exact = exact_solution.(x_points)
p_exact = exact_d_s.(x_points)

# Погрешности
abs_errors_y = abs.(y_approx .- y_exact)
rel_errors_y = abs_errors_y ./ abs.(y_exact)
</code></pre>
<p>Добавляем главную функцию.</p>
<p>Выводим результат.</p>

	<caption><h4>Пример 5.</h4></caption>
<p>Пусть дано дифференциальное уравнение \\[ y' = y - x, \\] с начальным условием \\( y(0) = 1.5 \\). Найти приближенное решение уравнения на отрезке \\([0; 1.5]\\) с шагом \\(h = 0.25\\)
 методом Рунге–Кутты 3-го порядка. Точным решением уравнения является функция: \\[ y_{\\text{точн}}(x) = 0.5 e^x + x + 1. \\] Определить абсолютную и относительную погрешности в точке 
\\(x = 1.5\\).</p>

<h4>Алгоритм решения ОДУ методом Рунге-Кутты 3-го порядка</h4>
<p>Определяем дифференциальное уравнение и точное решение</p>
<p>Шаг 1: Реализация метода</p>
<pre><code class="language-julia">
function runge_kutta_3(f, a, b, h, y0)
    # Сетка по x
    x = range(a, stop=b, step=h) |> collect
    n = length(x)
    
    # Массивы для решения
    y = zeros(n)
    delta_y = zeros(n)  # приращения Δy на каждом шаге
    y[1] = y0  # начальное условие
    
    for i in 1:n-1
        # Вычисление коэффициентов Рунге-Кутты
        k1 = h * f(x[i], y[i])
        k2 = h * f(x[i] + h/2, y[i] + k1/2)
        k3 = h * f(x[i] + h, y[i] - k1 + 2*k2)
        
        # Приращение и следующее значение
        delta_y[i] = (k1 + 4*k2 + k3) / 6
        y[i+1] = y[i] + delta_y[i]
    end
    
    return x, y, delta_y
end
</code></pre>

<p>Шаг 2: Геометрическая интерпретация</p>
<p>Метод использует три точки для оценки наклона:</p>
<ol>
    <li>k₁ - наклон в начале интервала</li>
    <li>k₂ - наклон в середине интервала</li>
    <li>k₃ - наклон в конце интервала (с коррекцией)</li>
</ol>

<p>Шаг 3: Задание параметров решения</p>
<pre><code class="language-julia">
# Параметры решения
a = 0.0      # начальная точка
b = 1.5      # конечная точка
h = 0.25     # шаг
y0 = 1.5     # начальное условие y(0) = 1.5
</code></pre>

<p>Шаг 4: Численное решение</p>
<pre><code class="language-julia">
# Применение метода Рунге-Кутты
x_points, y_approx, delta_y = runge_kutta_3(f, a, b, h, y0)

# Точное решение для сравнения
y_exact = exact_solution.(x_points)
</code></pre>

<p>Шаг 5: Анализ погрешности</p>
<pre><code class="language-julia">
# Абсолютные погрешности
abs_errors = abs.(y_approx .- y_exact)

# Относительные погрешности
rel_errors = abs_errors ./ abs.(y_approx)
</code></pre>
<p>Добавляем главную функцию.</p>
<p>Выводим результат.</p>

	<caption><h4>Пример 6.</h4></caption>
<p Численно решить дифференциальное уравнение \\[ y' = y - x, \\quad y(0) = 1.5, \\] на отрезке \\([0; 1.5]\\) с шагом \\(h = 0.25\\) методом Эйлера и методом Рунге–Кутты 4-го порядка. 
Точным решением уравнения является функция: \\[ y_{\\text{точн}}(x) = e^x + x + 1. \\] Определить абсолютную и относительную погрешности в точке \\(x = 1.5\\) для обоих методов.</p>

<h4>Алгоритм решения ОДУ методом Рунге-Кутты 4-го порядка</h4>

<p>Определяем дифференциальное уравнение и точное решение</p>
<p>Шаг 1: Реализация метода</p>
<pre><code class="language-julia">
function runge_kutta_4(a, b, h, y0)
    # Количество шагов
    n = Int(round((b - a) / h)) + 1
    
    # Массивы для решения
    x = zeros(n)
    y = zeros(n)
    delta_y = zeros(n)  # приращения Δy
    
    # Начальные условия
    x[1] = a
    y[1] = y0
    
    for i in 1:n-1
        # Следующая точка по x
        x[i+1] = x[i] + h
        
        # Коэффициенты Рунге-Кутты
        k1 = h * f(x[i], y[i])
        k2 = h * f(x[i] + h/2, y[i] + k1/2)
        k3 = h * f(x[i] + h/2, y[i] + k2/2)
        k4 = h * f(x[i] + h, y[i] + k3)
        
        # Приращение и следующее значение
        delta_y[i] = (k1 + 2*k2 + 2*k3 + k4) / 6
        y[i+1] = y[i] + delta_y[i]
    end
    
    return x, y, delta_y
end
</code></pre>

<p>Шаг 2: Геометрическая интерпретация</p>
<p>Метод использует четыре точки для оценки наклона:</p>
<ol>
    <li>k₁ - наклон в начале интервала</li>
    <li>k₂ - наклон в середине интервала (используя k₁)</li>
    <li>k₃ - наклон в середине интервала (используя k₂)</li>
    <li>k₄ - наклон в конце интервала (используя k₃)</li>
</ol>

<p>Шаг 3: Анализ погрешности</p>
<pre><code class="language-julia">
function pogr(x, y_approx)
    n = length(x)
    y_exact = exact_solution.(x)
    abs_errors = abs.(y_approx .- y_exact)
    rel_errors = zeros(n)
    
    for i in 1:n
        if y_approx[i] != 0
            rel_errors[i] = abs_errors[i] / abs(y_approx[i])
        end
    end
    
    return y_exact, abs_errors, rel_errors
end
</code></pre>

<p>Шаг 4: Задание параметров решения</p>
<pre><code class="language-julia">
# Параметры решения
a = 0.0      # начальная точка
b = 1.5      # конечная точка
h = 0.25     # шаг
y0 = 1.5     # начальное условие y(0) = 1.5
</code></pre>
<p>Добавляем главную функцию.</p>
<p>Выводим результат.</p>    
`,
	"test": {
            "timeLimit": 600,
            "questions": [
      {
        "question": "Что из перечисленного относится к одношаговым методам решения задачи Коши?",
        "answers": [
          {
            "text": "Метод Эйлера.",
            "correct": true
          },
          {
            "text": "Метод Рунге-Кутты.",
            "correct": true
          },
          {
            "text": "Метод Адамса (многошаговый метод).",
            "correct": false
          }
        ],
        "type": "multiple"
      },
      {
        "question": "Какие особенности характеризуют модифицированный (усовершенствованный) метод Эйлера?",
        "answers": [
          {
            "text": "Имеет точность второго порядка.",
            "correct": true
          },
          {
            "text": "Использует промежуточные вычисления в точке \\(x_i + \\frac{h}{2}\\).",
            "correct": true
          },
          {
            "text": "Требует информации о двух предыдущих точках для расчета следующей.",
            "correct": false
          }
        ],
        "type": "multiple"
      },
      {
        "question": "Какой из методов Рунге-Кутты считается одним из наиболее популярных и часто используется без указания порядка?",
        "answers": [
          {
            "text": "Метод Рунге-Кутты второго порядка.",
            "correct": false
          },
          {
            "text": "Метод Рунге-Кутты четвертого порядка.",
            "correct": true
          },
          {
            "text": "Метод Рунге-Кутты третьего порядка.",
            "correct": false
          }
        ],
        "type": "single"
      },
      {
        "question": "Как вычисляется абсолютная погрешность в методе Рунге-Кутты четвертого порядка?",
        "answers": [
          {
            "text": "С помощью двойного пересчета: сравнения результатов с шагом \\(h\\) и \\(h/2\\).",
            "correct": true
          },
          {
            "text": "По формуле \\(R = \\frac{|y_n^* - y_n|}{15}\\), где \\(y_n\\) и \\(y_n^*\\) - значения с шагом \\(h\\) и \\(h/2\\).",
            "correct": true
          },
          {
            "text": "Путем сравнения с точным аналитическим решением уравнения.",
            "correct": false
          }
        ],
        "type": "multiple"
      },
      {
        "question": "Какое условие характеризует задачу Коши для дифференциального уравнения?",
        "answers": [
          {
            "text": "Все дополнительные условия заданы в одной (начальной) точке интервала.",
            "correct": true
          },
          {
            "text": "Дополнительные условия заданы на границах интервала (краевая задача).",
            "correct": false
          },
          {
            "text": "Требуется найти частное решение, удовлетворяющее начальным условиям.",
            "correct": true
          }
        ],
        "type": "multiple"
      }
    ]
        }
    },
topic08: {
            "title": "Численные дифференцирование функций",
            "theory": `
        <h1><i>Численное дифференирование функций</i></h1>\n
	<p>Численное дифференцирование применяется тогда, когда функцию трудно или невозможно продифференцировать аналитически. Например, необходимость в численном дифференцировании 
возникает в том случае, когда функция задана не формулой, а таблицей или алгоритм вычисления в произвольной точке.</p>\n
	<p>Кроме того, формулы численного дифференцирования широко используются при разработке вычислительных методов решения многих задач, например, при решении дифференицальных уравнений,
 поиске решений систем нелинейных уравнений, поиске точек экстремума функций и т.д. Основной подход при построении формул численного дифференцирования &mdash; это аппроксимация функции. 
Предположим, что в окрестности точки \\(x\\) функция \\(f(x)\\) аппроксимируется некоторой другой функцией \\(f_n(x)\\), причем \\(k\\)-ая производная \\(f_{n}^{(k)}(x)\\) легко вычисляется.
 Естественно в этом случае воспользоваться приближенной формулой \\[f^{(k)}(x)\\approx f_n^{(k)}(x)\\tag{1}\\]</p>\n
	<p>Приближение \\(f_n(x)\\) может быть построено любым рассмотренным нами ранее методом. Например, в виде интерполяционного полинома или сплайна. Далее мы реализуем этот подход в 
случае, когда аппроксимация функции осуществляется с помощью лагранжевой интерполяции.</p>\n

	<h3>Пример простейшего дифференцирования с использованием встроенных функций на Julia:</h3>
		<div class="code-container">
       		 <div class="code-header">
            		Дифференцирование
           		 <span class="language-label">JULIA</span>
        	 </div>
       		 <pre><code class="language-julia">using ForwardDiff

f(x) = x^2 + sin(x)
println("f'(3) = ", ForwardDiff.derivative(f, 3))
</code></pre>
	        </div>

	<h2><i>Простейшие формулы вычисления \\(f'(x)\\) и \\(f''(x)\\)</i></h2>\n
	<p>Пусть задана скалярная функция \\(f(x)\\) и мы хотим приближенно вычислить \\(f'(x)\\), используя при этом лишь значения функции \\(f(x)\\) в двух точках. По определению 
\\[f'(x)=\\lim_{h \\to 0} \\frac{f(x+h)-f(x)}{h}\\]</p>\n
	<p>Следовательно, разностное отношение \\[f_x(x)=\\lim_{h \\to 0} \\frac{f(x+h)-f(x)}{h}\\tag{2}\\]</p>\n
	<p>которое принято называть разностью вперед функции \\(f\\) в точке \\(x\\) (или просто <font color = '#ff0000'>разностью вперед</font>) при малом \\(h\\) позволяет приближенно 
вычислить \\(f'(x)\\). Сказанное остается справедливым и для разностного отношения (<font color = '#ff0000'>разности назад</font>) \\[f_\\bar{x}(x)=\\frac{f(x)-f(x-h)}{h}\\tag{3}\\]</p>\n
	<p>Эти отношения являются простейшими формулами численного дифференцирования. Пользуясь разложениями Тейлора \\[f(x\\pm h)=f(x)\\pm hf'(x)+\\frac{h^2}{2f''(\\xi_{\\pm} (x))}\\tag{4}\\]</p>\n
	<p>где \\(\\xi_{\\pm} (x)\\in [a,b]\\), получаем следующие представления для погрешности этих формул: \\[f'(x)-f_x(x)=-\\frac{h}{2}f''(\\xi_{+}(x))\\tag{5}\\] \\[f'(x)-f_\\bar{x}(x)=-\\frac{h}{2}f''(\\xi_{-}(x))\\tag{6}\\]</p>\n
	
	<h3>Пример вычисления правой и левой разности на Julia:</h3>
		<div class="code-container">
       		 <div class="code-header">
            		Правая и левая разности
           		 <span class="language-label">JULIA</span>
        	 </div>
       		 <pre><code class="language-julia">pr_r = (y[i+1] - y[i]) / h
l_r = (y[i] - y[i-1]) / h
</code></pre>
	        </div>

	<p>Введем обозначение \\[M_k=\\max\\limits_{{x\\in [a,b]}}\\left| f^{(k)}(x) \\right|\\tag{7}\\]</p>\n
	<p>Тогда из (11) и (6) получаются следующие оценки погрешностей: \\[\\left| f'(x)-f_x(x) \\right|\\le \\frac{M_2h}{2},\\;\\;\\left| f'(x)-f_\\overline{x} \\right|\\le \\frac{M_2h}{2}\\tag{8}\\]</p>\n
	<p>Следовательно, погрешности обеих формулы имеют порядок малости \\(O(h)\\), если \\(f(x)\\) дважды дифференцируема на \\([a,b]\\).</p>\n
	<p>Рассмотрим полусумму \\[f_\\overset{\\circ}{x}(x)=\\frac{f_x(x)+f_\\overline{x}(x)}{2}=\\frac{f(x+h)-f(x-h)}{2h}\\tag{9}\\]</p>\n
	<p>называемую <font color = '#ff0000'>центральной разностью</font>. Используя разложения \\[f(x\\pm h)=f(x)\\pm hf'(x)+\\frac{h^2}{2}f''(x)\\pm \\frac{h^3}{3!}f'''(\\xi_{\\pm}(x))\\tag{10}\\]</p>\n
	<p>получим представление ее погрешности: \\[f'(x)-f_\\overset{\\circ}{x}(x)=\\frac{h^2}{6}f'''(\\xi (x))\\tag{11}\\]</p>\n
	<p>поскольку по теореме о среднем для сумм найдется \\(\\xi (x)\\) между \\(\\xi_{\\pm}(x)\\) такая, что \\[\\frac{f'''(\\xi_{+}(x))+f'''(\\xi_{-}(x))}{2}=f'''(\\xi (x))\\tag{12}\\]</p>\n
	<p>Таким образом, при одном и том же \\(h\\) центральная разность на порядок по \\(h\\) точнее, чем разности вперед и назад. Отметим, что ее нельзя использовать при вычислении 
производной в точке \\(x=a\\) или \\(x=b\\).</p>\n
	
	<h3>Пример вычисления центральной разности на Julia:</h3>
		<div class="code-container">
       		 <div class="code-header">
            		Центральная разность
           		 <span class="language-label">JULIA</span>
        	 </div>
       		 <pre><code class="language-julia">centr_r = (y[i+1] - y[i-1]) / (2h)   </code></pre>
	        </div>

	<p>Повторно применяя разделенные разности, получим формулы вычисления второй и более высокой производной. Возможны комбинации 
\\(f_{xx}(x)=(f_x)_x(x),\\;\\;f_{x\\overline{x}}(x),...\\tag{13}\\)</p>\n
	<p>Рассмотрим симметричную формулу \\[f_{x\\overline{x}(x)}=\\frac{f_x(x)-f_x(x-h)}{h}=\\frac{f(x+h)-2f(x)+f(x-h)}{h^2}\\tag{14}\\]</p>\n
	<p>Удерживая в разложения Тейлора \\(f(x\\pm h)\\) величины до порядка \\(h^4\\), аналогично предыдущему получим (проведите выкладки!) \\[f''(x)-f_{x\\overline{x}}(x)=-\\frac{h^2}{12}f^{(4)}(\\xi (x))\\tag{15}\\]</p>\n
	<p>Все рассмотренные выше формулы применимы для функций, заданных либо формулой, либо алгоритмом вычисления в произвольной точке, либо таблично.</p>\n\n

	<h2><i>Некорректность операции численного дифференцирования</i></h2>\n
	<p>Как правило, значения функции известны не точно, а с какой-то погрешностью. Напрмер, если трансцедентные функции вычисляются с помощью рядов, то ряды заменяются конечными суммами.
 Другими источниками погрешностей являются погрешности округления при вычислении функции или погрешность алгоритма его вычисления.</p>\n
	<p>Оказывается, что погрешность, возникающая при вычислении разностных отношений, намного превосходит погрешность в задании значений функции и даже может неограниченно возрастать 
при стремлении при стремлении шага \\(h\\) к нулю. Поэтому операцию вычисления разностных отношений называют <font color = '#ff0000'>некорректной</font>. Поясним причину некорректности на 
примере вычисления разностного отношения \\(f_x(x)\\).</p>\n
	<p>Разностное отношение \\(f_x(x)\\) хорошо приближает \\(f'(x)\\) только в том случае, когда шаг \\(h\\) достатточно мал. Требование малости величины \\(h\\), находящейся в знаменателе 
разностного отношоения, как раз и является причиной некорректности операции численного дифференцирования. Действительно, пусть вместо точного значения \\(f_x(x)\\) нам известны приближенные
 значения \\(\\widetilde{f}(x)=f(x)+\\epsilon(x)\\), причем известно, что \\(\\left| \\epsilon(x) \\right|\\le \\varepsilon\\) для любого \\(x\\in [a,b]\\). Тогда вместо \\(f_x(x)\\), будет 
вычислена величина \\[\\widetilde{f}_x(x)=f_x(x)+\\epsilon_x(x)\\tag{16}\\]</p>\n
	<p>Следовательно, погрешность в вычислении первой разностной производной окажется равной \\(\\epsilon_{x} (x)\\). Имеем \\[\\left| \\epsilon_x(x) \\right|=\\left| \\frac{\\epsilon
 (x+h)-\\epsilon(x)}{h} \\right|\\le \\frac{2\\epsilon}{h}\\tag{17}\\]</p>\n
	<p>причем эта оценка достигается при \\(\\epsilon(x+h)=-\\epsilon(x)=\\varepsilon\\). Как видим, погрешность в вычислении первой разностной производной неограниченно возрастает с 
уменьшением \\(h\\).</p>\n
	<p>Окончательно получим следующую оценку вычисления первой производной при наличии погрешностей (с использованием оценка (8)): \\[\\left| f'(x)-\\widetilde{f}_x(x) \\right|=\\left|
 (f'(x)-f_x(x))+(f_x(x)-\\widetilde{f}_x(x)) \\right|\\le \\frac{M_2h}{2}+\\frac{2\\varepsilon}{h}\\tag{18}\\]</p>\n
	<p>Оценка погрешности \\(\\varphi(h)=\\dfrac{M_2h}{2}+\\dfrac{2\\varepsilon}{h}\\) не стремится к нулю при \\(h\\to 0\\). Напротив, \\(\\varphi(h)\\longrightarrow \\infty \\). 
Минимальное ее значение достигается при \\[\\frac{M_2h}{2}+\\frac{2\\varepsilon}{h}\\Rightarrow h=h_0=\\sqrt{\\frac{4\\varepsilon}{M_2}}\\tag{19}\\]</p>\n
	<p>и равно \\(\\varphi(h_0)=2\\sqrt{M_2\\varepsilon}\\). Отсюда следует практическая рекомендация: при вычислении первой производной функции заданной с погрешностью \\(\\varepsilon\\) 
разностью вперед (или назад), шаг \\(h\\) должен иметь порядок \\(\\sqrt{\\varepsilon}\\). Меньшие порядки \\(h\\) лишь ухудшат результат.</p>\n
	<p>Сказанное остается справедливым для всех формул численного дифференцирования. Для каждой формулы существует свое оптимальное значение \\(h\\). При вычислении вторых и боолее
 высоких производных некорректность операции численного дифференцирования сказывается еще сильнее.</p>  
	`,
	"practica": `
	<h1><i>Численное дифференцирование функций</i></h1>
        <h2><i>Практическая работа №8</i></h2>

	<caption><h4>Пример 1.</h4></caption>
<p>Функция \\( f(x) \\) задана таблицей своих значений. Найти первую производную этой функции в точках \\( x_1^* = 0.7 \\) и \\( x_2^* = 1.0 \\). Оценить погрешности результатов. 
Найти оптимальный шаг \\( h^* \\) для каждой из формул численного дифференцирования.</p>
<table> <thead> 
<tr> <th>\\( x_i \\)</th> <th>\\(0.5\\)</th> <th>\\(0.6\\)</th> <th>\\(0.7\\)</th> <th>\\(0.8\\)</th> <th>\\(0.9\\)</th> <th>\\(1.0\\)</th> </tr> 
</thead> <tbody> 
<tr> <td>\\( y_i \\)</td> <td>\\(0.4794\\)</td> <td>\\(0.5646\\)</td> <td>\\(0.6442\\)</td> <td>\\(0.7174\\)</td> <td>\\(0.7833\\)</td> <td>\\(0.8415\\)</td> </tr> 
</tbody> </table>

<h4>Алгоритм численного дифференцирования с учётом погрешностей измерений</h4>

<p>Добавляем входные данные</p>
<p>Шаг 1: Вычисление конечных разностей</p>
<pre><code class="language-julia">
function kon_r(y)
    Δy = diff(y)         # первые разности
    Δ²y = diff(Δy)       # вторые разности
    Δ³y = diff(Δ²y)      # третьи разности
    Δ⁴y = diff(Δ³y)      # четвертые разности
    return Δy, Δ²y, Δ³y, Δ⁴y
end

# Вычисление конечных разностей
Δy, Δ²y, Δ³y, Δ⁴y = kon_r(y)
</code></pre>

<p>Шаг 2: Численное дифференцирование в средней точке</p>
<pre><code class="language-julia">
# Для точки x = 0.7 (индекс 3)
i = 3

# Центральная разность (2-й порядок точности)
centr_r = (y[i+1] - y[i-1]) / (2h)

# Правая разность (1-й порядок точности)
pr_r = (y[i+1] - y[i]) / h

# Левая разность (1-й порядок точности)
l_r = (y[i] - y[i-1]) / h
</code></pre>

<p>Шаг 3: Численное дифференцирование в краевой точке</p>
<pre><code class="language-julia">
# Для точки x = 1.0 (индекс 6) - только левая разность
i = 6
l_r_kr = (y[i] - y[i-1]) / h
</code></pre>

<p>Шаг 4: Оценка погрешностей численного дифференцирования</p>
<pre><code class="language-julia">
# Оценка погрешности для центральной разности
# Теоретическая оценка: |f'''(ξ)|·h²/6
o_centr = abs(Δ³y[2] * h^2 / 6)

# Оценка погрешности для односторонних разностей
# Теоретическая оценка: |f''(ξ)|·h/2
o_one_s = abs(Δ²y[2] * h / 2)
</code></pre>
<p>Выводим результат.</p>
`,
	"test": {
            "timeLimit": 600,
            "questions": [
      {
        "question": "Что из перечисленного является простейшими формулами численного дифференцирования для вычисления первой производной?",
        "answers": [
          {
            "text": "Разность вперед: \\(f'_x(x) = \\frac{f(x+h) - f(x)}{h}\\)",
            "correct": true
          },
          {
            "text": "Разность назад: \\(f'_x(x) = \\frac{f(x) - f(x-h)}{h}\\)",
            "correct": true
          },
          {
            "text": "Формула симметричной разности второго порядка",
            "correct": false
          }
        ],
        "type": "multiple"
      },
      {
        "question": "Какая из разностных формул имеет более высокий порядок точности при одинаковом шаге \\(h\\)?",
        "answers": [
          {
            "text": "Центральная разность: \\(f'_x(x) = \\frac{f(x+h) - f(x-h)}{2h}\\)",
            "correct": true
          },
          {
            "text": "Разность вперед: \\(f'_x(x) = \\frac{f(x+h) - f(x)}{h}\\)",
            "correct": false
          },
          {
            "text": "Разность назад: \\(f'_x(x) = \\frac{f(x) - f(x-h)}{h}\\)",
            "correct": false
          }
        ],
        "type": "single"
      },
      {
        "question": "Почему операция численного дифференцирования считается некорректной?",
        "answers": [
          {
            "text": "Погрешность вычисления разностных отношений может неограниченно возрастать при \\(h \\to 0\\)",
            "correct": true
          },
          {
            "text": "Малая величина \\(h\\) в знаменателе усиливает влияние погрешностей в значениях функции",
            "correct": true
          },
          {
            "text": "Численное дифференцирование всегда дает точные результаты независимо от шага \\(h\\)",
            "correct": false
          }
        ],
        "type": "multiple"
      },
      {
        "question": "Какую формулу используют для приближенного вычисления второй производной?",
        "answers": [
          {
            "text": "\\(f''_{xx}(x) = \\frac{f(x+h) - 2f(x) + f(x-h)}{h^2}\\)",
            "correct": true
          },
          {
            "text": "\\(f'_x(x) = \\frac{f(x+h) - f(x)}{h}\\)",
            "correct": false
          },
          {
            "text": "\\(f'_x(x) = \\frac{f(x+h) - f(x-h)}{2h}\\)",
            "correct": false
          }
        ],
        "type": "single"
      },
      {
        "question": "Что рекомендуется учитывать при выборе шага \\(h\\) при численном дифференцировании функции, заданной с погрешностью \\(\\varepsilon\\)?",
        "answers": [
          {
            "text": "Существует оптимальное значение \\(h\\) порядка \\(\\sqrt{\\varepsilon}\\), минимизирующее общую погрешность",
            "correct": true
          },
          {
            "text": "Чем меньше \\(h\\), тем точнее результат",
            "correct": false
          },
          {
            "text": "При вычислении вторых производных некорректность операции проявляется еще сильнее",
            "correct": true
          }
        ],
        "type": "multiple"
      }
    ]
        }
    },
	topic09: {
            "title": "Численное интегрирование функций",
            "theory": `
        <h1><i>Численное интегрирование функций</i></h1>
	<p>К вычислениям определенных интегралов сводятся многие практические задачи физики, химии, механики</p>
	<p>Например, для математических моделей химико-технологических процессов одним из основных параметров, характеризующих процессы, являются концентрации реагирующих веществ и 
температура процесса. Для таких моделей уравнения записываются системой интегральных и дифференциальных уравнений, в результате решения которых могут быть получены зависимости, характеризующие протекание процесса.</p>
	<p>Однако, на практике вычислить определенный интеграл аналитически не всегда удается.</p>
	<p>Под <font color = '#ff0000'>численным интегрированием</font> понимается набор численных методов вычисления значения определенного интеграла.</p>
	<p><font color = '#ff9100'><font size="4">Постановка задачи.</font></font> Вычислить определенный интеграл \\[I=\\int_{a}^{b}f(x)dx\\tag{1}\\] при условии, что \\(a\\) и 
\\(b\\) конечны и \\(F(x)\\)(первообразная) является непрерывной функцией на всем интервале \\([a,b]\\). Во многих случаях, когда подынтегральная функция задана в аналитическом виде, 
интеграл от этой функции в пределах от \\(a\\) до \\(b\\) может быть вычислен по формуле Ньютона-Лейбница \\[\\int_{a}^{b}f(x)dx=F(x)\\bigg|_a^b=F(b)-F(a)\\tag{2}\\]</p>
	<p>Однако этой формулой часто нельзя воспользоваться по следующим причинам:</p>
		<ol>  <li>Первообразная функция слишком сложна и ее нельзя выразить в элементарных функциях</li>
  		      <li>Функция \\(f(x)\\) задана в виде таблицы, что особенно часто встречается в инженерных задачах при обработке эксперементальных данных.</li></ol>
	<p>В этих случаях используют численные методы интегрования.</p>
	<p>Задача численного интегрирования состоит в нахождении приближенного значения интеграла (1) по заданным или вычисленным значениям.</p>
	<p>Общий подход к решению задачи состоит в следующем. Определенный интеграл представляет собой площадь, ограниченную кривой \\(f(x)\\), осью \\(x\\) и переменными \\(x=a\\) и \\(x=b\\). 
Необходимо вычислить интеграл, разбивая интервал \\([a,b]\\) на множество меньших интервалов, находя приблизительно площадь каждой фигуры, ограниченной перпендикулярами, восстановленными из 
каждой точки до пересечения с графиком функции \\(f(x)\\), и суммируя их.</p>
	<p>В зависимости от способавычисления подынтегральной суммы существуют различные методы численного интегрирования:</p>
		<ol>    <li>Метод прямоугольников;</li>
		        <li>Метод трапеций;</li>
		        <li>Метод парабол.</li></ol>

	<h2><i>Метод прямоугольников</i></h2>
	<p>Вычисление интеграла равносильно вычислению площади криволинейной трапеции с основаниями \\(x=a\\), \\(x_n=b\\) и "боковыми сторонами" \\(y=0\\), \\(y=f(x)\\).</p>
	<p>Разобьем отрзок \\([a,b]\\) на \\(n\\) равных отрезков точками деления \\(x_1,x_2,...,x_n\\). Обозначим \\(x_0=a, x_n=b\\)</p>
	<img src ="https://sun9-70.userapi.com/impg/t7ZPmrHRo9WXjlVYOjHUwkDD8eTmzzBB6plqtQ/jtdNCINDLWY.jpg?size=303x167&quality=96&sign=97b1347c5ceef21b7925f9a020c757c0&type=album">
	<p>Итак, весь отрезок \\([a,b]\\) разделен на отрезки: \\([x_0,x_1], [x_1,x_2],..., [x_{n-1},x_n]\\). Длина каждого орезка \\(h=(b-a)/n\\). Точки деления определяются по формулам: 
\\(x_1=a+h; x_2=a+2h;...;x_i=a+ih\\), где \\(i\\) &mdash; \\(i\\) - ый отрезок.</p>
	<p>Через точки деления проведем вертикальные прямые. Пусть они пересекают кривую \\(y=f(x)\\) в точках \\(A_0,A_1,...,A_n\\)</p>
	<img src = "https://sun1-85.userapi.com/impg/ZJ6L0eRygwVN9KUpBvScSdBPS3AnnpTtKWij2g/RE4Rl8pA4OY.jpg?size=278x180&quality=96&sign=a2851f02c15f9fd1cebbd296a3bdea73&type=album">
	<p>Ординаты этих точек обозначим \\(y_0,y_1,...,y_n\\). Эти ординаты &mdash; значения функции в точках деления \\([a,b]\\), т.е. в точках \\(x_0,x_1,...,x_n\\). Поэтому можно записать 
\\(y_0=f(x_0),y_1=f(x_1),...,y_n=f(x_n)\\)</p>
	<img src = "https://sun9-56.userapi.com/impg/5GwCsceNBdPrHZ5GHSGQ6xu7Hi8CZ7fg9ulTeQ/vFLEZMMz4lM.jpg?size=311x146&quality=96&sign=99890901d6e5ca5de63f570fa0213465&type=album">
	<p>Проведенные прямые разделят всю криволинейную трапецию на \\(n\\) частичных криволинейных трапеций, площади которых обозначим \\(S_1,S_2,...,S_n\\). Соответственно, \\(S=S_1+S_2+...+S
_n\\). Каждую частичную криволинейную трапецию заменим прямоугольником, основание которого есть отезок оси Ox, на котором построена эта трапеция, а высота равна крайней левой ординате данной
 трапеции. Каждый такой прямоугольник будет иметь основание \\(h\\), а высоты будут \\(y_0,y_1,...,y_{n-1}\\) соответственно.</p>
	<img src = "https://sun9-31.userapi.com/impg/Dpt6qmwBrBie6fQNY889HB6HHetU15A5kcXTGw/4NvqFwLQn64.jpg?size=332x148&quality=96&sign=7f81f41d66357380b524f06f595ff5c2&type=album">
	<p>Объединим все эти прямоугольники, получим многоугольник, площадь которого близка к площади данной криволиненйной трапеции. Площадь многоугольника равна сумме площадей построенных
 прямоугольников \\(y_0h+y_1h+...+y_{n-1}h\\). Это и будет приближенное значение интеграла \\(\\int_{a}^{b}f(x)dx\\approx hf(x_0)+hf(x_1)+...+hf(x_{n-1})\\), т.е. <font color = '#ff0000'>формула
 "левых" прямоугольников</font> запишется \\[\\int_{a}^{b}f(x)dx\\approx h\\sum_{i=0}^{n-1}f(x_i)\\tag{3}\\]</p>
	<p>Если в качестве приближенного значения площади для каждого подинтервала принять площадь прямоугольника, высота которого равна правой ординате криволинейной трапеции. Тогда высоты
 прямоугольников будут \\(y_1,y_2,...,y_n\\) и формула численного интегрирования имеет вид \\(\\int_{a}^{b}f(x)dx\\approx hf(x_0)+hf(x_1)+...+hf(x_{n})\\), то <font color = '#ff0000'>формула 
"правых" прямоугольников</font> запишется \\[\\int_{a}^{b}f(x)dx\\approx h\\sum_{i=1}^{n}f(x_i)\\tag{4}\\] при этом \\(x_i=a+ih\\)</p>
	<img src = "https://sun9-62.userapi.com/impg/X30EoUCO2AyTv5pf3lQVucDECCUdHPTjaG6oGw/Lw1Pj7aQW6g.jpg?size=435x257&quality=96&sign=6bb920933ca4f51f62ac431d954df1f0&type=album">
	<p><font color = '#ff0000'>Абсолютную погрешность \\(R_n\\) формул прямоугльников</font> (3) и (4) вычисляют по формуле \\[\\left| R_n \\right|=\\left| I-I_n \\right|=\\frac{(b-a)^2}{2n}M_1\\tag{5}\\] 
где \\(I\\) &mdash; точное приближение, \\(I_n\\) &mdash; приближенное значение интеграла, \\(M_1=\\max\\limits_{{x\\in [a,b]}}\\left| f'(x) \\right|\\)</p>
	<p>Если в качестве приближенного значения площади для каждого подинтервала принять площадь прямоугольника, высота которого равна значению \\(f(x)\\) в средней точке подинтервала, 
то <font color = '#ff0000'>формула "средних" прямоугольников</font> имеет вид \\[\\int_{a}^{b}f(x)dx\\approx h\\sum_{i=1}^{n}f(x_i)\\tag{6}\\] при этом \\(x_i=a+ih-\\frac{h}{2}\\)</p>
	<img src = "https://sun9-36.userapi.com/impg/1o0BiwRjRjb-4XwPQGCa-ucnTugWXpRozhID0g/aONU0AUAeDY.jpg?size=424x265&quality=96&sign=6181596c65f7e7a6a2491bde437b3318&type=album">
	<p><font color = '#ff0000'>Абсолютная погрешность метода "средних" прямоугольников</font> оценивается по формуле \\[\\left| R_n \\right|=\\frac{(b-a)^3}{24n^2}M_2\\tag{7}\\] где \\(M_2\\) 
&mdash; наибольшее значение \\(\\left| f''(x) \\right|\\) на отрезке \\([a,b]\\).</p>
	<p>При неограниченном возрастании \\(n\\) абсолютная погрешность стремится к 0, т.е. точность приближения будет больше, когда на большее число равных частей будет разделен отрезок 
\\([a,b]\\).</p>
	<p><font color = '#ffa726'><font size="4">Пример.</font></font> Вычислить приближенное значение определенного интеграла \\[\\int_{0}^{3,2}\\sqrt{x^4-x^3+8}\\ dx\\] методом "левых" и 
"правых" прямоугольников при \\(n=10\\).</p>

	<h4><font color = '#ffa726'>Решение:</font></h4>
	<p>\\[f(x_i)=\\sqrt{x^4-x^3+8}\\] \\(a=0,\\; b=3,2,\\; h=(3,2-0)/10=0,32\\)</p>
	<p>Точки разбиения отрезка \\([0;3,2]\\) определяют: \\[x_i=a+ih,\\; i=0,1,...,n\\]</p>
	<p>для \\(i=0\\to x_i=x_0=0+0\\cdot 0,32=0\\to f(x_i)=f(x_0)=f(0)=\\sqrt{0^4-0^3+8}=2,82448\\)</p>
	<p>и так далее до \\(i=10\\).</p>
	<img src = "https://sun9-26.userapi.com/impg/dueWTlqGAxqLo0sGB1HbVBoDUswLaYAL5ZMnKg/XfuExPqj5A0.jpg?size=783x122&quality=96&sign=678bdbc897be94090683ecea4f6194ff&type=album">
	<p>Подставляем в формулу (3) "левых" прямоугольников</p>
	<p>\\(\\int_{0}^{3,2}\\sqrt{x^4-x^3+8}\\ dx\\approx h\\sum_{i=0}^{n-1}f(x_i) = 0,32(2,82843+2,82449+2,81169+2,82216+\\)</p>
	<p>\\(+2,93039+3,23382+3,80942+4,68368+5,84572+7,27387)=12,50038\\)</p>
	<p>Подставляем в формулу (4) "правых" прямоугольников</p>
	<p>\\(\\int_{0}^{3,2}\\sqrt{x^4-x^3+8}\\ dx\\approx h\\sum_{i=1}^{n}f(x_i) = 0,32(2,82449+2,81169+2,82216+2,93039+\\)</p>
	<p>\\(+3,23382+3,80942+4,68368+5,84572+7,27387+8,94928)=14,45905\\)</p>
	<p>Метод прямоугольников &mdash; это наиболее простой и грубый метод приближенного интегрирования. Однако, увеличение числа отрезков разбиения не всегда возможно. Поэтому 
рассмотрим методы, дающие более точные результаты.</p>

	<h3>Функции для метода прямоугольников на Julia:</h3>
		<div class="code-container">
       		 <div class="code-header">
            		Метод прямоугольников
           		 <span class="language-label">JULIA</span>
        	 </div>
       		 <pre><code class="language-julia">function left_p(f, a, b, n)
    h = (b - a) / n
    sum(f(x) for x in range(a, stop = b - h, length = n)) * h
end

function right_p(f, a, b, n)
    h = (b - a) / n
    sum(f(x) for x in range(a + h, stop = b, length = n)) * h
end

function mid_p(f, a, b, n)
    h = (b - a) / n
    sum(f(x + h/2) for x in range(a, stop = b - h, length = n)) * h
end

</code></pre>
	        </div>

	<h2><i>Метод трапеций</i></h2>
	<p>В этом методе отрезок \\([a,b]\\) также разбивается на \\(n\\) равных частей. На каждом отрезке кривая \\(y=f(x)\\) заменяется прямой, проходящей через две известные точки с 
координатами \\((x_i;f(x_i))\\) и \\((x_{i+1},f(x_{i+1}))\\), где \\(i=0,1,...,n\\) и строится прямоугольная трапеция с высотой \\(h\\). Пусть \\(y_0,y_1,...,y_n\\) &mdash; соответствующие им 
ординаты графика функции. Тогда расчетные формулы для этих значений примут вид: \\[x_i=a+ih, \\; y_i=f(x_i),\\; i=0,1,...,n, \\; h=(b-a)/n\\]</p>
	<img src = "https://sun9-56.userapi.com/impg/lqSIEWDrKxRJIbt0uRMkCDr-ARuw_vhUYApE1Q/hIQuyD-ZRfw.jpg?size=452x262&quality=96&sign=444ae759f5115ce0b994c8f34252d6b5&type=album">
	<p>Заменим кривую \\(y=f(x)\\) ломаной линией, звенья которой соединяют концы ординат \\(y_i\\) и \\(y_{i+1}\\). Тогда площадь криволиненйной трапеции приближенно равна сумме площадей 
обычных трапеций с основаниями \\(y_i,\\;y_{i+1}\\) и высотой \\(h\\) \\[\\int_{a}^{b}f(x)\\ dx\\approx h\\cdot (\\frac{y_0+y_1}{2}+\\frac{y_1+y_2}{2}+...+\\frac{y_{n-1}+y_n}{2})\\] или \\[\\int_{a}^{b}f(x)\\
 dx\\approx h\\cdot (\\frac{y_0+y_n}{2}+y_1+y_2+...+y_{n-1})\\approx h(\\frac{f(a)+f(b)}{2}+\\sum_{i=1}^{n-1}f(x_i))\\]</p>
	<p><font color = '#ff0000'>Формула трапеций</font> имеет вид: \\[\\int_{a}^{b}f(x)\\ dx\\approx h(\\frac{f(a)+f(b)}{2}+\\sum_{i=1}^{n-1}f(x_i))\\tag{8}\\]</p>
	<p><font color = '#ff0000'>Абсолютная погрешность \\(R_n\\) приближения</font>, полученного по формуле трапеций, оценивается по формуле: \\[\\left| R_n \\right|=\\frac{(b-a)^3}{12n^2}
\\cdot M_2\\tag{9}\\]где \\(M_2=\\max\\limits_{{x\\in [a,b]}}\\left| f''(x) \\right|\\)</p>

	<h3>Функция для метода трапеций на Julia:</h3>
		<div class="code-container">
       		 <div class="code-header">
            		Метод трапеций
           		 <span class="language-label">JULIA</span>
        	 </div>
       		 <pre><code class="language-julia">function trap(f, a, b, n)
    h = (b - a) / n
    # Суммируем внутренние точки и добавляем полусумму крайних
    xs_inner = range(a + h, stop = b - h, length = n - 1)
    sum_inner = sum(f, xs_inner)
    (h/2) * (f(a) + 2*sum_inner + f(b))
end

function exact_integral(f, a, b)
    result, error = quadgk(f, a, b, rtol=1e-12)
    return result, error
end

</code></pre>
	        </div>


	<h2><i>Метод парабол (Симпсона)</i></h2>
	<p>Если заменить график функции \\(f(x)\\) на каждом отрезке разбиения не отрезками прямых, а дугами парабол, то получим более точную формулу приближенного вычисления интеграла.</p>
	<p>Отрезок \\([a,b]\\) разделим на четное число \\(2n\\) равных отезков \\(x_1,x_2,...,x_{2n-1}\\). Длина каждого частичного отрезка \\(h=\\dfrac{(b-a)}{2n}\\). Точки разбиения \\(x_i=a+ih\\),
 \\(i=0,1,...,2n\\). Объединим построенные отрезки попарно и рассмотрим отрезки \\([x_0;x_2],[x_2;x_4],...,[x_{2n-2};x_{2n}]\\) (здесь \\(x_0=a,\\;x_{2n}=b\\)). Серединами этих отрезков будут 
точки \\(x_1,x_3,...,x_{2n-1}\\). Длина каждого такого сдвоенного отрезка равна \\(2h=\\dfrac{(b-a)}{n}\\). Значения функции в точках \\(x_0,x_1,...\\) обозначим \\(y_0,y_1,...\\)</p>
	<img src = "https://sun9-8.userapi.com/impg/_koIBwUSFyxVU_nz9mdZBcY8AN6rCS5g84-zIw/rDtIjxTx7as.jpg?size=282x190&quality=96&sign=c74a52a8af8f0df25e0a064d3ea6a4c7&type=album">
	<p>На каждом отрезке \\([x_{2i-2};x_{2i}\\), \\(i=1,...,n\\) подынтегральная функция приближается квадратичной параболой \\(y=a_ix^2+b_ix+c_i\\), проходящей через точки \\((x_{2i-1};
f(x_{2i-1})), (x_{2i};f(x_{2i}))\\) (Поэтому в качестве приближенного значения определенного интеграла \\(\\int_{x_{2i-2}}^{x_{2i}}f(x)\\ dx\\) можно взять интеграл \\(\\int_{x_{2i-2}}^{x_{2i}}
(a_1x^2+b_ix+c)\\ dx\\), который можно вычислить по формулу Ньютона-Лейбница).</p>
	<p>Такая парабола всегда существует и единственна. Ее можно найти аналитически, затем останется только проинтегрировать выражение для нее, и окончательно полагаем: \\[\\int_{x_{2i-2}}
^{x_{2i}}(a_1x^2+b_ix+c)\\ dx = \\frac{h}{3}(f(x_0)+4(f(x_1)+f(x_3)+...+f(x_{2n-1}))+\\]\\[+2(f(x_2)+f(x_4)+...+f(x_{2n-2}))+f(x_{2n}))\\]</p>
	<p><font color = '#ff0000'>Формула парабол (Симпсона)</font> имеет вид \\[\\int_{x_a}^{x_b}\\ dx\\approx \\frac{h}{3}(y_0+4(y_1+y_3+...+y_{2n-1})+2(y_2+y_4+...+y_{2n-2})+y_{2n})\\tag{10}\\]</p>
	<p><font color = '#ff0000'>Абсолютная погрешность формулы парабол</font> вычисляется \\[\\left| R \\right|\\le \\frac{(b-a)^5}{180\\cdot (2n)^4}\\cdot M_4\\tag{11}\\] где \\(M_4=\\max\\limits_{
{x\\in [a,b]}}\\left| f^4(x) \\right|\\)</p>s

		<h3>Функция для метода порабол на Julia:</h3>
		<div class="code-container">
       		 <div class="code-header">
            		Метод порабол
           		 <span class="language-label">JULIA</span>
        	 </div>
       		 <pre><code class="language-julia">function simpson_method(f, a, b, n)
    # четность
    n = iseven(n) ? n : n + 1
    h = (b - a) / n
    
    # Сумма с весами
    sum_odd = sum(f(a + i*h) for i in 1:2:n-1)
    sum_even = sum(f(a + i*h) for i in 2:2:n-2)
    
    return (h/3) * (f(a) + f(b) + 4*sum_odd + 2*sum_even)
end
</code></pre>
	        </div>


	<h2><i>Практические приемы оценки погрешности вычислений</i></h2>
	<p>Однако формулы (9) и (11) можно применять только в тех случаях, когда существуют и легко вычисляются производные \\(f''(x)\\) и \\(F^{IV}(x)\\) порядков. Если же функция \\(f(x)\\) 
задана таблицей и ее аналитическое выражение неизвестно, то использование формулы становится невозможным.</p>
	<p>В этом случае значение погрешности находится:</p>
		<ol>    <li>Вычисление интеграла \\(I=\\int{}{}f(x)\\ dx\\) выполняется два раза. Один раз разделим отрезок на \\(n\\) частей (\\(n\\) &mdash; четное), получим приближенное значение
 интеграла \\(I_n\\). Второй раз увеличим число отрезков вдвое, получим значение \\(I_{2n}\\).</li>
    			<li>При выполнении значения интеграла по формуле трапеций используются следующим выражением для погрешности: \\[R_n=\\frac{\\left| I_{2n}-I_n \\right|}{3}\\]</li>
   			<li>При вычислении значения интеграла парабол (Симпсона) погрешность равна \\[R_n=\\frac{\\left| I_{2n}-I_n \\right|}{15}\\]</li></ol>

	<h2><i>Выбор шага интегрирования</i></h2>
	<p>При вычислении значения определенного интеграла от функций, заданных аналитически, необходимо обеспечить требуемую точность расчета \\(\\varepsilon\\). Она достигается уменьшением шага интегрирования</p>
	<p>Для метода Симпсона сначала вычисляется значение интеграла с шагом \\(h\\;(I^{(h)})\\). Хатем значение шага делится пополам при этом количество отрезков интегрирования увеличивается
 в 2 раза, и интеграл вычисляется с шагом \\(h/2\\;(I^{(h/2)})\\). Вычисления заканчивают, если разность вычисленных значений интеграла меньше заданной точности \\(\\left| I^{h}-I^{(h/2)} 
\\right|\\le \\varepsilon\\).</p>
	<p>Если результаты отличаются более чем на требуемую точность, продолжают деление шага и вычисляют значения \\(I^{(h/4)},\\;I^{(h/8)},...\\) и т.д.</p>
	<p>Такой способ называется <font color = '#ff0000'>автоматическим выбором шага интегрирования</font>.</p>
	<p>Преимущество способа вычисления интеграла с автоматическим выбором шага состоит в том, что он приспосабливается к особенностям подынтегральной функции: в областях резкого 
изменения функции шаг уменьшается, а там, где функция изменяется слабо &mdash; увеличивается.</p>
`,
	"practica": `
	<h1><i>Численное интегрирование функций</i></h1>
        <h2><i>Практическая работа №9</i></h2>

	<caption><h4>Пример 1.</h4></caption>
<p>Вычислить значение интеграла \\( \\int\\limits_{0}^{3\\sqrt{2}} \\sqrt{x^4 - x^3 + 8} \\, dx \\), используя формулы методов левых, правых и средних прямоугольников при \\( n = 100 \\).</p>
	
<h4>Алгоритм численного интегрирования методами прямоугольников</h4>

<p>Шаг 1: Определение интегрируемой функции</p>
<pre><code class="language-julia">
using QuadGK, Printf

# Функция для интегрирования
f(x) = √(x^4 - x³ + 8)
</code></pre>

<p>Шаг 2: Метод левых прямоугольников</p>
<pre><code class="language-julia">
function left_p(f, a, b, n)
    h = (b - a) / n                # шаг интегрирования
    sum = 0.0
    for i in 0:n-1
        x_i = a + i * h            # левая точка интервала
        sum += f(x_i)
    end
    return sum * h
end
</code></pre>

<p>Формула: I = h·Σᵢ₌₀ⁿ⁻¹ f(xᵢ), где xᵢ = a + i·h</p>

<p>Шаг 3: Метод правых прямоугольников</p>
<pre><code class="language-julia">
function right_p(f, a, b, n)
    h = (b - a) / n
    sum = 0.0
    for i in 1:n
        x_i = a + i * h            # правая точка интервала
        sum += f(x_i)
    end
    return sum * h
end
</code></pre>

<p>Формула: I = h·Σᵢ₌₁ⁿ f(xᵢ), где xᵢ = a + i·h</p>

<p>Шаг 4: Метод средних прямоугольников</p>
<pre><code class="language-julia">
function mid_p(f, a, b, n)
    h = (b - a) / n
    sum = 0.0
    for i in 0:n-1
        x_mid = a + (i + 0.5) * h  # средняя точка интервала
        sum += f(x_mid)
    end
    return sum * h
end
</code></pre>

<p>Формула: I = h·Σᵢ₌₀ⁿ⁻¹ f(xᵢ+½), где xᵢ+½ = a + (i + 0.5)·h</p>

<p>Шаг 5: Точное значение интеграла (для сравнения)</p>
<pre><code class="language-julia">
function exact_integral(f, a, b)
    result, error = quadgk(f, a, b, rtol=1e-10)
    return result
end
</code></pre>

<p>Шаг 6: Оценка погрешностей</p>
<pre><code class="language-julia">
function pogr(f, a, b, n)
    h = (b - a) / n
    # Оценка максимальной производной на отрезке
    xs = range(a, stop=b, length=100)
    deriv_est = maximum(abs(f(x + h/100) - f(x)) * 100/h for x in xs[1:end-1])
    return (b - a) * h/2 * deriv_est
end

function pogr_mid(f, a, b, n)
    h = (b - a) / n
    xs = range(a, stop=b, length=100)
    # Оценка второй производной
    f_pp_est = maximum(abs(f(x + h/50) - 2*f(x) + f(x - h/50)) * 2500/h^2 
                      for x in xs[2:end-1])
    return (b - a) * h²/24 * f_pp_est
end
</code></pre>

<p>Теоретические оценки погрешностей:</p>
<ul>
    <li>Лево/правые прямоугольники: ε ∼ (b-a)·h/2·max|f'(x)|</li>
    <li>Средние прямоугольники: ε ∼ (b-a)·h²/24·max|f''(x)|</li>
</ul>

<p>Добавляем главную функцию, где добавлен ввод данных с консоли, вычисление и сравнение результатов.</p>
<p>Выводим результат.</p>

	<caption><h4>Пример 2.</h4></caption>
<p>Найти значение интеграла \\( \\int_{0.4}^{1.2} \\dfrac{\\cos(x)}{x+2} \\, dx \\), используя метод трапеций при \\( n=100 \\).</p>
	
<h4>Алгоритм численного интегрирования методом трапеций</h4>

<p>Вводим интегрируемую функцию</p>
<p>Шаг 1: Метод трапеций</p>
<pre><code class="language-julia">
function trap(f, a, b, n)
    h = (b - a) / n                # шаг интегрирования
    # Сумма внутренних точек (умноженных на 2)
    xs_inner = range(a + h, stop = b - h, length = n - 1)
    sum_inner = sum(f, xs_inner)
    
    # Формула трапеций
    return (h/2) * (f(a) + 2*sum_inner + f(b))
end
</code></pre>

<p>Шаг 2: Точное значение интеграла (для сравнения)</p>
<pre><code class="language-julia">
function exact_integral(f, a, b)
    result, error = quadgk(f, a, b, rtol=1e-12)
    return result, error
end
</code></pre>

<p>Шаг 3: Оценка погрешности метода трапеций</p>
<pre><code class="language-julia">
function trap_pogr(f, a, b, n)
    h = (b - a) / n
    # Оценка максимальной второй производной на отрезке
    xs = range(a, stop = b, length = 100)
    
    # Функция для оценки f''(x) через конечные разности
    f_pp_est(x) = (f(x + h/100) - 2*f(x) + f(x - h/100)) / (h/100)^2
    
    max_fpp = maximum(abs(f_pp_est(x)) for x in xs[2:end-1])
    
    # Теоретическая оценка погрешности: (b-a)·h²/12·max|f''(x)|
    return (b - a) * h^2 / 12 * max_fpp
end
</code></pre>
<p>Добавляем главную функцию, где добавлен ввод данных с консоли, вычисление и сравнение результатов.</p>
<p>Выводим результат.</p>

	<caption><h4>Пример 3.</h4></caption>
<p>Найти значение интеграла \\( \\int_{1.2}^{1.6} \\dfrac{\\sin(2x-2.1)}{x^2+1} \\, dx \\) в C++, используя метод парабол при \\( n=100 \\).</p>
	
<h4>Алгоритм численного интегрирования методом Симпсона</h4>
<p>Определяем входную функцию.</p>
<p>Шаг 1: Вычисление четвертой производной</p>
<pre><code class="language-julia">
# Вычисление 4-й производной с помощью автоматического дифференцирования
function proizv(f, x)
    f4 = ForwardDiff.derivative(f, x)
    f4 = ForwardDiff.derivative(x -> ForwardDiff.derivative(f, x), x)
    f4 = ForwardDiff.derivative(x -> ForwardDiff.derivative(x -> ForwardDiff.derivative(f, x), x), x)
    return ForwardDiff.derivative(x -> ForwardDiff.derivative(x -> ForwardDiff.derivative(x -> ForwardDiff.derivative(f, x), x), x), x)
end
</code></pre>

<p>Шаг 2: Метод Симпсона</p>
<pre><code class="language-julia">
function simpson_method(f, a, b, n)
    # Убеждаемся, что n четное
    n = iseven(n) ? n : n + 1
    h = (b - a) / n
    
    # Суммы нечетных и четных индексов
    sum_odd = sum(f(a + i*h) for i in 1:2:n-1)
    sum_even = sum(f(a + i*h) for i in 2:2:n-2)
    
    # Формула Симпсона
    return (h/3) * (f(a) + f(b) + 4*sum_odd + 2*sum_even)
end
</code></pre>

<p>Шаг 3: Оценка погрешности метода Симпсона</p>
<pre><code class="language-julia">
function simpson_pogr(f, a, b, n)
    n = iseven(n) ? n : n + 1
    h = (b - a) / n
    
    # Максимум 4-й производной на отрезке
    xs = range(a, stop=b, length=101)
    f4_max = maximum(abs(proizv(f, x)) for x in xs)
    
    # Теоретическая оценка погрешности
    return (b - a) * h^4 / 180 * f4_max
end
</code></pre>
<p>Добавляем главную функцию, где добавлен ввод данных с консоли, вычисление и сравнение результатов.</p>
<p>Выводим результат.</p> 
`,
	"test": {
    "timeLimit": 600,
    "questions": [
      {
        "question": "Какие из перечисленных причин могут препятствовать использованию формулы Ньютона-Лейбница для вычисления определённого интеграла?",
        "answers": [
          {
            "text": "Подынтегральная функция задана таблично (например, результатами эксперимента)",
            "correct": true
          },
          {
            "text": "Подынтегральная функция имеет сложную первообразную, не выражаемую в элементарных функциях",
            "correct": true
          },
          {
            "text": "Число точек разбиения отрезка интегрирования слишком мало (например, \\(n=2\\))",
            "correct": false
          }
        ],
        "type": "multiple"
      },
      {
        "question": "Какие из утверждений справедливы для метода прямоугольников?",
        "answers": [
          {
            "text": "При увеличении числа отрезков разбиения \\(n\\) абсолютная погрешность вычислений стремится к нулю",
            "correct": true
          },
          {
            "text": "Метод \"средних\" прямоугольников имеет более высокий порядок точности по сравнению с методами \"левых\" и \"правых\" прямоугольников",
            "correct": true
          },
          {
            "text": "Абсолютная погрешность метода прямоугольников оценивается через максимум третьей производной подынтегральной функции",
            "correct": false
          }
        ],
        "type": "multiple"
      },
      {
        "question": "В каком методе численного интегрирования подынтегральная функция на каждом элементарном отрезке заменяется дугой квадратичной параболы?",
        "answers": [
          {
            "text": "Метод трапеций",
            "correct": false
          },
          {
            "text": "Метод Симпсона (парабол)",
            "correct": true
          },
          {
            "text": "Метод средних прямоугольников",
            "correct": false
          }
        ],
        "type": "single"
      },
      {
        "question": "Какие из утверждений верны относительно оценки погрешности численного интегрирования?",
        "answers": [
          {
            "text": "Для метода трапеций абсолютная погрешность оценивается через максимум второй производной функции: \\(|R_n| \\le \\frac{(b-a)^3}{12n^2} M_2\\)",
            "correct": true
          },
          {
            "text": "Для метода Симпсона абсолютная погрешность оценивается через максимум четвёртой производной функции",
            "correct": true
          },
          {
            "text": "Погрешность метода \"левых\" прямоугольников всегда меньше, чем погрешность метода трапеций при одинаковом числе разбиений \\(n\\)",
            "correct": false
          }
        ],
        "type": "multiple"
      },
      {
        "question": "Какой практический приём позволяет оценить погрешность вычислений, если подынтегральная функция задана таблично и её аналитическое выражение неизвестно?",
        "answers": [
          {
            "text": "Вычислить интеграл дважды: сначала с шагом \\(h\\) (значение \\(I_n\\)), затем с шагом \\(h/2\\) (значение \\(I_{2n}\\)) и оценить погрешность как \\(\\frac{|I_{2n} - I_n|}{3}\\) (для трапеций) или \\(\\frac{|I_{2n} - I_n|}{15}\\) (для Симпсона)",
            "correct": true
          },
          {
            "text": "Использовать формулы с производными, численно приблизив их значения в узлах таблицы",
            "correct": false
          },
          {
            "text": "Сравнить результат с точным значением интеграла, найденным по таблице интегралов",
            "correct": false
          }
        ],
        "type": "single"
      }
    ]
  }
}
};

const menuToggle = document.getElementById('menuToggle');
const sideMenu = document.getElementById('sideMenu');
const tabButtons = document.querySelectorAll('.tab-btn');
const tabContent = document.getElementById('tab-content');
const modal = document.getElementById('modal');
// Переключение темы
const themeToggle = document.getElementById('themeToggle');
const themeIcon = themeToggle.querySelector('svg path');

// Проверяем сохраненную тему
const savedTheme = localStorage.getItem('theme') || 'light';
if (savedTheme === 'dark') {
    document.body.classList.add('dark-theme');
    themeIcon.setAttribute('d', 'M12,2A7,7 0 0,1 19,9C19,11.38 17.81,13.47 16,14.74V17A1,1 0 0,1 15,18H9A1,1 0 0,1 8,17V14.74C6.19,13.47 5,11.38 5,9A7,7 0 0,1 12,2M9,21V20H15V21A1,1 0 0,1 14,22H10A1,1 0 0,1 9,21Z');
}

themeToggle.addEventListener('click', () => {
    const isDark = document.body.classList.toggle('dark-theme');
    
    // Меняем иконку
    if (isDark) {
        themeIcon.setAttribute('d', 'M12,2A7,7 0 0,1 19,9C19,11.38 17.81,13.47 16,14.74V17A1,1 0 0,1 15,18H9A1,1 0 0,1 8,17V14.74C6.19,13.47 5,11.38 5,9A7,7 0 0,1 12,2M9,21V20H15V21A1,1 0 0,1 14,22H10A1,1 0 0,1 9,21Z');
        localStorage.setItem('theme', 'dark');
    } else {
        themeIcon.setAttribute('d', 'M12,18A6,6 0 0,1 6,12A6,6 0 0,1 12,6A6,6 0 0,1 18,12A6,6 0 0,1 12,18M20,15.31L23.31,12L20,8.69V4H15.31L12,0.69L8.69,4H4V8.69L0.69,12L4,15.31V20H8.69L12,23.31L15.31,20H20V15.31Z');
        localStorage.setItem('theme', 'light');
    }
});

// Боковое меню
menuToggle.addEventListener('click', () => sideMenu.classList.toggle('active'));
document.addEventListener('click', e => {
    if (!sideMenu.contains(e.target) && !menuToggle.contains(e.target) && !modal.contains(e.target)) {
        sideMenu.classList.remove('active');
    }
});
sideMenu.addEventListener('click', e => {
    const link = e.target.closest('a[data-topic]');
    if (link) {
        e.preventDefault();
        selectTopic(link.dataset.topic);
    }
});

function showModal({ title, content, onConfirm, requireName = false }) {
    modal.innerHTML = `
        <div class="modal-content">
            <button id="modal-close" class="modal-close-btn" aria-label="Закрыть">&times;</button>
            <h2>${title}</h2>
            ${content}
            <button id="modal-confirm" class="modal-btn" ${requireName ? 'disabled' : ''}>
                ${requireName ? 'Введите имя' : 'OK'}
            </button>
        </div>
    `;

    const confirmBtn = modal.querySelector('#modal-confirm');
    const closeBtn = modal.querySelector('#modal-close');
    const nameInput = requireName ? modal.querySelector('#user-name') : null;

    function close() {
        modal.classList.remove('active');
        document.getElementById('content').classList.remove('main-blur');
        document.removeEventListener('click', outsideClickHandler);
    }

    function outsideClickHandler(e) {
        if (!modal.querySelector('.modal-content').contains(e.target)) close();
    }

    closeBtn.addEventListener('click', close);
    confirmBtn.addEventListener('click', e => {
        e.preventDefault();
        if (!confirmBtn.disabled) {
            if (requireName) userName = nameInput.value.trim();
            close();
            onConfirm?.();
        }
    });

    if (requireName && nameInput) {
        nameInput.addEventListener('input', () => {
            const enabled = nameInput.value.trim().length > 0;
            confirmBtn.disabled = !enabled;
            confirmBtn.classList.toggle('disabled', !enabled);
            confirmBtn.textContent = enabled ? 'Начать тест' : 'Введите имя';
        });
    } else {
        confirmBtn.disabled = false;
    }

    document.getElementById('content').classList.add('main-blur');
    modal.classList.add('active');
    setTimeout(() => document.addEventListener('click', outsideClickHandler), 100);
}

let currentTopicKey = null;
let currentTab = "theory";

// Заполняем боковое меню темами
function renderMenu() {
    sideMenu.innerHTML = '';
    Object.entries(JSON_content).forEach(([key, topic]) => {
        const a = document.createElement('a');
        a.href = "#";
        a.textContent = topic.title;
        a.dataset.topic = key;
        a.addEventListener('click', (e) => {
            e.preventDefault();
            selectTopic(key);
        });
        sideMenu.appendChild(a);
    });
}

function renderMathJax() {
    if (typeof MathJax === 'undefined') return;
    try {
        if (MathJax.typesetPromise) {
            MathJax.typesetPromise([document.getElementById('tab-content')]);
        } else if (MathJax.Hub) {
            MathJax.Hub.Queue(["Typeset", MathJax.Hub, "tab-content"]);
        }
    } catch (err) {
        console.log('MathJax error', err);
    }
}

function selectTopic(topicKey) {
    currentTopicKey = topicKey;
    currentTab = "theory";
    updateTabButtons();
    showContent();
    updateActiveMenuItem();
    sideMenu.classList.remove('active');
}

function updateActiveMenuItem() {
    Array.from(sideMenu.children).forEach(link => {
        if (link.dataset.topic === currentTopicKey) {
            link.classList.add('active');
        } else {
            link.classList.remove('active');
        }
    });
}

function updateTabButtons() {
    tabButtons.forEach(btn => {
        btn.classList.toggle('active', btn.dataset.tab === currentTab);
    });
}

document.querySelector('.tabs').addEventListener('click', e => {
    const btn = e.target.closest('.tab-btn');
    if (!btn || !currentTopicKey) return;

    if (btn.dataset.tab === 'test') {
        showModal({
            title: "Введите ваше имя",
            content: `<input type="text" id="user-name" placeholder="Имя">`,
            requireName: true,
            onConfirm: () => {
                currentTab = 'test';
                updateTabButtons();
                showContent();
            }
        });
    } else {
        currentTab = btn.dataset.tab;
        updateTabButtons();
        showContent();
    }
});

document.addEventListener('DOMContentLoaded', () => {
    extractPracticeData();
    
    // Инициализируем данные для практики
    initializePracticeData();
    
    renderMenu();
    if (Object.keys(JSON_content).length > 0) {
        const firstTopicKey = Object.keys(JSON_content)[0];
        selectTopic(firstTopicKey);
    }
});

let testTimer = null;
let timeLeft = 0;
let userAnswers = {};
let testScore = 0;
let userName = "";

const timeout = 100;

function showContent() {
   if (!currentTopicKey || !JSON_content[currentTopicKey]) {
        document.getElementById('tab-content').innerHTML = "<p>Выберите тему</p>";
        return;
    }
    const topic = JSON_content[currentTopicKey];
    const tabContent = document.getElementById('tab-content');

    if (currentTab === 'theory') {
        tabContent.innerHTML = `<section>${topic.theory}</section>`;
        setTimeout(() => {
            renderMathJax();
            // Подсветка синтаксиса для нового контента
            if (typeof Prism !== 'undefined') {
                Prism.highlightAll();
            }
        }, timeout);
    } else if (currentTab === 'practica') {
    renderFullPractice();
	}else if (currentTab === 'test') {
        if (topic.test) {
            renderTest(topic.test);
            startTestTimer();
        } else {
            tabContent.innerHTML = "<p>Тест отсутствует</p>";
        }
    }

    window.scrollTo({
        top: 0,
        behavior: 'smooth'
    });
}
function renderTest(testData) {
    if (testTimer) clearInterval(testTimer);
    timeLeft = testData.timeLimit;
    userAnswers = {};
    testScore = 0;

    const html = testData.questions.map((q, i) => `
        <div class="question">
            <h3>${i + 1}. ${q.question}</h3>
            ${q.answers.map((a, ai) => `
                <label class="answer-option">
                    <input type="${q.type === 'multiple' ? 'checkbox' : 'radio'}"
                           name="q${i}" value="${ai}">
                    ${a.text}
                </label>
            `).join('')}
        </div>
    `).join('') + `
        <button type="submit" class="submit-btn">Завершить тест</button>
    `;

    tabContent.innerHTML = `
        <div id="test-container">
            <div id="timer" class="timer">${formatTime(timeLeft)}</div>
            <form id="test-form">${html}</form>
            <div id="test-results" style="display: none;"></div>
        </div>
    `;

    setTimeout(renderMathJax, timeout);

    document.getElementById('test-form').addEventListener('submit', e => {
        e.preventDefault();
        finishTest();
    });
    startTestTimer();
}

function startTestTimer() {
    testTimer = setInterval(updateTimer, 1000);
}

function updateTimer() {
    timeLeft--;
    document.getElementById('timer').textContent = formatTime(timeLeft);
   
    if (timeLeft <= 0) {
        clearInterval(testTimer);
        finishTest();
    }
}

function formatTime(seconds) {
    const mins = Math.floor(seconds / 60);
    const secs = seconds % 60;
    return `${mins}:${secs.toString().padStart(2, '0')}`;
}

function finishTest() {
    clearInterval(testTimer);
    calculateScore();
    showResults();
}

function calculateScore() {
    const topic = JSON_content[currentTopicKey];
    const testData = topic.test;
    testScore = 0;
   
    testData.questions.forEach((q, index) => {
        const selected = Array.from(document.querySelectorAll(`input[name="q${index}"]:checked`));
        const selectedIndices = selected.map(input => parseInt(input.value));
        const correctIndices = q.answers.map((answer, i) => answer.correct ? i : -1).filter(i => i !== -1);
       
        if (q.type === 'single') {
            if (selectedIndices[0] === correctIndices[0]) {
                testScore += 1;
            }
        } else {
            if (JSON.stringify(selectedIndices.sort()) === JSON.stringify(correctIndices.sort())) {
                testScore += 1;
            }
        }
    });
}

function showResults() {
    const topic = JSON_content[currentTopicKey];
    const testData = topic.test;

    showModal({
        title: "Результаты теста",
        content: `
            <p>Пользователь: ${userName}</p>
            <p>Время: ${formatTime(testData.timeLimit - timeLeft)}</p>
            <p>Правильных: ${testScore} из ${testData.questions.length} (${Math.round((testScore / testData.questions.length) * 100)}%)</p>
        `,
        onConfirm: () => {
            tabContent.innerHTML = '';
            currentTab = 'theory';
            updateTabButtons();
            showContent();
        }
    });
}
function getPracticeSelectionScreen() {
    return `
        <div class="variant-selector">
            <label for="variant-select">Выберите вариант работы:</label>
            <select id="variant-select">
                <option value=""> Выберите вариант </option>
                ${Array.from({length: 20}, (_, i) => 
                    `<option value="${i+1}">Вариант ${i+1}</option>`
                ).join('')}
            </select>
        </div>
        <div id="assignment-container"></div>
    `;
}

// Функция для выбора варианта в практике
// Функция для выбора варианта в практике
function selectVariant(variantId) {
    if (!variantId) {
        document.getElementById('assignment-container').innerHTML = '';
        return;
    }
    renderAllAssignmentsWithSameVariant(variantId);
}

function renderAllAssignmentsWithSameVariant(variantId) {
    const practiceData = JSON_content[currentTopicKey].practicaData;
    
    let html = '';
    
    if (practiceData && practiceData.assignments && practiceData.assignments.length > 0) {
        const variantIdNum = parseInt(variantId);
        
        // Для каждого задания показываем ОДИН И ТОТ ЖЕ вариант
        practiceData.assignments.forEach((assignment, assignmentIndex) => {
            // Ищем вариант по ID
            const variant = assignment.variants.find(v => v.id === variantIdNum);
            
            if (variant) {
                html += `
                    <div class="assignment" id="assignment-${assignmentIndex}">
                        <h3>${assignment.title} (Вариант ${variantId})</h3>
                        ${assignment.description ? `<div class="assignment-description">${assignment.description}</div>` : ''}
                        <div class="variant-task">
                            ${variant.content || ''}
                        </div>
                    </div>
                `;
            } else {
                // Если вариант не найден по ID, берем первый вариант
                const fallbackVariant = assignment.variants[0];
                if (fallbackVariant) {
                    html += `
                        <div class="assignment" id="assignment-${assignmentIndex}">
                            <h3>${assignment.title} (Вариант ${fallbackVariant.id})</h3>
                            ${assignment.description ? `<div class="assignment-description">${assignment.description}</div>` : ''}
                            <div class="variant-task">
                                ${fallbackVariant.content || ''}
                            </div>
                        </div>
                    `;
                }
            }
        });
        
        if (html === '') {
            html = `<p>Задания для варианта ${variantId} не найдены.</p>`;
        }
    } else {
        html = `<p>Практические задания не загружены.</p>`;
    }
    
    document.getElementById('assignment-container').innerHTML = html;
    
    // Обновляем MathJax
    if (window.MathJax) {
        MathJax.typesetPromise([document.getElementById('assignment-container')]);
    }
}

// Рендеринг всей практики (примеры + селектор вариантов)
function renderFullPractice() {
    const practiceHTML = JSON_content[currentTopicKey].practica;
    const practiceData = JSON_content[currentTopicKey].practicaData;
    
    // Проверяем, есть ли задания
    const hasAssignments = practiceData && practiceData.assignments && practiceData.assignments.length > 0;
    
    tabContent.innerHTML = `
        <section>
            ${practiceHTML}
            ${hasAssignments ? `
                <div class="practice-header">
                    <h4>Задания для самостоятельной работы</h4>
                </div>
                ${getPracticeSelectionScreen()}
            ` : '<p>Практические задания не загружены.</p>'}
        </section>
    `;
    
    const variantSelect = document.getElementById('variant-select');
    if (variantSelect) {
        variantSelect.addEventListener('change', function() {
            selectVariant(this.value);
        });
    }
    
    setTimeout(() => {
        renderMathJax();
        if (typeof Prism !== 'undefined') {
            Prism.highlightAll();
        }
    }, timeout);
}

function extractPracticeData() {
    Object.keys(JSON_content).forEach(key => {
        const practica = JSON_content[key].practica;
        if (practica && practica.includes('"assignments":')) {
            try {
                // Найти полный JSON объект (включая фигурные скобки)
                const match = practica.match(/("assignments":\s*\[[\s\S]*?\]\s*\n\s*\})/);
                if (match) {
                    // Добавим фигурные скобки чтобы сделать валидный JSON
                    const jsonStr = `{${match[1]}}`;
                    const data = JSON.parse(jsonStr);
                    
                    // Сохраняем assignments
                    JSON_content[key].practicaData = { 
                        assignments: data.assignments 
                    };
                    
                    // Убрать JSON из HTML чтобы не отображался
                    JSON_content[key].practica = practica.replace(
                        /\s*"assignments":\s*\[[\s\S]*?\]\s*\n\s*\}\s*\n\s*\`,\s*$/,
                        ''
                    );
                }
            } catch (e) {
                console.error('Error parsing practice data:', e);
                // Попробуем альтернативный метод парсинга
                try {
                    // Ищем assignments как отдельный массив
                    const startIndex = practica.indexOf('"assignments":');
                    const jsonPart = practica.substring(startIndex);
                    // Найдем конец массива
                    let bracketCount = 0;
                    let endIndex = 0;
                    let inString = false;
                    let escape = false;
                    
                    for (let i = 0; i < jsonPart.length; i++) {
                        const char = jsonPart[i];
                        
                        if (escape) {
                            escape = false;
                            continue;
                        }
                        
                        if (char === '\\') {
                            escape = true;
                            continue;
                        }
                        
                        if (char === '"' && !escape) {
                            inString = !inString;
                            continue;
                        }
                        
                        if (!inString) {
                            if (char === '[') bracketCount++;
                            if (char === ']') {
                                bracketCount--;
                                if (bracketCount === 0) {
                                    endIndex = i + 1;
                                    break;
                                }
                            }
                        }
                    }
                    
                    if (endIndex > 0) {
                        const assignmentsStr = jsonPart.substring(0, endIndex);
                        const fullJsonStr = `{${assignmentsStr}}`;
                        const data = JSON.parse(fullJsonStr);
                        
                        JSON_content[key].practicaData = { 
                            assignments: data.assignments 
                        };
                        
                        // Убрать JSON из HTML
                        JSON_content[key].practica = practica.replace(
                            assignmentsStr,
                            ''
                        ).trim();
                    }
                } catch (e2) {
                    console.error('Second attempt failed:', e2);
                }
            }
        }
    });
}
// После определения JSON_content, добавьте:
function initializePracticeData() {

    if (JSON_content.topic01 && !JSON_content.topic01.practicaData) {
        JSON_content.topic01.practicaData = {
            assignments: [{
                title: "Задание 1",
                description: `
	<ol>
    		<li><p>Найти предельную абсолютную погрешность \\(\\Delta x^*\\) функции \\(x\\).</p></li>
    		<li><p>Найти абсолютную погрешность \\(\\Delta x\\) функции \\(x\\).</p></li>
    		<li><p>Вычислить относительную погрешность \\(\\delta x\\) функции \\(x\\).</p></li>
    		<li><p>Оценить предельную относительную погрешность \\(\\delta x^*\\) функции \\(x\\).</p></li>
	</ol>
`,
                variants: [
                    {
                            "id": 1,
                            "content": "<p>Дана функция \\( x = \\dfrac{a \\cdot b}{\\sqrt[3]{c}} \\) и значение параметров с погрешностями \\( a = 3.85 \\pm 0.04 \\); \\( b = 2.043 \\pm 0.004 \\); \\( c = 96.6 \\pm 0.2 \\).</p>"
                        },
                        {
                            "id": 2,
                            "content": "<p>Дана функция \\( x = \\dfrac{\\sqrt{a} \\cdot b}{c} \\) и значение параметров с погрешностями \\( a = 3.85 \\pm 0.04 \\); \\( b = 2.043 \\pm 0.004 \\); \\( c = 96.6 \\pm 0.2 \\).</p>"
                        },
                        {
                            "id": 3,
                            "content": "<p>Дана функция \\( x = \\dfrac{\\sqrt{a} \\cdot b}{c} \\) и значение параметров с погрешностями \\( a = 2.28 \\pm 0.6 \\); \\( b = 84.6 \\pm 0.02 \\); \\( c = 68.7 \\pm 0.05 \\).</p>"
                        },
                        {
                            "id": 4,
                            "content": "<p>Дана функция \\( x = \\dfrac{a^2 b}{c} \\) и значение параметров с погрешностями \\( a = 0.323 \\pm 0.005 \\); \\( b = 3.147 \\pm 0.008 \\); \\( c = 1.78 \\pm 0.05 \\).</p>"
                        },
                        {
                            "id": 5,
                            "content": "<p>Дана функция \\( x = \\dfrac{a b^3}{\\sqrt{c}} \\) и значение параметров с погрешностями \\( a = 0.323 \\pm 0.005 \\); \\( b = 3.147 \\pm 0.008 \\); \\( c = 1.78 \\pm 0.05 \\).</p>"
                        },
                        {
                            "id": 6,
                            "content": "<p>Дана функция \\( x = \\dfrac{a b}{c^2} \\) и значение параметров с погрешностями \\( a = 0.258 \\pm 0.01 \\); \\( b = 3.45 \\pm 0.004 \\); \\( c = 1.374 \\pm 0.007 \\).</p>"
                        },
                        {
                            "id": 7,
                            "content": "<p>Дана функция \\( x = \\dfrac{a^2 b}{c - b} \\) и значение параметров с погрешностями \\( a = 2.712 \\pm 0.005 \\); \\( b = 0.37 \\pm 0.02 \\); \\( c = 13.21 \\pm 0.08 \\).</p>"
                        },
                        {
                            "id": 8,
                            "content": "<p>Дана функция \\( x = \\dfrac{a^2 b}{c^3} \\) и значение параметров с погрешностями \\( a = 3.804 \\pm 0.003 \\); \\( b = 4.05 \\pm 0.005 \\); \\( c = 2.18 \\pm 0.01 \\).</p>"
                        },
                        {
                            "id": 9,
                            "content": "<p>Дана функция \\( x = \\sqrt{\\dfrac{a \\cdot c}{b}} \\) и значение параметров с погрешностями \\( a = 0.834 \\pm 0.004 \\); \\( b = 138 \\pm 0.03 \\); \\( c = 1.84 \\pm 0.01 \\).</p>"
                        },
                        {
                            "id": 10,
                            "content": "<p>Дана функция \\( x = \\dfrac{a - b}{b \\cdot c} \\) и значение параметров с погрешностями \\( a = 54.8 \\pm 0.02 \\); \\( b = 2.45 \\pm 0.01 \\); \\( c = 0.68 \\pm 0.04 \\).</p>"
                        },
                        {
                            "id": 11,
                            "content": "<p>Дана функция \\( x = \\dfrac{\\sqrt{a} \\cdot b}{c^2} \\) и значение параметров с погрешностями \\( a = 13.28 \\pm 0.02 \\); \\( b = 2.37 \\pm 0.007 \\); \\( c = 5.13 \\pm 0.01 \\).</p>"
                        },
                        {
                            "id": 12,
                            "content": "<p>Дана функция \\( x = \\dfrac{a \\sqrt{b}}{c^2} \\) и значение параметров с погрешностями \\( a = 0.231 \\pm 0.008 \\); \\( b = 2.13 \\pm 0.01 \\); \\( c = 5.91 \\pm 0.05 \\).</p>"
                        },
                        {
                            "id": 13,
                            "content": "<p>Дана функция \\( x = \\dfrac{a}{c} \\) и значение параметров с погрешностями \\( a = 1.182 \\pm 0.005 \\); \\( b = 2.18 \\pm 0.009 \\); \\( c = 0.19 \\pm 0.01 \\).</p>"
                        },
                        {
                            "id": 14,
                            "content": "<p>Дана функция \\( x = \\dfrac{a + \\sqrt{c}}{b^2} \\) и значение параметров с погрешностями \\( a = 0.95 \\pm 0.01 \\); \\( b = 2.3 \\pm 0.03 \\); \\( c = 1.195 \\pm 0.005 \\).</p>"
                        },
                        {
                            "id": 15,
                            "content": "<p>Дана функция \\( x = \\dfrac{a + b}{\\sqrt{c}} \\) и значение параметров с погрешностями \\( a = 1.19 \\pm 0.05 \\); \\( b = 2.3 \\pm 0.1 \\); \\( c = 5.191 \\pm 0.08 \\).</p>"
                        },
                        {
                            "id": 16,
                            "content": "<p>Дана функция \\( x = \\dfrac{a}{b + \\sqrt{c}} \\ и значение параметров с погрешностями \\( a = 13.52 \\pm 0.02 \\); \\( b = 5.1 \\pm 0.03 \\); \\( c = 9.273 \\pm 0.008 \\).</p>"
                        },
                        {
                            "id": 17,
                            "content": "<p>Дана функция \\( x = \\dfrac{a}{\\sqrt{c + b}} \\) и значение параметров с погрешностями \\( a = 1.18 \\pm 0.01 \\); \\( b = 2.75 \\pm 0.05 \\); \\( c = 3.62 \\pm 0.007 \\).</p>"
                        },
                        {
                            "id": 18,
                            "content": "<p>Дана функция \\( x = a + \\dfrac{b}{\\sqrt{c}} \\) и значение параметров с погрешностями \\( a = 1.95 \\pm 0.03 \\); \\( b = 2.18 \\pm 0.01 \\); \\( c = 9.193 \\pm 0.008 \\).</p>"
                        },
                        {
                            "id": 19,
                            "content": "<p>Дана функция \\( x = a + b + c^2 \\) и значение параметров с погрешностями \\( a = 0.193 \\pm 0.00 \\); \\( b = 1.19 \\pm 0.01 \\); \\( c = 2.276 \\pm 0.009 \\).</p>"
                        },
                        {
                            "id": 20,
                            "content": "<p>Дана функция \\( x = a + \\dfrac{\\sqrt{c}}{b} \\) и значение параметров с погрешностями \\( a = 2.56 \\pm 0.04 \\); \\( b = 1.785 \\pm 0.09 \\); \\( c = 3.4 \\pm 0.1 \\).</p>"
                        }
                ]
            }]
        };
        
        if (JSON_content.topic01.practica && JSON_content.topic01.practica.includes('"assignments":')) {
            JSON_content.topic01.practica = JSON_content.topic01.practica.split('"assignments":')[0].trim();
        }
    }
    

if (JSON_content.topic02 && !JSON_content.topic02.practicaData) {
        JSON_content.topic02.practicaData = {
            assignments: [{
                title: "Задание 1",
                description: `
	<p>Выполнить отделение корней для функции своего варианта. Выполнить уточнение корней с точностью \\(0,001\\), используя методы половинного деления, Ньютона, простой итерации.</p>
`,
                variants: [
                    {
                            "id": 1,
                            "content": "<p>Дано уравнение \\( x^3 - 3x^2 + 3 = 0 \\).</p>"
                        },
                        {
                            "id": 2,
                            "content": "<p>Дано уравнение \\( x + 2 = e^{2x} \\).</p>"
                        },
                        {
                            "id": 3,
                            "content": "<p>Дано уравнение \\( x^3 + 3x^2 - 2 = 0 \\).</p>"
			},
                        {
                            "id": 4,
                            "content": "<p>Дано уравнение \\( 3x + \\cos(x) + 1 = 0 \\).</p>"
			},
                        {
                            "id": 5,
                            "content": "<p>Дано уравнение \\( x^3 - 12x - 5 = 0 \\).</p>"
                        },
                        {
                            "id": 6,
                            "content": "<p>Дано уравнение \\( (x+1)^3 + \\ln(x) = 0 \\).</p>"
                        },
                        {
                            "id": 7,
                            "content": "<p>Дано уравнение \\( x \\cdot 2^x = 1 \\).</p>"
                        },
                        {
                            "id": 8,
                            "content": "<p>Дано уравнение \\( \\sqrt{x+1} = x \\).</p>"
                        },
                        {
                            "id": 9,
                            "content": "<p>Дано уравнение \\( x - \\cos(x) = 0 \\).</p>"
                        },
                        {
                            "id": 10,
                            "content": "<p>Дано уравнение \\( x + \\ln\\left(\\dfrac{x}{2}\\right) = 0 \\).</p>"
                        },
                        {
                            "id": 11,
                            "content": "<p>Дано уравнение \\( 2x^3 + 9x^2 - 4 = 0 \\).</p>"
                        },
                        {
                            "id": 12,
                            "content": "<p>Дано уравнение \\( x^3 + 3x^2 - 1 = 0 \\).</p>"
                        },
                        {
                            "id": 13,
                            "content": "<p>Дано уравнение \\( x^3 + \\cos(x) = 0 \\).</p>"
                        },
                        {
                            "id": 14,
                            "content": "<p>Дано уравнение \\( x^3 - 3x^2 + 3.5 = 0 \\).</p>"
                        },
                        {
                            "id": 15,
                            "content": "<p>Дано уравнение \\( x^3 - 12x^2 - 10 = 0 \\).</p>"
                        },
                        {
                            "id": 16,
                            "content": "<p>Дано уравнение \\( 2 - x = \\ln(x) \\).</p>"
                        },
                        {
                            "id": 17,
                            "content": "<p>Дано уравнение \\( x + \\lg(x) = 0.5 \\).</p>"
                        },
                        {
                            "id": 18,
                            "content": "<p>Дано уравнение \\( (x+1)^2 = \\dfrac{1}{2}e^{-x} \\).</p>"
                        },
                        {
                            "id": 19,
                            "content": "<p>Дано уравнение \\( (2-x)e^x = 1 \\).</p>"
                        },
                        {
                            "id": 20,
                            "content": "<p>Дано уравнение \\( x^2 + 4\\sin(x) + 1 = 0 \\).</p>"
                        }
                ]
            }]
        };
        
        if (JSON_content.topic02.practica && JSON_content.topic02.practica.includes('"assignments":')) {
            JSON_content.topic02.practica = JSON_content.topic02.practica.split('"assignments":')[0].trim();
        }
    }


if (JSON_content.topic03 && !JSON_content.topic03.practicaData) {
        JSON_content.topic03.practicaData = {
            assignments: [{
                title: "Задание 1",
                description: `
	<p> Решить систему линейных уравнений, используя методы Гаусса, Якоби, Зейделя.</p>
`,
                variants: [
                    {
                            "id": 1,
                            "content": "<p>Дана система уравнений \\[ \\begin{cases} 31x_1 + 2{,}8x_2 + 1{,}9x_3 = 2 \\\\ 1{,}9x_1 + 31x_2 + 2{,}1x_3 = 21 \\\\ 7{,}5x_1 + 3{,}8x_2 + 48x_3 = 56 \\end{cases} \\].</p>"
                        },
                        {
                            "id": 2,
                            "content": "<p>Дана система уравнений \\[ \\begin{cases} 91x_1 + 5,6x_2 + 7,8x_3 = 98 \\\\ 3,8x_1 + 51x_2 + 2,8x_3 = 67 \\\\ 4,1x_1 + 5,7x_2 + 12x_3 = 58 \\end{cases} \\].</p>"
                        },
                        {
                            "id": 3,
                            "content": "<p>Дана система уравнений \\[ \\begin{cases} 33x_1 + 2,1x_2 + 2,8x_3 = 8 \\\\ 4,1x_1 + 37x_2 + 4,8x_3 = 57 \\\\ 2,7x_1 + 1,8x_2 + 11x_3 = 32 \\end{cases} \\].</p>"
                        },
                        {
                            "id": 4,
                            "content": "<p>Дана система уравнений \\[ \\begin{cases} 76x_1 + 5,8x_2 + 4,7x_3 = 101 \\\\ 3,8x_1 + 41x_2 + 2,7x_3 = 97 \\\\ 2,9x_1 + 2,1x_2 + 38x_3 = 78 \\end{cases} \\].</p>"
                        },
                        {
                            "id": 5,
                            "content": "<p>Дана система уравнений \\[ \\begin{cases} 32x_1 - 2,5x_2 + 3,7x_3 = 65 \\\\ 0,5x_1 + 34x_2 + 1,7x_3 = -2,4 \\\\ 1,6x_1 + 2,3x_2 - 15x_3 = 43 \\end{cases} \\].</p>"
                        },
                        {
                            "id": 6,
                            "content": "<p>Дана система уравнений \\[ \\begin{cases} 54x_1 - 2,3x_2 + 3,4x_3 = -35 \\\\ 4,2x_1 + 17x_2 - 2,3x_3 = 27 \\\\ 3,4x_1 + 2,4x_2 + 7,4x_3 = 19 \\end{cases} \\].</p>"
                        },
                        {
                            "id": 7,
                            "content": "<p>Дана система уравнений \\[ \\begin{cases} 36x_1 + 1,8x_2 - 4,7x_3 = 38 \\\\ 2,7x_1 - 36x_2 + 1,9x_3 = 4 \\\\ 1,5x_1 + 4,5x_2 + 33x_3 = -16 \\end{cases} \\].</p>"
                        },
                        {
                            "id": 8,
                            "content": "<p>Дана система уравнений \\[ \\begin{cases} 56x_1 + 2,87x_2 - 1,7x_3 = 19 \\\\ 3,4x_1 - 36x_2 - 6,7x_3 = -24 \\\\ 0,8x_1 + 1,3x_2 + 37x_3 = 12 \\end{cases} \\].</p>"
                        },
                        {
                            "id": 9,
                            "content": "<p>Дана система уравнений \\[ \\begin{cases} 27x_1 + 0,9x_2 - 1,5x_3 = 35 \\\\ 4,5x_1 - 28x_2 + 6,7x_3 = 26 \\\\ 5,1x_1 + 3,7x_2 - 14x_3 = 14 \\end{cases} \\].</p>"
                        },
                        {
                            "id": 10,
                            "content": "<p>Дана система уравнений \\[ \\begin{cases} 45x_1 - 3,5x_2 + 7,4x_3 = 25 \\\\ 3,1x_1 - 6x_2 - 2,3x_3 = -15 \\\\ 0,8x_1 + 7,4x_2 - 5x_3 = 64 \\end{cases} \\].</p>"
                        },
                        {
                            "id": 11,
                            "content": "<p>Дана система уравнений \\[ \\begin{cases} 38x_1 + 6,7x_2 - 1,2x_3 = 52 \\\\ 6,4x_1 + 13x_2 - 2,7x_3 = 38 \\\\ 2,4x_1 - 4,5x_2 + 35x_3 = -6 \\end{cases} \\].</p>"
                        },
                        {
                            "id": 12,
                            "content": "<p>Дана система уравнений \\[ \\begin{cases} 54x_1 - 6,2x_2 - 0,5x_3 = 5,2 \\\\ 3,4x_1 + 23x_2 + 0,8x_3 = -8 \\\\ 2,4x_1 - 1,1x_2 + 38x_3 = 18 \\end{cases} \\].</p>"
                        },
                        {
                            "id": 13,
                            "content": "<p>Дана система уравнений \\[ \\begin{cases} 78x_1 + 5,3x_2 + 4,8x_3 = 18 \\\\ 3,3x_1 + 11x_2 + 1,8x_3 = 23 \\\\ 4,5x_1 + 3,3x_2 + 28 = 34 \\end{cases} \\].</p>"
                        },
                        {
                            "id": 14,
                            "content": "<p>Дана система уравнений \\[ \\begin{cases} 38x_1 + 4,1x_2 - 2,3x_3 = 48 \\\\ -2,1x_1 + 39x_2 - 5,8x_3 = 33 \\\\ 1,8x_1 + 1,1x_2 - 21x_3 = 58 \\end{cases} \\].</p>"
                        },
                        {
                            "id": 15,
                            "content": "<p>Дана система уравнений \\[ \\begin{cases} 17x_1 - 2,2x_2 + 30x_3 = 18 \\\\ 2,1x_1 + 19x_2 - 2,3x_3 = 28 \\\\ 4,2x_1 + 3,9x_2 - 31x_3 = 51 \\end{cases} \\].</p>"
                        },
                        {
                            "id": 16,
                            "content": "<p>Дана система уравнений \\[ \\begin{cases} 28x_1 + 3,8x_2 - 32x_3 = 45 \\\\ 2,5x_1 - 28x_2 + 3,3x_3 = 71 \\\\ 6,5x_1 - 7,1x_2 + 48x_3 = 63 \\end{cases} \\].</p>"
                        },
                        {
                            "id": 17,
                            "content": "<p>Дана система уравнений \\[ \\begin{cases} 33x_1 + 3,7x_2 + 4,2x_3 = 58 \\\\ 2,7x_1 + 23x_2 - 29x_3 = 61 \\\\ 4,1x_1 + 4,8x_2 - 50x_3 = 70 \\end{cases} \\].</p>"
                        },
                        {
                            "id": 18,
                            "content": "<p>Дана система уравнений \\[ \\begin{cases} 71x_1 + 6,8x_2 + 6,1x_3 = 70 \\\\ 5,0x_1 + 48x_2 + 5,3x_3 = 61 \\\\ 8,2x_1 + 7,8x_2 + 71x_3 = 58 \\end{cases} \\].</p>"
                        },
                        {
                            "id": 19,
                            "content": "<p>Дана система уравнений \\[ \\begin{cases} 37x_1 + 3,1 + 4,0x_3 = 50 \\\\ 4,1x_1 + 45x_2 - 4,8x_3 = 49 \\\\ -2,1x_1 - 3,7x_2 + 18x_3 = 27 \\end{cases} \\].</p>"
                        },
                        {
                            "id": 20,
                            "content": "<p>Дана система уравнений \\[ \\begin{cases} 41x_1 + 5,2x_2 - 5,8x_3 = 70 \\\\ 3,8x_1 - 31x_2 + 4,0x_3 = 53 \\\\ 7,8x_1 + 5,3x_2 - 63x_3 = 58 \\end{cases} \\].</p>"
                        }
                ]
            }]
        };
        
        if (JSON_content.topic03.practica && JSON_content.topic03.practica.includes('"assignments":')) {
            JSON_content.topic03.practica = JSON_content.topic03.practica.split('"assignments":')[0].trim();
        }
    }


if (JSON_content.topic04 && !JSON_content.topic04.practicaData) {
        JSON_content.topic04.practicaData = {
            assignments: [{
                title: "Задание 1",
                description: `
	<p>Дана система нелинейных уравнений.</p>
    <ol>
        <li>Получить начальное приближение к решению системы двух нелинейных уравнений графическим способом.</li>
        <li>Уточнить решение системы методом Ньютона с точностью \\(0,001\\).</li>
        <li>Уточнить решение системы методом простой итерации с точностью \\(0,001\\).</li>
        <li>Вычислить погрешность методов.</li>
    </ol>
`,
                variants: [
                    {
                            "id": 1,
                            "content": "<p>Дана система уравнений \\( \\begin{cases} \\tan(xy + 0.4) = x^2 \\\\ 0.6x^2 + 2y^2 = 1, \\quad x > 0, \\quad y > 0 \\end{cases} \\).</p>"
                        },
                        {
                            "id": 2,
                            "content": "<p>Дана система уравнений \\( \\begin{cases} \\sin(x + y) - 1.6x = 0 \\\\ x^2 + y^2 = 1, \\quad x > 0, \\quad y > 0 \\end{cases} \\).</p>"
                        },
                        {
                            "id": 3,
                            "content": "<p>Дана система уравнений \\( \\begin{cases} \\tan(xy + 0.1) = x^2 \\\\ x^2 + 2y^2 = 1 \\end{cases} \\).</p>"
                        },
                        {
                            "id": 4,
                            "content": "<p>Дана система уравнений \\( \\begin{cases} (x - y)^3 + 0.4x = 0 \\\\ 1.8x^2 + 0.8y^2 = 1.1 \\end{cases} \\).</p>"
                        },
                        {
                            "id": 5,
                            "content": "<p>Дана система уравнений \\( \\begin{cases} \\sin(x + y) - 1.2x = 0.2 \\\\ x^2 + y^2 = 1 \\end{cases} \\).</p>"
                        },
                        {
                            "id": 6,
                            "content": "<p>Дана система уравнений \\( \\begin{cases} \\tan(xy + 0.3) = x^2 \\\\ 0.9x^2 + 2y^2 = 1 \\end{cases} \\).</p>"
                        },
                        {
                            "id": 7,
                            "content": "<p>Дана система уравнений \\( \\begin{cases} \\sin(x + y) - 1.3x = 0 \\\\ x^2 + y^2 = 1 \\end{cases} \\).</p>"
                        },
                        {
                            "id": 8,
                            "content": "<p>Дана система уравнений \\( \\begin{cases} \\tan(xy) = x^2 \\\\ 0.8x^2 + 2y^2 = 1 \\end{cases} \\).</p>"
                        },
                        {
                            "id": 9,
                            "content": "<p>Дана система уравнений \\( \\begin{cases} \\cos(x - y) - 0.8x = 0.3 \\\\ 2x^2 + y^2 = 1.5 \\end{cases} \\).</p>"
                        },
                        {
                            "id": 10,
                            "content": "<p>Дана система уравнений \\( \\begin{cases} e^{xy} - 2x = 0.5 \\\\ x^2 + 3y^2 = 2 \\end{cases} \\).</p>"
                        },
                        {
                            "id": 11,
                            "content": "<p>Дана система уравнений \\( \\begin{cases} \\sin(xy) = 0.7x \\\\ 0.5x^2 + 1.5y^2 = 1.2 \\end{cases} \\).</p>"
                        },
                        {
                            "id": 12,
                            "content": "<p>Дана система уравнений \\( \\begin{cases} \\ln(1 + xy) = x^2 \\\\ 1.2x^2 + 2.5y^2 = 1.8 \\end{cases} \\).</p>"
                        },
                        {
                            "id": 13,
                            "content": "<p>Дана система уравнений \\( \\begin{cases} \\arctan(x + y) = 0.5x \\\\ 1.5x^2 + y^2 = 1.1 \\end{cases} \\).</p>"
                        },
                        {
                            "id": 14,
                            "content": "<p>Дана система уравнений \\( \\begin{cases} \\sqrt{xy} - 0.6x = 0.1 \\\\ 0.8x^2 + 1.8y^2 = 1.3 \\end{cases} \\).</p>"
                        },
                        {
                            "id": 15,
                            "content": "<p>Дана система уравнений \\( \\begin{cases} (x + y)^2 - 1.4x = 0 \\\\ 1.1x^2 + 0.9y^2 = 0.8 \\end{cases} \\).</p>"
                        },
                        {
                            "id": 16,
                            "content": "<p>Дана система уравнений \\( \\begin{cases} \\sin(2x + y) - x = 0.2 \\\\ x^2 + 2.2y^2 = 1.6 \\end{cases} \\).</p>"
                        },
                        {
                            "id": 17,
                            "content": "<p>Дана система уравнений \\( \\begin{cases} \\cos(xy) + 0.3x = 0.4 \\\\ 1.4x^2 + 1.1y^2 = 1.2 \\end{cases} \\).</p>"
                        },
                        {
                            "id": 18,
                            "content": "<p>Дана система уравнений \\( \\begin{cases} e^{-xy} - 0.7x = 0.1 \\\\ 0.9x^2 + 1.7y^2 = 1.4 \\end{cases} \\).</p>"
                        },
                        {
                            "id": 19,
                            "content": "<p>Дана система уравнений \\( \\begin{cases} \\tan(2x - y) = 0.8x \\\\ 1.3x^2 + 1.6y^2 = 1.5 \\end{cases} \\).</p>"
                        },
                        {
                            "id": 20,
                            "content": "<p>Дана система уравнений \\( \\begin{cases} \\sinh(x + y) - 0.5x = 0.3 \\\\ 0.7x^2 + 2.1y^2 = 1.7 \\end{cases} \\).</p>"
                        }
                ]
            }]
        };
        
        if (JSON_content.topic04.practica && JSON_content.topic04.practica.includes('"assignments":')) {
            JSON_content.topic04.practica = JSON_content.topic04.practica.split('"assignments":')[0].trim();
        }
    }


if (JSON_content.topic05 && !JSON_content.topic05.practicaData) {
        JSON_content.topic05.practicaData = {
            assignments: [{
                title: "Задание 1",
                description: `<p>В результате эксперимента получена таблица значений. Требуется получить выражение этой зависимости в виде формулы.</p>
	
`,
                variants: [
                    {
                            "id": 1,
                            "content": ` <table align="center" border="1" cellpadding="5" cellspacing="0" style="border-collapse: collapse;">
    <tbody>
        <tr>
            <td style="border: 1px solid black;">\\(x\\)</td><td style="border: 1px solid black;">\\(1,415\\)</td><td style="border: 1px solid black;">\\(1,420\\)</td><td style="border: 1px solid black;">\\(1,425\\)</td><td style="border: 1px solid black;">\\(1,430\\)</td><td style="border: 1px solid black;">\\(1,435\\)</td><td style="border: 1px solid black;">\\(1,440\\)</td><td style="border: 1px solid black;">\\(1,445\\)</td><td style="border: 1px solid black;">\\(1,450\\)</td><td style="border: 1px solid black;">\\(1,455\\)</td><td style="border: 1px solid black;">\\(1,460\\)</td><td style="border: 1px solid black;">\\(1,465\\)</td>
        </tr>
        <tr>
            <td style="border: 1px solid black;">\\(y\\)</td><td style="border: 1px solid black;">\\(0,8886\\)</td><td style="border: 1px solid black;">\\(0,8900\\)</td><td style="border: 1px solid black;">\\(0,8906\\)</td><td style="border: 1px solid black;">\\(0,8917\\)</td><td style="border: 1px solid black;">\\(0,8927\\)</td><td style="border: 1px solid black;">\\(0,8940\\)</td><td style="border: 1px solid black;">\\(0,8947\\)</td><td style="border: 1px solid black;">\\(0,8957\\)</td><td style="border: 1px solid black;">\\(0,8967\\)</td><td style="border: 1px solid black;">\\(0,8977\\)</td><td style="border: 1px solid black;">\\(0,8986\\)</td>
        </tr>
</tbody>
</table>
			`},
                        {
                            "id": 2,
                            "content": ` <table align="center" border="1" cellpadding="5" cellspacing="0" style="border-collapse: collapse;">
    <tbody>
        <tr>
            <td style="border: 1px solid black;">\\(x\\)</td><td style="border: 1px solid black;">\\(0,101\\)</td><td style="border: 1px solid black;">\\(0,106\\)</td><td style="border: 1px solid black;">\\(0,111\\)</td><td style="border: 1px solid black;">\\(0,116\\)</td><td style="border: 1px solid black;">\\(0,121\\)</td><td style="border: 1px solid black;">\\(0,126\\)</td><td style="border: 1px solid black;">\\(0,131\\)</td><td style="border: 1px solid black;">\\(0,136\\)</td><td style="border: 1px solid black;">\\(0,141\\)</td><td style="border: 1px solid black;">\\(0,146\\)</td><td style="border: 1px solid black;">\\(0,151\\)</td>
        </tr>
        <tr>
            <td style="border: 1px solid black;">\\(y\\)</td><td style="border: 1px solid black;">\\(1,2618\\)</td><td style="border: 1px solid black;">\\(1,2764\\)</td><td style="border: 1px solid black;">\\(1,2912\\)</td><td style="border: 1px solid black;">\\(1,3061\\)</td><td style="border: 1px solid black;">\\(0,3213\\)</td><td style="border: 1px solid black;">\\(1,3366\\)</td><td style="border: 1px solid black;">\\(1,3521\\)</td><td style="border: 1px solid black;">\\(1,3677\\)</td><td style="border: 1px solid black;">\\(1,3836\\)</td><td style="border: 1px solid black;">\\(1,3995\\)</td><td style="border: 1px solid black;">\\(1,4157\\)</td>
        </tr>
</tbody>
</table>
			`},
                        {
                            "id": 3,
                            "content": ` <table align="center" border="1" cellpadding="5" cellspacing="0" style="border-collapse: collapse;">
    <tbody>
        <tr>
            <td style="border: 1px solid black;">\\(x\\)</td><td style="border: 1px solid black;">\\(0,15\\)</td><td style="border: 1px solid black;">\\(0,20\\)</td><td style="border: 1px solid black;">\\(0,25\\)</td><td style="border: 1px solid black;">\\(0,30\\)</td><td style="border: 1px solid black;">\\(0,35\\)</td><td style="border: 1px solid black;">\\(0,40\\)</td><td style="border: 1px solid black;">\\(0,45\\)</td><td style="border: 1px solid black;">\\(0,50\\)</td><td style="border: 1px solid black;">\\(0,55\\)</td><td style="border: 1px solid black;">\\(0,60\\)</td><td style="border: 1px solid black;">\\(0,65\\)</td>
        </tr>
        <tr>
            <td style="border: 1px solid black;">\\(y\\)</td><td style="border: 1px solid black;">\\(0,8607\\)</td><td style="border: 1px solid black;">\\(0,8187\\)</td><td style="border: 1px solid black;">\\(0,7788\\)</td><td style="border: 1px solid black;">\\(0,7408\\)</td><td style="border: 1px solid black;">\\(0,7046\\)</td><td style="border: 1px solid black;">\\(0,6703\\)</td><td style="border: 1px solid black;">\\(0,6376\\)</td><td style="border: 1px solid black;">\\(0,6065\\)</td><td style="border: 1px solid black;">\\(0,5769\\)</td><td style="border: 1px solid black;">\\(0,5488\\)</td><td style="border: 1px solid black;">\\(0,5220\\)</td>
        </tr>
</tbody>
</table>
			`},
                        {
                            "id": 4,
                            "content": ` <table align="center" border="1" cellpadding="5" cellspacing="0" style="border-collapse: collapse;">
    <tbody>
         <tr>
            <td style="border: 1px solid black;">\\(x\\)</td><td style="border: 1px solid black;">\\(0,180\\)</td><td style="border: 1px solid black;">\\(0,185\\)</td><td style="border: 1px solid black;">\\(0,190\\)</td><td style="border: 1px solid black;">\\(0,195\\)</td><td style="border: 1px solid black;">\\(0,200\\)</td><td style="border: 1px solid black;">\\(0,205\\)</td><td style="border: 1px solid black;">\\(0,210\\)</td><td style="border: 1px solid black;">\\(0,215\\)</td><td style="border: 1px solid black;">\\(0,220\\)</td><td style="border: 1px solid black;">\\(0,225\\)</td><td style="border: 1px solid black;">\\(0,230\\)</td>
        </tr>
        <tr>
            <td style="border: 1px solid black;">\\(y\\)</td><td style="border: 1px solid black;">\\(5,6154\\)</td><td style="border: 1px solid black;">\\(5,4669\\)</td><td style="border: 1px solid black;">\\(5,3263\\)</td><td style="border: 1px solid black;">\\(5,1930\\)</td><td style="border: 1px solid black;">\\(5,0664\\)</td><td style="border: 1px solid black;">\\(4,9461\\)</td><td style="border: 1px solid black;">\\(4,8317\\)</td><td style="border: 1px solid black;">\\(4,7226\\)</td><td style="border: 1px solid black;">\\(4,6185\\)</td><td style="border: 1px solid black;">\\(4,5191\\)</td><td style="border: 1px solid black;">\\(4,4242\\)</td>
        </tr>
</tbody>
</table>
			`},
                        {
                            "id": 5,
                            "content": ` <table align="center" border="1" cellpadding="5" cellspacing="0" style="border-collapse: collapse;">
    <tbody>
         <tr>
            <td style="border: 1px solid black;">\\(x\\)</td><td style="border: 1px solid black;">\\(3,50\\)</td><td style="border: 1px solid black;">\\(3,55\\)</td><td style="border: 1px solid black;">\\(3,60\\)</td><td style="border: 1px solid black;">\\(3,65\\)</td><td style="border: 1px solid black;">\\(3,70\\)</td><td style="border: 1px solid black;">\\(3,75\\)</td><td style="border: 1px solid black;">\\(3,80\\)</td><td style="border: 1px solid black;">\\(3,85\\)</td><td style="border: 1px solid black;">\\(3,90\\)</td><td style="border: 1px solid black;">\\(3,95\\)</td><td style="border: 1px solid black;">\\(4,00\\)</td>
        </tr>
        <tr>
            <td style="border: 1px solid black;">\\(y\\)</td><td style="border: 1px solid black;">\\(33,115\\)</td><td style="border: 1px solid black;">\\(34,813\\)</td><td style="border: 1px solid black;">\\(36,598\\)</td><td style="border: 1px solid black;">\\(38,474\\)</td><td style="border: 1px solid black;">\\(40,447\\)</td><td style="border: 1px solid black;">\\(42,521\\)</td><td style="border: 1px solid black;">\\(44,701\\)</td><td style="border: 1px solid black;">\\(46,993\\)</td><td style="border: 1px solid black;">\\(49,402\\)</td><td style="border: 1px solid black;">\\(51,935\\)</td><td style="border: 1px solid black;">\\(54,598\\)</td>
        </tr>
</tbody>
</table>
			`},
                        {
                            "id": 6,
                            "content": ` <table align="center" border="1" cellpadding="5" cellspacing="0" style="border-collapse: collapse;">
    <tbody>
        <tr>
            <td style="border: 1px solid black;">\\(x\\)</td><td style="border: 1px solid black;">\\(0,115\\)</td><td style="border: 1px solid black;">\\(0,120\\)</td><td style="border: 1px solid black;">\\(0,125\\)</td><td style="border: 1px solid black;">\\(0,130\\)</td><td style="border: 1px solid black;">\\(0,135\\)</td><td style="border: 1px solid black;">\\(0,140\\)</td><td style="border: 1px solid black;">\\(0,145\\)</td><td style="border: 1px solid black;">\\(0,150\\)</td><td style="border: 1px solid black;">\\(0,155\\)</td><td style="border: 1px solid black;">\\(0,160\\)</td><td style="border: 1px solid black;">\\(0,165\\)</td>
        </tr>
        <tr>
            <td style="border: 1px solid black;">\\(y\\)</td><td style="border: 1px solid black;">\\(8,6572\\)</td><td style="border: 1px solid black;">\\(8,2932\\)</td><td style="border: 1px solid black;">\\(7,9582\\)</td><td style="border: 1px solid black;">\\(7,6489\\)</td><td style="border: 1px solid black;">\\(7,3623\\)</td><td style="border: 1px solid black;">\\(7,0961\\)</td><td style="border: 1px solid black;">\\(6,8481\\)</td><td style="border: 1px solid black;">\\(6,6165\\)</td><td style="border: 1px solid black;">\\(6,3998\\)</td><td style="border: 1px solid black;">\\(6,1965\\)</td><td style="border: 1px solid black;">\\(6,0055\\)</td>
        </tr>
</tbody>
</table>
			`},
                        {
                            "id": 7,
                            "content": ` <table align="center" border="1" cellpadding="5" cellspacing="0" style="border-collapse: collapse;">
    <tbody>
         <tr>
            <td style="border: 1px solid black;">\\(x\\)</td><td style="border: 1px solid black;">\\(1,340\\)</td><td style="border: 1px solid black;">\\(1,345\\)</td><td style="border: 1px solid black;">\\(1,350\\)</td><td style="border: 1px solid black;">\\(1,355\\)</td><td style="border: 1px solid black;">\\(1,360\\)</td><td style="border: 1px solid black;">\\(1,365\\)</td><td style="border: 1px solid black;">\\(1,370\\)</td><td style="border: 1px solid black;">\\(1,375\\)</td><td style="border: 1px solid black;">\\(1,380\\)</td><td style="border: 1px solid black;">\\(1,385\\)</td><td style="border: 1px solid black;">\\(1,390\\)</td>
        </tr>
        <tr>
            <td style="border: 1px solid black;">\\(y\\)</td><td style="border: 1px solid black;">\\(4,2556\\)</td><td style="border: 1px solid black;">\\(4,3532\\)</td><td style="border: 1px solid black;">\\(4,4552\\)</td><td style="border: 1px solid black;">\\(4,5618\\)</td><td style="border: 1px solid black;">\\(4,6734\\)</td><td style="border: 1px solid black;">\\(4,7903\\)</td><td style="border: 1px solid black;">\\(4,9130\\)</td><td style="border: 1px solid black;">\\(5,0419\\)</td><td style="border: 1px solid black;">\\(5,1774\\)</td><td style="border: 1px solid black;">\\(5,3201\\)</td><td style="border: 1px solid black;">\\(5,4706\\)</td>
        </tr>
</tbody>
</table>
			`},
                        {
                            "id": 8,
                            "content": ` <table align="center" border="1" cellpadding="5" cellspacing="0" style="border-collapse: collapse;">
    <tbody>
         <tr>
            <td style="border: 1px solid black;">\\(x\\)</td><td style="border: 1px solid black;">\\(0,01\\)</td><td style="border: 1px solid black;">\\(0,06\\)</td><td style="border: 1px solid black;">\\(0,11\\)</td><td style="border: 1px solid black;">\\(0,16\\)</td><td style="border: 1px solid black;">\\(0,21\\)</td><td style="border: 1px solid black;">\\(0,26\\)</td><td style="border: 1px solid black;">\\(0,31\\)</td><td style="border: 1px solid black;">\\(0,36\\)</td><td style="border: 1px solid black;">\\(0,41\\)</td><td style="border: 1px solid black;">\\(0,46\\)</td><td style="border: 1px solid black;">\\(0,51\\)</td>
        </tr>
        <tr>
            <td style="border: 1px solid black;">\\(y\\)</td><td style="border: 1px solid black;">\\(0,9918\\)</td><td style="border: 1px solid black;">\\(0,9519\\)</td><td style="border: 1px solid black;">\\(0,9136\\)</td><td style="border: 1px solid black;">\\(0,8769\\)</td><td style="border: 1px solid black;">\\(0,8416\\)</td><td style="border: 1px solid black;">\\(0,8077\\)</td><td style="border: 1px solid black;">\\(0,7753\\)</td><td style="border: 1px solid black;">\\(0,7441\\)</td><td style="border: 1px solid black;">\\(0,7141\\)</td><td style="border: 1px solid black;">\\(0,6854\\)</td><td style="border: 1px solid black;">\\(0,6579\\)</td>
        </tr>
</tbody>
</table>
			`},
                        {
                            "id": 9,
                            "content": ` <table align="center" border="1" cellpadding="5" cellspacing="0" style="border-collapse: collapse;">
    <tbody>
        <tr>
            <td style="border: 1px solid black;">\\(x\\)</td><td style="border: 1px solid black;">\\(0,15\\)</td><td style="border: 1px solid black;">\\(0,16\\)</td><td style="border: 1px solid black;">\\(0,17\\)</td><td style="border: 1px solid black;">\\(0,18\\)</td><td style="border: 1px solid black;">\\(0,19\\)</td><td style="border: 1px solid black;">\\(0,20\\)</td><td style="border: 1px solid black;">\\(0,21\\)</td><td style="border: 1px solid black;">\\(0,22\\)</td><td style="border: 1px solid black;">\\(0,23\\)</td><td style="border: 1px solid black;">\\(0,24\\)</td><td style="border: 1px solid black;">\\(0,25\\)</td>
        </tr>
        <tr>
            <td style="border: 1px solid black;">\\(y\\)</td><td style="border: 1px solid black;">\\(4,481\\)</td><td style="border: 1px solid black;">\\(4,953\\)</td><td style="border: 1px solid black;">\\(5,473\\)</td><td style="border: 1px solid black;">\\(6,049\\)</td><td style="border: 1px solid black;">\\(6,685\\)</td><td style="border: 1px solid black;">\\(7,389\\)</td><td style="border: 1px solid black;">\\(8,166\\)</td><td style="border: 1px solid black;">\\(9,025\\)</td><td style="border: 1px solid black;">\\(9,974\\)</td><td style="border: 1px solid black;">\\(11,023\\)</td><td style="border: 1px solid black;">\\(12,182\\)</td>
        </tr>
</tbody>
</table>
			`},
                        {
                            "id": 10,
                            "content": ` <table align="center" border="1" cellpadding="5" cellspacing="0" style="border-collapse: collapse;">
    <tbody>
        <tr>
            <td style="border: 1px solid black;">\\(x\\)</td><td style="border: 1px solid black;">\\(0,45\\)</td><td style="border: 1px solid black;">\\(0,46\\)</td><td style="border: 1px solid black;">\\(0,47\\)</td><td style="border: 1px solid black;">\\(0,48\\)</td><td style="border: 1px solid black;">\\(0,49\\)</td><td style="border: 1px solid black;">\\(0,50\\)</td><td style="border: 1px solid black;">\\(0,51\\)</td><td style="border: 1px solid black;">\\(0,52\\)</td><td style="border: 1px solid black;">\\(0,53\\)</td><td style="border: 1px solid black;">\\(0,54\\)</td><td style="border: 1px solid black;">\\(0,55\\)</td>
        </tr>
        <tr>
            <td style="border: 1px solid black;">\\(y\\)</td><td style="border: 1px solid black;">\\(20,194\\)</td><td style="border: 1px solid black;">\\(19,613\\)</td><td style="border: 1px solid black;">\\(18,942\\)</td><td style="border: 1px solid black;">\\(18,174\\)</td><td style="border: 1px solid black;">\\(17,301\\)</td><td style="border: 1px solid black;">\\(16,312\\)</td><td style="border: 1px solid black;">\\(15,198\\)</td><td style="border: 1px solid black;">\\(13,948\\)</td><td style="border: 1px solid black;">\\(12,550\\)</td><td style="border: 1px solid black;">\\(10,993\\)</td><td style="border: 1px solid black;">\\(9,264\\)</td>
        </tr>
</tbody>
</table>
			`},
                        {
                            "id": 11,
                            "content": ` <table align="center" border="1" cellpadding="5" cellspacing="0" style="border-collapse: collapse;">
    <tbody>
        <tr>
            <td style="border: 1px solid black;">\\(x\\)</td><td style="border: 1px solid black;">\\(1,345\\)</td><td style="border: 1px solid black;">\\(1,350\\)</td><td style="border: 1px solid black;">\\(1,355\\)</td><td style="border: 1px solid black;">\\(1,360\\)</td><td style="border: 1px solid black;">\\(1,365\\)</td><td style="border: 1px solid black;">\\(1,370\\)</td><td style="border: 1px solid black;">\\(1,375\\)</td><td style="border: 1px solid black;">\\(1,380\\)</td><td style="border: 1px solid black;">\\(1,385\\)</td><td style="border: 1px solid black;">\\(1,390\\)</td><td style="border: 1px solid black;">\\(1,395\\)</td>
        </tr>
        <tr>
            <td style="border: 1px solid black;">\\(y\\)</td><td style="border: 1px solid black;">\\(4,3532\\)</td><td style="border: 1px solid black;">\\(4,4552\\)</td><td style="border: 1px solid black;">\\(4,5618\\)</td><td style="border: 1px solid black;">\\(4,6734\\)</td><td style="border: 1px solid black;">\\(4,7903\\)</td><td style="border: 1px solid black;">\\(4,9130\\)</td><td style="border: 1px solid black;">\\(5,0419\\)</td><td style="border: 1px solid black;">\\(5,1774\\)</td><td style="border: 1px solid black;">\\(5,3201\\)</td><td style="border: 1px solid black;">\\(5,4706\\)</td><td style="border: 1px solid black;">\\(5,6296\\)</td>
        </tr>
</tbody>
</table>
			`},
                        {
                            "id": 12,
                            "content": ` <table align="center" border="1" cellpadding="5" cellspacing="0" style="border-collapse: collapse;">
    <tbody>
        <tr>
            <td style="border: 1px solid black;">\\(x\\)</td><td style="border: 1px solid black;">\\(0,130\\)</td><td style="border: 1px solid black;">\\(0,135\\)</td><td style="border: 1px solid black;">\\(0,140\\)</td><td style="border: 1px solid black;">\\(0,145\\)</td><td style="border: 1px solid black;">\\(0,150\\)</td><td style="border: 1px solid black;">\\(0,155\\)</td><td style="border: 1px solid black;">\\(0,160\\)</td><td style="border: 1px solid black;">\\(0,165\\)</td><td style="border: 1px solid black;">\\(0,170\\)</td><td style="border: 1px solid black;">\\(0,175\\)</td><td style="border: 1px solid black;">\\(0,180\\)</td>
        </tr>
        <tr>
            <td style="border: 1px solid black;">\\(y\\)</td><td style="border: 1px solid black;">\\(7,6489\\)</td><td style="border: 1px solid black;">\\(7,3623\\)</td><td style="border: 1px solid black;">\\(7,0961\\)</td><td style="border: 1px solid black;">\\(6,8481\\)</td><td style="border: 1px solid black;">\\(6,6165\\)</td><td style="border: 1px solid black;">\\(6,3998\\)</td><td style="border: 1px solid black;">\\(6,1965\\)</td><td style="border: 1px solid black;">\\(6,0055\\)</td><td style="border: 1px solid black;">\\(5,8255\\)</td><td style="border: 1px solid black;">\\(5,6558\\)</td><td style="border: 1px solid black;">\\(5,4954\\)</td>
        </tr>
</tbody>
</table>
			`},
                        {
                            "id": 13,
                            "content": ` <table align="center" border="1" cellpadding="5" cellspacing="0" style="border-collapse: collapse;">
    <tbody>
        <tr>
            <td style="border: 1px solid black;">\\(x\\)</td><td style="border: 1px solid black;">\\(0,70\\)</td><td style="border: 1px solid black;">\\(0,75\\)</td><td style="border: 1px solid black;">\\(0,80\\)</td><td style="border: 1px solid black;">\\(0,85\\)</td><td style="border: 1px solid black;">\\(0,90\\)</td><td style="border: 1px solid black;">\\(0,95\\)</td><td style="border: 1px solid black;">\\(1,00\\)</td><td style="border: 1px solid black;">\\(1,05\\)</td><td style="border: 1px solid black;">\\(1,10\\)</td><td style="border: 1px solid black;">\\(1,15\\)</td><td style="border: 1px solid black;">\\(1,20\\)</td>
        </tr>
        <tr>
            <td style="border: 1px solid black;">\\(y\\)</td><td style="border: 1px solid black;">\\(0,4966\\)</td><td style="border: 1px solid black;">\\(0,4724\\)</td><td style="border: 1px solid black;">\\(0,4493\\)</td><td style="border: 1px solid black;">\\(0,4274\\)</td><td style="border: 1px solid black;">\\(0,4066\\)</td><td style="border: 1px solid black;">\\(0,3867\\)</td><td style="border: 1px solid black;">\\(0,3679\\)</td><td style="border: 1px solid black;">\\(0,3500\\)</td><td style="border: 1px solid black;">\\(0,3329\\)</td><td style="border: 1px solid black;">\\(0,3166\\)</td><td style="border: 1px solid black;">\\(0,3012\\)</td>
        </tr>
</tbody>
</table>
			`},
                        {
                            "id": 14,
                            "content": ` <table align="center" border="1" cellpadding="5" cellspacing="0" style="border-collapse: collapse;">
    <tbody>
        <tr>
            <td style="border: 1px solid black;">\\(x\\)</td><td style="border: 1px solid black;">\\(2,00\\)</td><td style="border: 1px solid black;">\\(2,05\\)</td><td style="border: 1px solid black;">\\(2,10\\)</td><td style="border: 1px solid black;">\\(2,15\\)</td><td style="border: 1px solid black;">\\(2,20\\)</td><td style="border: 1px solid black;">\\(2,25\\)</td><td style="border: 1px solid black;">\\(2,30\\)</td><td style="border: 1px solid black;">\\(2,35\\)</td><td style="border: 1px solid black;">\\(2,40\\)</td><td style="border: 1px solid black;">\\(2,45\\)</td><td style="border: 1px solid black;">\\(2,50\\)</td>
        </tr>
        <tr>
            <td style="border: 1px solid black;">\\(y\\)</td><td style="border: 1px solid black;">\\(7,3891\\)</td><td style="border: 1px solid black;">\\(7,7679\\)</td><td style="border: 1px solid black;">\\(8,1662\\)</td><td style="border: 1px solid black;">\\(8,5849\\)</td><td style="border: 1px solid black;">\\(9,0250\\)</td><td style="border: 1px solid black;">\\(9,4877\\)</td><td style="border: 1px solid black;">\\(9,9742\\)</td><td style="border: 1px solid black;">\\(10,486\\)</td><td style="border: 1px solid black;">\\(11,023\\)</td><td style="border: 1px solid black;">\\(11,588</td><td style="border: 1px solid black;">\\(12,182\\)</td>
        </tr>
</tbody>
</table>
			`},
                        {
                            "id": 15,
                            "content": ` <table align="center" border="1" cellpadding="5" cellspacing="0" style="border-collapse: collapse;">
    <tbody>
         <tr>
            <td style="border: 1px solid black;">\\(x\\)</td><td style="border: 1px solid black;">\\(0,85\\)</td><td style="border: 1px solid black;">\\(0,90\\)</td><td style="border: 1px solid black;">\\(0,95\\)</td><td style="border: 1px solid black;">\\(1,00\\)</td><td style="border: 1px solid black;">\\(1,05\\)</td><td style="border: 1px solid black;">\\(1,10\\)</td><td style="border: 1px solid black;">\\(1,15\\)</td><td style="border: 1px solid black;">\\(1,20\\)</td><td style="border: 1px solid black;">\\(1,25\\)</td><td style="border: 1px solid black;">\\(1,30\\)</td><td style="border: 1px solid black;">\\(1,35\\)</td>
        </tr>
        <tr>
            <td style="border: 1px solid black;">\\(y\\)</td><td style="border: 1px solid black;">\\(2,3396\\)</td><td style="border: 1px solid black;">\\(2,4596\\)</td><td style="border: 1px solid black;">\\(2,5857\\)</td><td style="border: 1px solid black;">\\(2,7183\\)</td><td style="border: 1px solid black;">\\(2,8577\\)</td><td style="border: 1px solid black;">\\(3,0042\\)</td><td style="border: 1px solid black;">\\(3,1582\\)</td><td style="border: 1px solid black;">\\(3,3201\\)</td><td style="border: 1px solid black;">\\(3,4903\\)</td><td style="border: 1px solid black;">\\(3,6693\\)</td><td style="border: 1px solid black;">\\(3,8574\\)</td>
        </tr>
</tbody>
</table>
			`},
                        {
                            "id": 16,
                            "content": ` <table align="center" border="1" cellpadding="5" cellspacing="0" style="border-collapse: collapse;">
    <tbody>
        <tr>
            <td style="border: 1px solid black;">\\(x\\)</td><td style="border: 1px solid black;">\\(1,60\\)</td><td style="border: 1px solid black;">\\(1,65\\)</td><td style="border: 1px solid black;">\\(1,70\\)</td><td style="border: 1px solid black;">\\(1,75\\)</td><td style="border: 1px solid black;">\\(1,80\\)</td><td style="border: 1px solid black;">\\(1,85\\)</td><td style="border: 1px solid black;">\\(1,90\\)</td><td style="border: 1px solid black;">\\(1,95\\)</td><td style="border: 1px solid black;">\\(2,00\\)</td><td style="border: 1px solid black;">\\(2,05\\)</td><td style="border: 1px solid black;">\\(2,10\\)</td>
        </tr>
        <tr>
            <td style="border: 1px solid black;">\\(y\\)</td><td style="border: 1px solid black;">\\(4,9530\\)</td><td style="border: 1px solid black;">\\(5,2060\\)</td><td style="border: 1px solid black;">\\(5,4739\\)</td><td style="border: 1px solid black;">\\(5,7546\\)</td><td style="border: 1px solid black;">\\(6,0496\\)</td><td style="border: 1px solid black;">\\(6,3598\\)</td><td style="border: 1px solid black;">\\(6,6859\\)</td><td style="border: 1px solid black;">\\(7,0287\\)</td><td style="border: 1px solid black;">\\(7,3891\\)</td><td style="border: 1px solid black;">\\(7,7679\\)</td><td style="border: 1px solid black;">\\(8,1662\\)</td>
        </tr>
</tbody>
</table>
			`},
                        {
                            "id": 17,
                            "content": ` <table align="center" border="1" cellpadding="5" cellspacing="0" style="border-collapse: collapse;">
    <tbody>
        <tr>
            <td style="border: 1px solid black;">\\(x\\)</td><td style="border: 1px solid black;">\\(0,30\\)</td><td style="border: 1px solid black;">\\(0,35\\)</td><td style="border: 1px solid black;">\\(0,40\\)</td><td style="border: 1px solid black;">\\(0,45\\)</td><td style="border: 1px solid black;">\\(0,50\\)</td><td style="border: 1px solid black;">\\(0,55\\)</td><td style="border: 1px solid black;">\\(0,60\\)</td><td style="border: 1px solid black;">\\(0,65\\)</td><td style="border: 1px solid black;">\\(0,70\\)</td><td style="border: 1px solid black;">\\(0,75\\)</td><td style="border: 1px solid black;">\\(0,80\\)</td>
        </tr>
        <tr>
            <td style="border: 1px solid black;">\\(y\\)</td><td style="border: 1px solid black;">\\(1,3499\\)</td><td style="border: 1px solid black;">\\(1,4191\\)</td><td style="border: 1px solid black;">\\(1,4918\\)</td><td style="border: 1px solid black;">\\(1,5683\\)</td><td style="border: 1px solid black;">\\(1,6487\\)</td><td style="border: 1px solid black;">\\(1,7333\\)</td><td style="border: 1px solid black;">\\(1,8221\\)</td><td style="border: 1px solid black;">\\(1,9155\\)</td><td style="border: 1px solid black;">\\(2,0138\\)</td><td style="border: 1px solid black;">\\(2,1170\\)</td><td style="border: 1px solid black;">\\(2,2255\\)</td>
        </tr>
</tbody>
</table>
			`},
                        {
                            "id": 18,
                            "content": ` <table align="center" border="1" cellpadding="5" cellspacing="0" style="border-collapse: collapse;">
    <tbody>
        <tr>
            <td style="border: 1px solid black;">\\(x\\)</td><td style="border: 1px solid black;">\\(1,00\\)</td><td style="border: 1px solid black;">\\(1,05\\)</td><td style="border: 1px solid black;">\\(1,10\\)</td><td style="border: 1px solid black;">\\(1,15\\)</td><td style="border: 1px solid black;">\\(1,20\\)</td><td style="border: 1px solid black;">\\(1,25\\)</td><td style="border: 1px solid black;">\\(1,30\\)</td><td style="border: 1px solid black;">\\(1,35\\)</td><td style="border: 1px solid black;">\\(1,40\\)</td><td style="border: 1px solid black;">\\(1,45\\)</td><td style="border: 1px solid black;">\\(1,50\\)</td>
        </tr>
        <tr>
            <td style="border: 1px solid black;">\\(y\\)</td><td style="border: 1px solid black;">\\(0,3679\\)</td><td style="border: 1px solid black;">\\(0,3500\\)</td><td style="border: 1px solid black;">\\(0,3329\\)</td><td style="border: 1px solid black;">\\(0,3166\\)</td><td style="border: 1px solid black;">\\(0,3012\\)</td><td style="border: 1px solid black;">\\(0,2865\\)</td><td style="border: 1px solid black;">\\(0,2725\\)</td><td style="border: 1px solid black;">\\(0,2592\\)</td><td style="border: 1px solid black;">\\(0,2466\\)</td><td style="border: 1px solid black;">\\(0,2346\\)</td><td style="border: 1px solid black;">\\(0,2231\\)</td>
        </tr>
</tbody>
</table>
			`},
                        {
                            "id": 19,
                            "content": ` <table align="center" border="1" cellpadding="5" cellspacing="0" style="border-collapse: collapse;">
    <tbody>
        <tr>
            <td style="border: 1px solid black;">\\(x\\)</td><td style="border: 1px solid black;">\\(0,55\\)</td><td style="border: 1px solid black;">\\(0,60\\)</td><td style="border: 1px solid black;">\\(0,65\\)</td><td style="border: 1px solid black;">\\(0,70\\)</td><td style="border: 1px solid black;">\\(0,75\\)</td><td style="border: 1px solid black;">\\(0,80\\)</td><td style="border: 1px solid black;">\\(0,85\\)</td><td style="border: 1px solid black;">\\(0,90\\)</td><td style="border: 1px solid black;">\\(0,95\\)</td><td style="border: 1px solid black;">\\(1,00\\)</td><td style="border: 1px solid black;">\\(1,05\\)</td>
        </tr>
        <tr>
            <td style="border: 1px solid black;">\\(y\\)</td><td style="border: 1px solid black;">\\(1,7333\\)</td><td style="border: 1px solid black;">\\(1,8221\\)</td><td style="border: 1px solid black;">\\(1,9155\\)</td><td style="border: 1px solid black;">\\(2,0138\\)</td><td style="border: 1px solid black;">\\(2,1170\\)</td><td style="border: 1px solid black;">\\(2,2255\\)</td><td style="border: 1px solid black;">\\(2,3396\\)</td><td style="border: 1px solid black;">\\(2,4596\\)</td><td style="border: 1px solid black;">\\(2,5857\\)</td><td style="border: 1px solid black;">\\(2,7183\\)</td><td style="border: 1px solid black;">\\(2,8577\\)</td>
        </tr>
</tbody>
</table>
			`},
                        {
                            "id": 20,
                            "content": ` <table align="center" border="1" cellpadding="5" cellspacing="0" style="border-collapse: collapse;">
    <tbody>
        <tr>
            <td style="border: 1px solid black;">\\(x\\)</td><td style="border: 1px solid black;">\\(2,20\\)</td><td style="border: 1px solid black;">\\(2,25\\)</td><td style="border: 1px solid black;">\\(2,30\\)</td><td style="border: 1px solid black;">\\(2,35\\)</td><td style="border: 1px solid black;">\\(2,40\\)</td><td style="border: 1px solid black;">\\(2,45\\)</td><td style="border: 1px solid black;">\\(2,50\\)</td><td style="border: 1px solid black;">\\(2,55\\)</td><td style="border: 1px solid black;">\\(2,60\\)</td><td style="border: 1px solid black;">\\(2,65\\)</td><td style="border: 1px solid black;">\\(2,70\\)</td>
        </tr>
        <tr>
            <td style="border: 1px solid black;">\\(y\\)</td><td style="border: 1px solid black;">\\(9,0250\\)</td><td style="border: 1px solid black;">\\(9,4877\\)</td><td style="border: 1px solid black;">\\(9,9742\\)</td><td style="border: 1px solid black;">\\(10,486\\)</td><td style="border: 1px solid black;">\\(11,023\\)</td><td style="border: 1px solid black;">\\(11,588\\)</td><td style="border: 1px solid black;">\\(12,182\\)</td><td style="border: 1px solid black;">\\(12,807\\)</td><td style="border: 1px solid black;">\\(13,464\\)</td><td style="border: 1px solid black;">\\(14,154\\)</td><td style="border: 1px solid black;">\\(14,880\\)</td>
        </tr>
</tbody>
</table>
			`}
                ]
            }]
        };
        
        if (JSON_content.topic05.practica && JSON_content.topic05.practica.includes('"assignments":')) {
            JSON_content.topic05.practica = JSON_content.topic05.practica.split('"assignments":')[0].trim();
        }
    }


if (JSON_content.topic06 && !JSON_content.topic06.practicaData) {
        JSON_content.topic06.practicaData = {
            assignments: [{
                title: "Задание 1",
                description: ``,
                variants: [
    {
        "id": 1,
        "content": ` <p>Функция \\(y = f(x)\\) задана таблицей. Найти значения функции в точках \\(x_1 = 1,5223\\) и \\(x_2 = 1,5241\\), используя линейную, квадратичную и полиномиальную 
интерполяцию. Вычислить погрешность. </p>
<table align="center" border="1" cellpadding="5" cellspacing="0" style="border-collapse: collapse;">
    <tbody>
        <tr>
    <td style="border: 1px solid black;">\\(x\\)</td><td style="border: 1px solid black;">\\(1,520\\)</td><td style="border: 1px solid black;">\\(1,521\\)</td><td style="border: 1px solid black;">\\(1,522\\)</td><td style="border: 1px solid black;">\\(1,523\\)</td><td style="border: 1px solid black;">\\(1,524\\)</td><td style="border: 1px solid black;">\\(1,525\\)</td><td style="border: 1px solid black;">\\(1,526\\)</td><td style="border: 1px solid black;">\\(1,527\\)</td>
</tr>
<tr>
    <td style="border: 1px solid black;">\\(y\\)</td><td style="border: 1px solid black;">\\(19,670\\)</td><td style="border: 1px solid black;">\\(20,065\\)</td><td style="border: 1px solid black;">\\(20,447\\)</td><td style="border: 1px solid black;">\\(20,906\\)</td><td style="border: 1px solid black;">\\(21,354\\)</td><td style="border: 1px solid black;">\\(21,821\\)</td><td style="border: 1px solid black;">\\(22,308\\)</td><td style="border: 1px solid black;">\\(22,818\\)</td>
</tr>
</tbody>
</table>
        `
    },
    {
        "id": 2,
        "content": ` <p>Функция \\(y = f(x)\\)  задана таблицей. Найти значения функции в точках \\(x_1 = 0,44030\\) и \\(x_2 = 0,54090\\), используя линейную, квадратичную и полиномиальную интерполяцию. Вычислить 
погрешность. </p>
<table align="center" border="1" cellpadding="5" cellspacing="0" style="border-collapse: collapse;">
    <tbody>
        <tr>
    <td style="border: 1px solid black;">\\(x\\)</td><td style="border: 1px solid black;">\\(0,35\\)</td><td style="border: 1px solid black;">\\(0,41\\)</td><td style="border: 1px solid black;">\\(0,47\\)</td><td style="border: 1px solid black;">\\(0,51\\)</td><td style="border: 1px solid black;">\\(0,56\\)</td><td style="border: 1px solid black;">\\(0,64\\)</td>
</tr>
<tr>
    <td style="border: 1px solid black;">\\(y\\)</td><td style="border: 1px solid black;">\\(2,73951\\)</td><td style="border: 1px solid black;">\\(2,90080\\)</td><td style="border: 1px solid black;">\\(1,96864\\)</td><td style="border: 1px solid black;">\\(1,78776\\)</td><td style="border: 1px solid black;">\\(1,59502\\)</td><td style="border: 1px solid black;">\\(1,34310\\)</td>
</tr>
</tbody>
</table>
        `
    },
    {
        "id": 3,
        "content": ` <p>Дана таблица значений функции \\(y = e^x\\). Найти значения функции в точках \\(x_1 = 0,507\\) и \\(x_2 = 0,541\\), используя линейную, квадратичную и полиномиальную интерполяцию. 
Вычислить погрешность. </p>
<table align="center" border="1" cellpadding="5" cellspacing="0" style="border-collapse: collapse;">
    <tbody>
       <tr>
    <td style="border: 1px solid black;">\\(x\\)</td><td style="border: 1px solid black;">\\(0,50\\)</td><td style="border: 1px solid black;">\\(0,51\\)</td><td style="border: 1px solid black;">\\(0,52\\)</td><td style="border: 1px solid black;">\\(0,53\\)</td><td style="border: 1px solid black;">\\(0,54\\)</td><td style="border: 1px solid black;">\\(0,55\\)</td><td style="border: 1px solid black;">\\(0,56\\)</td><td style="border: 1px solid black;">\\(0,57\\)</td>
</tr>
<tr>
    <td style="border: 1px solid black;">\\(y\\)</td><td style="border: 1px solid black;">\\(1,6487\\)</td><td style="border: 1px solid black;">\\(1,6653\\)</td><td style="border: 1px solid black;">\\(1,6820\\)</td><td style="border: 1px solid black;">\\(1,6989\\)</td><td style="border: 1px solid black;">\\(1,7160\\)</td><td style="border: 1px solid black;">\\(1,7333\\)</td><td style="border: 1px solid black;">\\(1,7507\\)</td><td style="border: 1px solid black;">\\(1,7683\\)</td>
</tr>
</tbody>
</table>
        `
    },
    {
        "id": 4,
        "content": ` <p>Дана таблица значений функции \\(y = \\sin x\\). Найти значения функции в точках \\(x_1 = 1,151\\) и \\(x_2 = 1,609\\), используя линейную, квадратичную и полиномиальную интерполяцию. 
Вычислить погрешность.</p>
<table align="center" border="1" cellpadding="5" cellspacing="0" style="border-collapse: collapse;">
    <tbody>
        <tr>
    <td style="border: 1px solid black;">\\(x\\)</td><td style="border: 1px solid black;">\\(1,1\\)</td><td style="border: 1px solid black;">\\(1,2\\)</td><td style="border: 1px solid black;">\\(1,3\\)</td><td style="border: 1px solid black;">\\(1,4\\)</td><td style="border: 1px solid black;">\\(1,5\\)</td><td style="border: 1px solid black;">\\(1,6\\)</td><td style="border: 1px solid black;">\\(1,7\\)</td><td style="border: 1px solid black;">\\(1,8\\)</td>
</tr>
<tr>
    <td style="border: 1px solid black;">\\(y\\)</td><td style="border: 1px solid black;">\\(0,8912\\)</td><td style="border: 1px solid black;">\\(0,9320\\)</td><td style="border: 1px solid black;">\\(0,9635\\)</td><td style="border: 1px solid black;">\\(0,9854\\)</td><td style="border: 1px solid black;">\\(0,9974\\)</td><td style="border: 1px solid black;">\\(0,9995\\)</td><td style="border: 1px solid black;">\\(0,9916\\)</td><td style="border: 1px solid black;">\\(0,9738\\)</td>
</tr>
</tbody>
</table>
        `
    },
    {
        "id": 5,
        "content": ` <p>Функция \\(y = f(x)\\)  задана таблицей. Найти значения функции в точках \\(x_1 = 0,107\\) и \\(x_2 = 0,133\\), используя линейную, квадратичную и полиномиальную интерполяцию. 
Вычислить погрешность. </p>
<table align="center" border="1" cellpadding="5" cellspacing="0" style="border-collapse: collapse;">
    <tbody>
        <tr>
    <td style="border: 1px solid black;">\\(x\\)</td><td style="border: 1px solid black;">\\(0,101\\)</td><td style="border: 1px solid black;">\\(0,106\\)</td><td style="border: 1px solid black;">\\(0,111\\)</td><td style="border: 1px solid black;">\\(0,116\\)</td><td style="border: 1px solid black;">\\(0,121\\)</td><td style="border: 1px solid black;">\\(0,126\\)</td><td style="border: 1px solid black;">\\(0,131\\)</td><td style="border: 1px solid black;">\\(0,136\\)</td>
</tr>
<tr>
    <td style="border: 1px solid black;">\\(y\\)</td><td style="border: 1px solid black;">\\(1,26183\\)</td><td style="border: 1px solid black;">\\(1,27644\\)</td><td style="border: 1px solid black;">\\(1,29122\\)</td><td style="border: 1px solid black;">\\(1,30617\\)</td><td style="border: 1px solid black;">\\(1,32130\\)</td><td style="border: 1px solid black;">\\(1,33660\\)</td><td style="border: 1px solid black;">\\(1,35207\\)</td><td style="border: 1px solid black;">\\(1,36773\\)</td>
</tr>
</tbody>
</table>
        `
    },
    {
        "id": 6,
        "content": ` <p>Дана таблица натуральных логарифмов чисел от \\(1\\) до \\(10\\) с шагом \\(0,5\\). Найти значения функции в точках \\(x_1 = 2,2\\) и \\(x_2 = 4,80\\), используя линейную, квадратичную и полиномиальную 
интерполяцию. Вычислить погрешность.</p>
<table align="center" border="1" cellpadding="5" cellspacing="0" style="border-collapse: collapse;">
    <tbody>
        <tr>
    <td style="border: 1px solid black;">\\(x\\)</td><td style="border: 1px solid black;">\\(1,0\\)</td><td style="border: 1px solid black;">\\(1,5\\)</td><td style="border: 1px solid black;">\\(2,0\\)</td><td style="border: 1px solid black;">\\(2,5\\)</td><td style="border: 1px solid black;">\\(3,0\\)</td><td style="border: 1px solid black;">\\(3,5\\)</td><td style="border: 1px solid black;">\\(4,0\\)</td><td style="border: 1px solid black;">\\(4,5\\)</td><td style="border: 1px solid black;">\\(5,0\\)</td>
</tr>
<tr>
    <td style="border: 1px solid black;">\\(y\\)</td><td style="border: 1px solid black;">\\(0,0000\\)</td><td style="border: 1px solid black;">\\(0,4055\\)</td><td style="border: 1px solid black;">\\(0,6931\\)</td><td style="border: 1px solid black;">\\(0,9163\\)</td><td style="border: 1px solid black;">\\(1,0986\\)</td><td style="border: 1px solid black;">\\(1,2528\\)</td><td style="border: 1px solid black;">\\(1,3863\\)</td><td style="border: 1px solid black;">\\(1,5041\\)</td><td style="border: 1px solid black;">\\(1,6094\\)</td>
</tr>
</tbody>
        `
    },
    {
        "id": 7,
        "content": ` <p>Функция \\(y = f(x)\\)  задана таблицей. Найти значения функции в точках \\(x_1 = 1,5091\\) и \\(x_2 = 1,5419\\), используя линейную, квадратичную и полиномиальную интерполяцию. Вычислить 
погрешность. </p>
<table align="center" border="1" cellpadding="5" cellspacing="0" style="border-collapse: collapse;">
    <tbody>
        <tr>
    <td style="border: 1px solid black;">\\(x\\)</td><td style="border: 1px solid black;">\\(1,50\\)</td><td style="border: 1px solid black;">\\(1,51\\)</td><td style="border: 1px solid black;">\\(1,52\\)</td><td style="border: 1px solid black;">\\(1,53\\)</td><td style="border: 1px solid black;">\\(1,54\\)</td><td style="border: 1px solid black;">\\(1,55\\)</td><td style="border: 1px solid black;">\\(1,56\\)</td><td style="border: 1px solid black;">\\(1,57\\)</td>
</tr>
<tr>
    <td style="border: 1px solid black;">\\(y\\)</td><td style="border: 1px solid black;">\\(0,5118\\)</td><td style="border: 1px solid black;">\\(0,5062\\)</td><td style="border: 1px solid black;">\\(0,5006\\)</td><td style="border: 1px solid black;">\\(0,4950\\)</td><td style="border: 1px solid black;">\\(0,4894\\)</td><td style="border: 1px solid black;">\\(0,4837\\)</td><td style="border: 1px solid black;">\\(0,4781\\)</td><td style="border: 1px solid black;">\\(0,4724\\)</td>
</tr>
</tbody>
</table>
        `
    },
    {
        "id": 8,
        "content": ` <p>При измерении температуры нагрева металла в зависимости от времени получены следующие результаты. Вычислить значение температуры нагрева металла в моменты 
времени \\(17 мин.\\) и \\(45 мин.\\), используя линейную, квадратичную и полиномиальную интерполяцию. Вычислить погрешность.</p>
<table align="center" border="1" cellpadding="5" cellspacing="0" style="border-collapse: collapse;">
    <tbody>
        <tr>
    <td style="border: 1px solid black;">\\(t\\), мин</td><td style="border: 1px solid black;">\\(0\\)</td><td style="border: 1px solid black;">\\(10\\)</td><td style="border: 1px solid black;">\\(20\\)</td><td style="border: 1px solid black;">\\(30\\)</td><td style="border: 1px solid black;">\\(40\\)</td><td style="border: 1px solid black;">\\(50\\)</td><td style="border: 1px solid black;">\\(60\\)</td>
</tr>
<tr>
    <td style="border: 1px solid black;">\\(T^\\circ\\)</td><td style="border: 1px solid black;">\\(200^\\circ\\)</td><td style="border: 1px solid black;">\\(537^\\circ\\)</td><td style="border: 1px solid black;">\\(600^\\circ\\)</td><td style="border: 1px solid black;">\\(487^\\circ\\)</td><td style="border: 1px solid black;">\\(530^\\circ\\)</td><td style="border: 1px solid black;">\\(137^\\circ\\)</td><td style="border: 1px solid black;">\\(100^\\circ\\)</td>
</tr>
</tbody>
</table>
        `
    },
    {
        "id": 9,
        "content": ` <p>Функция \\(y = \\lg x\\) задана таблицей. Найти значения функции в точках \\(x_1 = 3,67\\) и \\(x_2 = 4,23\\), используя линейную, квадратичную и полиномиальную интерполяцию. Вычислить погрешность.</p>
<table align="center" border="1" cellpadding="5" cellspacing="0" style="border-collapse: collapse;">
    <tbody>
        <tr>
    <td style="border: 1px solid black;">\\(x\\)</td><td style="border: 1px solid black;">\\(1\\)</td><td style="border: 1px solid black;">\\(2\\)</td><td style="border: 1px solid black;">\\(3\\)</td><td style="border: 1px solid black;">\\(4\\)</td><td style="border: 1px solid black;">\\(5\\)</td>
</tr>
<tr>
    <td style="border: 1px solid black;">\\(y\\)</td><td style="border: 1px solid black;">\\(0\\)</td><td style="border: 1px solid black;">\\(0,30103\\)</td><td style="border: 1px solid black;">\\(0,47712\\)</td><td style="border: 1px solid black;">\\(0,60206\\)</td><td style="border: 1px solid black;">\\(0,69897\\)</td>
</tr>
</tbody>
</table>
        `
    },
    {
        "id": 10,
        "content": ` <p>Функция \\(y = g(x)\\)  задана таблицей. Найти значения функции в точках \\(x_1 = 1,0113\\) и \\(x_2 = 1,4592\\), используя линейную, квадратичную и полиномиальную интерполяцию. 
Вычислить погрешность.</p>
<table align="center" border="1" cellpadding="5" cellspacing="0" style="border-collapse: collapse;">
    <tbody>
        <tr>
    <td style="border: 1px solid black;">\\(x\\)</td><td style="border: 1px solid black;">\\(1\\)</td><td style="border: 1px solid black;">\\(1,1\\)</td><td style="border: 1px solid black;">\\(1,2\\)</td><td style="border: 1px solid black;">\\(1,3\\)</td><td style="border: 1px solid black;">\\(1,4\\)</td><td style="border: 1px solid black;">\\(1,5\\)</td><td style="border: 1px solid black;">\\(1,6\\)</td><td style="border: 1px solid black;">\\(1,7\\)</td>
</tr>
<tr>
    <td style="border: 1px solid black;">\\(y\\)</td><td style="border: 1px solid black;">\\(0,5652\\)</td><td style="border: 1px solid black;">\\(0,6375\\)</td><td style="border: 1px solid black;">\\(0,7147\\)</td><td style="border: 1px solid black;">\\(0,7973\\)</td><td style="border: 1px solid black;">\\(0,8861\\)</td><td style="border: 1px solid black;">\\(0,9817\\)</td><td style="border: 1px solid black;">\\(1,0848\\)</td><td style="border: 1px solid black;">\\(1,1964\\)</td>
</tr>
</tbody>
</table>
        `
    },
    {
        "id": 11,
        "content": ` <p>Функция \\(y = 2^x\\) задана таблицей. Найти значения функции в точках \\(x_1 = \\dfrac{1}{6}\\) и \\(x_2 = \\dfrac{2}{5}\\), используя линейную, квадратичную и полиномиальную интерполяцию. Вычислить погрешность. </p>
<table align="center" border="1" cellpadding="5" cellspacing="0" style="border-collapse: collapse;">
    <tbody>
        <tr>
    <td style="border: 1px solid black;">\\(x\\)</td><td style="border: 1px solid black;">\\(0\\)</td><td style="border: 1px solid black;">\\(\\dfrac{1}{4}\\)</td><td style="border: 1px solid black;">\\(\\dfrac{1}{3}\\)</td><td style="border: 1px solid black;">\\(\\dfrac{1}{2}\\)</td><td style="border: 1px solid black;">\\(\\dfrac{2}{3}\\)</td><td style="border: 1px solid black;">\\(\\dfrac{3}{4}\\)</td><td style="border: 1px solid black;">\\(1\\)</td>
</tr>
<tr>
    <td style="border: 1px solid black;">\\(y\\)</td><td style="border: 1px solid black;">\\(1\\)</td><td style="border: 1px solid black;">\\(1,1892\\)</td><td style="border: 1px solid black;">\\(1,2599\\)</td><td style="border: 1px solid black;">\\(1,4142\\)</td><td style="border: 1px solid black;">\\(1,5874\\)</td><td style="border: 1px solid black;">\\(1,6818\\)</td><td style="border: 1px solid black;">\\(2\\)</td>
</tr>
</tbody>
</table>
        `
    },
    {
        "id": 12,
        "content": ` <p>Дана таблица значений функции \\(y = e^x\\). Найти значения функции в точках \\(x_1 = 3,5123\\) и \\(x_2 = 3,5148\\), используя линейную, квадратичную и полиномиальную интерполяцию. 
Вычислить погрешность.</p>
<table align="center" border="1" cellpadding="5" cellspacing="0" style="border-collapse: collapse;">
    <tbody>
        <tr>
    <td style="border: 1px solid black;">\\(x\\)</td><td style="border: 1px solid black;">\\(3,510\\)</td><td style="border: 1px solid black;">\\(3,511\\)</td><td style="border: 1px solid black;">\\(3,512\\)</td><td style="border: 1px solid black;">\\(3,513\\)</td><td style="border: 1px solid black;">\\(3,514\\)</td><td style="border: 1px solid black;">\\(3,515\\)</td>
</tr>
<tr>
    <td style="border: 1px solid black;">\\(y\\)</td><td style="border: 1px solid black;">\\(33,448\\)</td><td style="border: 1px solid black;">\\(33,481\\)</td><td style="border: 1px solid black;">\\(33,515\\)</td><td style="border: 1px solid black;">\\(33,548\\)</td><td style="border: 1px solid black;">\\(33,582\\)</td><td style="border: 1px solid black;">\\(33,615\\)</td>
</tr>
</tbody>
</table>
        `
    },
    {
        "id": 13,
        "content": ` <p>Дана таблица значений функции \\(y = \\sin x\\). Найти значения функции \\(\\sin 36^\\circ\\) и \\(\\sin 48^\\circ\\), используя линейную, квадратичную и полиномиальную интерполяцию. 
Вычислить погрешность. </p>
<table align="center" border="1" cellpadding="5" cellspacing="0" style="border-collapse: collapse;">
    <tbody>
        <tr>
    <td style="border: 1px solid black;">\\(x\\)</td>
    <td style="border: 1px solid black;">\\(0^\\circ\\)</td><td style="border: 1px solid black;">\\(30^\\circ\\)</td><td style="border: 1px solid black;">\\(45^\\circ\\)</td><td style="border: 1px solid black;">\\(60^\\circ\\)</td><td style="border: 1px solid black;">\\(90^\\circ\\)</td><td style="border: 1px solid black;">\\(180^\\circ\\)</td>
</tr>
<tr>
    <td style="border: 1px solid black;">\\(y\\)</td><td style="border: 1px solid black;">\\(0\\)</td><td style="border: 1px solid black;">\\(0,5000\\)</td><td style="border: 1px solid black;">\\(0,7071\\)</td><td style="border: 1px solid black;">\\(0,8660\\)</td><td style="border: 1px solid black;">\\(1\\)</td><td style="border: 1px solid black;">\\(0\\)</td>
</tr>
</tbody>
</table>
        `
    },
    {
        "id": 14,
        "content": ` <p>Дана таблица значений функции \\(y = \\sin x\\). Найти значения функции \\(\\sin \\dfrac{\\pi}{12}\\) и \\(\\sin \\dfrac{\\pi}{24}\\), используя линейную, квадратичную и полиномиальную интерполяцию. 
Вычислить погрешность. </p>
<table align="center" border="1" cellpadding="5" cellspacing="0" style="border-collapse: collapse;">
    <tbody>
        <tr>
    <td style="border: 1px solid black;">\\(x\\)</td><td style="border: 1px solid black;">\\(0\\)</td><td style="border: 1px solid black;">\\(\\dfrac{\\pi}{6}\\)</td><td style="border: 1px solid black;">\\(\\dfrac{\\pi}{4}\\)</td><td style="border: 1px solid black;">\\(\\dfrac{\\pi}{3}\\)</td><td style="border: 1px solid black;">\\(\\dfrac{\\pi}{2}\\)</td><td style="border: 1px solid black;">\\(\\pi\\)</td>
</tr>
<tr>
    <td style="border: 1px solid black;">\\(y\\)</td><td style="border: 1px solid black;">\\(0\\)</td><td style="border: 1px solid black;">\\(0,5\\)</td><td style="border: 1px solid black;">\\(0,707\\)</td><td style="border: 1px solid black;">\\(0,866\\)</td><td style="border: 1px solid black;">\\(1\\)</td><td style="border: 1px solid black;">\\(0\\)</td>
</tr>
</tbody>
</table>
        `
    },
    {
        "id": 15,
        "content": ` <p>Дана таблица значений функции \\(f(x) = \\dfrac{1}{\\sqrt{\\pi}} e^{-x^2}\\) . Найти значения функции в точках \\(x_1 = 0,3\\) и \\(x_2 = 1,05\\), используя линейную, квадратичную и полиномиальную интерполяцию. 
Вычислить погрешность.</p>
<table align="center" border="1" cellpadding="5" cellspacing="0" style="border-collapse: collapse;">
    <tbody>
        <tr>
    <td style="border: 1px solid black;">\\(x\\)</td><td style="border: 1px solid black;">\\(0,2\\)</td><td style="border: 1px solid black;">\\(0,5\\)</td><td style="border: 1px solid black;">\\(0,7\\)</td><td style="border: 1px solid black;">\\(1\\)</td><td style="border: 1px solid black;">\\(1,2\\)</td><td style="border: 1px solid black;">\\(2\\)</td>
</tr>
<tr>
    <td style="border: 1px solid black;">\\(y\\)</td><td style="border: 1px solid black;">\\(0,3833\\)</td><td style="border: 1px solid black;">\\(0,3107\\)</td><td style="border: 1px solid black;">\\(0,2444\\)</td><td style="border: 1px solid black;">\\(0,1468\\)</td><td style="border: 1px solid black;">\\(2,3818\\)</td><td style="border: 1px solid black;">\\(5,3542\\)</td>
</tr>
</tbody>
</table>
        `
    },
{
        "id": 16,
        "content": ` <p>Функция \\(y = \\cos x\\) задана таблицей. Найти значения функции в точках \\(x_1 = 0,45\\) и \\(x_2 = 0,78\\), используя линейную, квадратичную и полиномиальную интерполяцию. 
Вычислить погрешность. </p>
<table align="center" border="1" cellpadding="5" cellspacing="0" style="border-collapse: collapse;">
    <tbody>
        <tr>
    <td style="border: 1px solid black;">\\(x\\)</td><td style="border: 1px solid black;">\\(0,2\\)</td><td style="border: 1px solid black;">\\(0,3\\)</td><td style="border: 1px solid black;">\\(0,4\\)</td><td style="border: 1px solid black;">\\(0,5\\)</td><td style="border: 1px solid black;">\\(0,6\\)</td><td style="border: 1px solid black;">\\(0,7\\)</td><td style="border: 1px solid black;">\\(0,8\\)</td>
</tr>
<tr>
    <td style="border: 1px solid black;">\\(y\\)</td><td style="border: 1px solid black;">\\(0,9801\\)</td><td style="border: 1px solid black;">\\(0,9553\\)</td><td style="border: 1px solid black;">\\(0,9211\\)</td><td style="border: 1px solid black;">\\(0,8776\\)</td><td style="border: 1px solid black;">\\(0,8253\\)</td><td style="border: 1px solid black;">\\(0,7648\\)</td><td style="border: 1px solid black;">\\(0,6967\\)</td>
</tr>
</tbody>
</table>
        `
    },
    {
        "id": 17,
        "content": ` <p>Функция \\(y = \\ln(1+x)\\) задана таблицей. Найти значения функции в точках \\(x_1 = 0,25\\) и \\(x_2 = 0,65\\), используя линейную, квадратичную и полиномиальную интерполяцию. 
Вычислить погрешность.</p>
<table align="center" border="1" cellpadding="5" cellspacing="0" style="border-collapse: collapse;">
    <tbody>
        <tr>
    <td style="border: 1px solid black;">\\(x\\)</td>
    <td style="border: 1px solid black;">\\(0,1\\)</td><td style="border: 1px solid black;">\\(0,2\\)</td><td style="border: 1px solid black;">\\(0,3\\)</td><td style="border: 1px solid black;">\\(0,4\\)</td><td style="border: 1px solid black;">\\(0,5\\)</td><td style="border: 1px solid black;">\\(0,6\\)</td><td style="border: 1px solid black;">\\(0,7\\)</td>
</tr>
<tr>
    <td style="border: 1px solid black;">\\(y\\)</td><td style="border: 1px solid black;">\\(0,09531\\)</td><td style="border: 1px solid black;">\\(0,18232\\)</td><td style="border: 1px solid black;">\\(0,26236\\)</td><td style="border: 1px solid black;">\\(0,33647\\)</td><td style="border: 1px solid black;">\\(0,40547\\)</td><td style="border: 1px solid black;">\\(0,47000\\)</td><td style="border: 1px solid black;">\\(0,53063\\)</td>
</tr>
</tbody>
</table>
        `
    },
    {
        "id": 18,
        "content": ` <p>Функция \\(y = \\sqrt{x}\\) задана таблицей. Найти значения функции в точках \\(x_1 = 2,3\\) и \\(x_2 = 4,7\\), используя линейную, квадратичную и полиномиальную интерполяцию. Вычислить погрешность.</p>
<table align="center" border="1" cellpadding="5" cellspacing="0" style="border-collapse: collapse;">
    <tbody>
        <tr>
    <td style="border: 1px solid black;">\\(x\\)</td><td style="border: 1px solid black;">\\(1,0\\)</td><td style="border: 1px solid black;">\\(1,5\\)</td><td style="border: 1px solid black;">\\(2,0\\)</td><td style="border: 1px solid black;">\\(2,5\\)</td><td style="border: 1px solid black;">\\(3,0\\)</td><td style="border: 1px solid black;">\\(3,5\\)</td><td style="border: 1px solid black;">\\(4,0\\)</td><td style="border: 1px solid black;">\\(4,5\\)</td><td style="border: 1px solid black;">\\(5,0\\)</td>
</tr>
<tr>
    <td style="border: 1px solid black;">\\(y\\)</td><td style="border: 1px solid black;">\\(1,0000\\)</td><td style="border: 1px solid black;">\\(1,2247\\)</td><td style="border: 1px solid black;">\\(1,4142\\)</td><td style="border: 1px solid black;">\\(1,5811\\)</td><td style="border: 1px solid black;">\\(1,7321\\)</td><td style="border: 1px solid black;">\\(1,8708\\)</td><td style="border: 1px solid black;">\\(2,0000\\)</td><td style="border: 1px solid black;">\\(2,1213\\)</td><td style="border: 1px solid black;">\\(2,2361\\)</td>
</tr>
</tbody>
</table>
        `
    },
    {
        "id": 19,
        "content": ` <p>Функция \\(y = \\arctan x\\) задана таблицей. Найти значения функции в точках \\(x_1 = 0,35\\) и \\(x_2 = 0,85\\), используя линейную, квадратичную и полиномиальную интерполяцию. 
Вычислить погрешность. </p>
<table align="center" border="1" cellpadding="5" cellspacing="0" style="border-collapse: collapse;">
    <tbody>
        <tr>
    <td style="border: 1px solid black;">\\(x\\)</td><td style="border: 1px solid black;">\\(0,1\\)</td><td style="border: 1px solid black;">\\(0,2\\)</td><td style="border: 1px solid black;">\\(0,3\\)</td><td style="border: 1px solid black;">\\(0,4\\)</td><td style="border: 1px solid black;">\\(0,5\\)</td><td style="border: 1px solid black;">\\(0,6\\)</td><td style="border: 1px solid black;">\\(0,7\\)</td><td style="border: 1px solid black;">\\(0,8\\)</td><td style="border: 1px solid black;">\\(0,9\\)</td>
</tr>
<tr>
    <td style="border: 1px solid black;">\\(y\\)</td><td style="border: 1px solid black;">\\(0,09967\\)</td><td style="border: 1px solid black;">\\(0,19740\\)</td><td style="border: 1px solid black;">\\(0,29146\\)</td><td style="border: 1px solid black;">\\(0,38051\\)</td><td style="border: 1px solid black;">\\(0,46365\\)</td><td style="border: 1px solid black;">\\(0,54042\\)</td><td style="border: 1px solid black;">\\(0,61073\\)</td><td style="border: 1px solid black;">\\(0,67474\\)</td><td style="border: 1px solid black;">\\(0,73282\\)</td>
</tr>
</tbody>
</table>
        `
    },
    {
        "id": 20,
        "content": ` <p>Функция \\(y = x^3\\) задана таблицей. Найти значения функции в точках \\(x_1 = 1,25\\) и \\(x_2 = 2,75\\), используя линейную, квадратичную и полиномиальную интерполяцию. Вычислить погрешность. </p>
<table align="center" border="1" cellpadding="5" cellspacing="0" style="border-collapse: collapse;">
    <tbody>
        <tr>
    <td style="border: 1px solid black;">\\(x\\)</td><td style="border: 1px solid black;">\\(1,0\\)</td><td style="border: 1px solid black;">\\(1,2\\)</td><td style="border: 1px solid black;">\\(1,4\\)</td><td style="border: 1px solid black;">\\(1,6\\)</td><td style="border: 1px solid black;">\\(1,8\\)</td><td style="border: 1px solid black;">\\(2,0\\)</td><td style="border: 1px solid black;">\\(2,2\\)</td><td style="border: 1px solid black;">\\(2,4\\)</td><td style="border: 1px solid black;">\\(2,6\\)</td><td style="border: 1px solid black;">\\(3,0\\)</td>
</tr>
<tr>
    <td style="border: 1px solid black;">\\(y\\)</td><td style="border: 1px solid black;">\\(1,000\\)</td><td style="border: 1px solid black;">\\(1,728\\)</td><td style="border: 1px solid black;">\\(2,744\\)</td><td style="border: 1px solid black;">\\(4,096\\)</td><td style="border: 1px solid black;">\\(5,832\\)</td><td style="border: 1px solid black;">\\(8,000\\)</td><td style="border: 1px solid black;">\\(10,648\\)</td><td style="border: 1px solid black;">\\(13,824\\)</td><td style="border: 1px solid black;">\\(17,576\\)</td><td style="border: 1px solid black;">\\(27,000\\)</td>
</tr>
</tbody>
</table>
        `
    }
]
            }]
        };
        
        if (JSON_content.topic06.practica && JSON_content.topic06.practica.includes('"assignments":')) {
            JSON_content.topic06.practica = JSON_content.topic06.practica.split('"assignments":')[0].trim();
        }
    }


if (JSON_content.topic07 && !JSON_content.topic07.practicaData) {
    JSON_content.topic07.practicaData = {
        assignments: [
            { // Задание 1
                title: "Задание 1",
                description: `
	<p>Решить задачу Коши для обыкновенного дифференциального уравнения первого порядка \\( y' = f(x, y) \\) с начальным условием \\( y(x_0) = y_0 \\) на отрезке \\([a, b]\\) 
с шагом \\( h=0.1 \\) методом Эйлера. Все вычисления вести с четырьмя десятичными знаками.</p>
`,
                variants: [
                    {
                        "id": 1,
                        "content": "<p>Дано уравнение \\( y' = x + \\cos\\left(\\dfrac{y}{3}\\right) \\) с начальным условием \\( y_0(1.8) = 2.6 \\) и интервалом \\( x \\in [1.8; 2.8] \\) .</p>"
                    },
                    {
                        "id": 2,
                        "content": "<p>Дано уравнение \\( y' = x + \\cos\\left(\\dfrac{y}{3}\\right) \\) с начальным условием \\( y_0(1.6) = 4.6 \\) и интервалом \\( x \\in [1.6; 2.6] \\) .</p>"
                    },
                    {
                        "id": 3,
                        "content": "<p>Дано уравнение \\( y' = x + \\cos\\left(\\dfrac{y}{\\sqrt{10}}\\right) \\) с начальным условием \\( y_0(0.6) = 0.8 \\) и интервалом \\( x \\in [0.6; 1.6] \\) .</p>"
                    },
                    {
                        "id": 4,
                        "content": "<p>Дано уравнение \\( y' = x + \\cos\\left(\\dfrac{y}{\\sqrt{7}}\\right) \\) с начальным условием \\( y_0(0.5) = 0.6 \\) и интервалом \\( x \\in [0.5; 1.5] \\) .</p>"
                    },
                    {
                        "id": 5,
                        "content": "<p>Дано уравнение \\( y' = x + \\cos\\left(\\dfrac{y}{\\pi}\\right) \\) с начальным условием \\( y_0(1.7) = 5.3 \\) и интервалом \\( x \\in [1.7; 2.7] \\) .</p>"
                    },
                    {
                        "id": 6,
                        "content": "<p>Дано уравнение \\( y' = x + \\cos\\left(\\dfrac{y}{2.25}\\right) \\) с начальным условием \\( y_0(1.4) = 2.2 \\) и интервалом \\( x \\in [1.4; 2.4] \\) .</p>"
                    },
                    {
                        "id": 7,
                        "content": "<p>Дано уравнение \\( y' = x + \\cos\\left(\\dfrac{y}{e}\\right) \\) с начальным условием \\( y_0(1.4) = 2.5 \\) и интервалом \\( x \\in [1.4; 2.4] \\) .</p>"
                    },
                    {
                        "id": 8,
                        "content": "<p>Дано уравнение \\( y' = x + \\cos\\left(\\dfrac{y}{\\sqrt{2}}\\right) \\) с начальным условием \\( y_0(0.8) = 1.4 \\) и интервалом \\( x \\in [0.8; 1.8] \\) .</p>"
                    },
                    {
                        "id": 9,
                        "content": "<p>Дано уравнение \\( y' = x + \\cos\\left(\\dfrac{y}{\\sqrt{3}}\\right) \\) с начальным условием \\( y_0(1.2) = 2.1 \\) и интервалом \\( x \\in [1.2; 2.2] \\) .</p>"
                    },
                    {
                        "id": 10,
                        "content": "<p>Дано уравнение \\( y' = x + \\cos\\left(\\dfrac{y}{\\sqrt{11}}\\right) \\) с начальным условием \\( y_0(2.1) = 2.5 \\) и интервалом \\( x \\in [2.1; 3.1] \\) .</p>"
                    },
                    {
                        "id": 11,
                        "content": "<p>Дано уравнение \\( y' = x + \\sin\\left(\\dfrac{y}{\\sqrt{5}}\\right) \\) с начальным условием \\( y_0(1.8) = 2.6 \\) и интервалом \\( x \\in [1.8; 2.8] \\) .</p>"
                    },
                    {
                        "id": 12,
                        "content": "<p>Дано уравнение \\( y' = x + \\sin\\left(\\dfrac{y}{3}\\right) \\) с начальным условием \\( y_0(1.6) = 4.6 \\) и интервалом \\( x \\in [1.6; 2.6] \\) .</p>"
                    },
                    {
                        "id": 13,
                        "content": "<p>Дано уравнение \\( y' = x + \\sin\\left(\\dfrac{y}{\\sqrt{10}}\\right) \\) с начальным условием \\( y_0(0.6) = 0.8 \\) и интервалом \\( x \\in [0.6; 1.6] \\) .</p>"
                    },
                    {
                        "id": 14,
                        "content": "<p>Дано уравнение \\( y' = x + \\sin\\left(\\dfrac{y}{\\sqrt{7}}\\right) \\) с начальным условием \\( y_0(0.5) = 0.6 \\) и интервалом \\( x \\in [0.5; 1.5] \\) .</p>"
                    },
                    {
                        "id": 15,
                        "content": "<p>Дано уравнение \\( y' = x + \\sin\\left(\\dfrac{y}{\\pi}\\right) \\) с начальным условием \\( y_0(1.7) = 5.3 \\) и интервалом \\( x \\in [1.7; 2.7] \\) .</p>"
                    },
                    {
                        "id": 16,
                        "content": "<p>Дано уравнение \\( y' = x + \\sin\\left(\\dfrac{y}{2.8}\\right) \\) с начальным условием \\( y_0(1.4) = 2.2 \\) и интервалом \\( x \\in [1.4; 2.4] \\) .</p>"
                    },
                    {
                        "id": 17,
                        "content": "<p>Дано уравнение \\( y' = x + \\sin\\left(\\dfrac{y}{e}\\right) \\) с начальным условием \\( y_0(1.4) = 2.5 \\) и интервалом \\( x \in [1.4; 2.4] \\) .</p>"
                    },
                    {
                        "id": 18,
                        "content": "<p>Дано уравнение \\( y' = x + \\sin\\left(\\dfrac{y}{\\sqrt{2}}\\right) \\) с начальным условием \\( y_0(0.8) = 1.3 \\) и интервалом \\( x \\in [0.8; 1.8] \\) .</p>"
                    },
                    {
                        "id": 19,
                        "content": "<p>Дано уравнение \\( y' = x + \\sin\\left(\\dfrac{y}{\\sqrt{3}}\\right) \\) с начальным условием \\( y_0(1.1) = 1.5 \\) и интервалом \\( x \\in [1.1; 2.1] \\).</p>"
                    },
                    {
                        "id": 20,
                        "content": "<p>Дано уравнение \\( y' = x + \\sin\\left(\\frac{y}{\\sqrt{11}}\\right) \\) с начальным условием \\( y_0(0.6) = 1.2 \\) и интервалом \\( x \\in [0.6; 1.6] \\) .</p>"
                    }
                ]
            },
            { 
                title: "Задание 2",
                description: `<p>Решить задачу Коши для обыкновенного дифференциального уравнения первого порядка модифицированным методом Эйлера на отрезке \\([0.2; 1.2]\\) с шагом \\(h=0.1\\) при 
начальном условии \\(y(0.2)=0.25\\). Все вычисления выполнять с четырьмя десятичными знаками.</p>
`,
                variants: [
                    {
                        "id": 1,
                        "content": "<p>Дано уравнение \\( y' = 0.133(x^2 + \\sin(x)) + 0.872y \\) .</p>"
                    },
                    {
                        "id": 2,
                        "content": "<p>Дано уравнение \\( y' = 0.215(x^2 + \\cos(1.5x)) + 1.283y \\) .</p>"
                    },
                    {
                        "id": 3,
                        "content": "<p>Дано уравнение \\( y' = 0.158(x^2 + \\sin(0.8x)) + 1.164y \\) .</p>"
                    },
                    {
                        "id": 4,
                        "content": "<p>Дано уравнение \\( y' = 0.173(x^2 + \\cos(0.7x)) + 0.754y \\) .</p>"
                    },
                    {
                        "id": 5,
                        "content": "<p>Дано уравнение \\( y' = 0.221(x^2 + \\sin(1.2x)) + 0.452y \\) .</p>"
                    },
                    {
                        "id": 6,
                        "content": "<p>Дано уравнение \\( y' = 0.163(x^2 + \\cos(0.4x)) + 0.635y \\) .</p>"
                    },
                    {
                        "id": 7,
                        "content": "<p>Дано уравнение \\( y' = 0.218(x^2 + \\sin(1.6x)) + 0.718y \\) .</p>"
                    },
                    {
                        "id": 8,
                        "content": "<p>Дано уравнение \\( y' = 0.145(x^2 + \\cos(0.5x)) + 0.842y \\) .</p>"
                    },
                    {
                        "id": 9,
                        "content": "<p>Дано уравнение \\( y' = 0.213(x^2 + \\sin(1.8x)) + 0.368y \\) .</p>"
                    },
                    {
                        "id": 10,
                        "content": "<p>Дано уравнение \\( y' = 0.127(x^2 + \\cos(0.6x)) + 0.573y \\) .</p>"
                    },
                    {
                        "id": 11,
                        "content": "<p>Дано уравнение \\( y' = 0.232(x^2 + \\sin(1.4x)) + 1.453y \\) .</p>"
                    },
                    {
                        "id": 12,
                        "content": "<p>Дано уравнение \\( y' = 0.417(x^2 + \\cos(0.8x)) + 0.972y \\) .</p>"
                    },
                    {
                        "id": 13,
                        "content": "<p>Дано уравнение \\( y' = 0.324(x^2 + \\sin(1.5x)) + 1.612y \\) .</p>"
                    },
                    {
                        "id": 14,
                        "content": "<p>Дано уравнение \\( y' = 0.263(x^2 + \\cos(1.2x)) + 0.453y \\) .</p>"
                    },
                    {
                        "id": 15,
                        "content": "<p>Дано уравнение \\( y' = 0.372(x^2 + \\sin(0.7x)) + 0.758y \\) .</p>"
                    },
                    {
                        "id": 16,
                        "content": "<p>Дано уравнение \\( y' = 0.343(x^2 + \\cos(0.4x)) + 1.315y \\) .</p>"
                    },
                    {
                        "id": 17,
                        "content": "<p>Дано уравнение \\( y' = 0.276(x^2 + \\sin(1.6x)) + 0.988y \\) .</p>"
                    },
                    {
                        "id": 18,
                        "content": "<p>Дано уравнение \\( y' = 0.173(x^2 + \\cos(0.6x)) + 1.534y \\) .</p>"
                    },
                    {
                        "id": 19,
                        "content": "<p>Дано уравнение \\( y' = 0.258(x^2 + \\sin(0.4x)) + 0.724y \\) .</p>"
                    },
                    {
                        "id": 20,
                        "content": "<p>Дано уравнение \\( y' = 0.317(x^2 + \\cos(1.4x)) + 1.344y \\) .</p>"
                    }
                ]
            },
            { 
                title: "Задание 3",
                description: `<p>Для функции \\( f(x, y) \\), заданной дифференциальным уравнением первого порядка \\( y' = f(x, y) \\), решить задачу Коши с начальным условием \\( y(x_0) = y_0 \\) на отрезке
 \\( [0; 1] \\) с шагом \\( h = 0.1 \\), используя метод Рунге-Кутта. Все вычисления выполнить с точностью до четырёх десятичных знаков.</p>
`,
                variants: [
                    {
                        "id": 1,
                        "content": "<p>Дано уравнение \\( y' = 1 + 0.2y\\sin(x) - y^2 \\) с начальным условием \\( y(0) = 0 \\) .</p>"
                    },
                    {
                        "id": 2,
                        "content": "<p>Дано уравнение \\( y' = \\cos(x + y) + 0.5(x - y) \\) с начальным условием \\( y(0) = 0 \\) .</p>"
                    },
                    {
                        "id": 3,
                        "content": "<p>Дано уравнение \\( y' = \\dfrac{\\cos y}{x + 1} - 0.5y^2 \\) с начальным условием \\( y(0) = 0 \\) .</p>"
                    },
                    {
                        "id": 4,
                        "content": "<p>Дано уравнение \\( y' = (1 - y^2)\\cos x + 0.6y \\) с начальным условием \\( y(0) = 0 \\) .</p>"
                    },
                    {
                        "id": 5,
                        "content": "<p>Дано уравнение \\( y' = 1 + 0.4y\\sin x - 1.5y^2 \\) с начальным условием \\( y(0) = 0 \\) .</p>"
                    },
                    {
                        "id": 6,
                        "content": "<p>Дано уравнение \\( y' = \\dfrac{\\cos y}{x + 2} + 0.3y^2 \\) с начальным условием \\( y(0) = 0 \\) .</p>"
                    },
                    {
                        "id": 7,
                        "content": "<p>Дано уравнение \\( y' = \\cos(1.5x + y) + (x - y) \\) с начальным условием \\( y(0) = 0 \\) .</p>"
                    },
                    {
                        "id": 8,
                        "content": "<p>Дано уравнение \\( y' = 1 - \\sin(x + y) + \\dfrac{0.5y}{x + 2} \\) с начальным условием \\( y(0) = 0 \\) .</p>"
                    },
                    {
                        "id": 9,
                        "content": "<p>Дано уравнение \\( y' = \\dfrac{\\cos y}{1.5 + x} + 0.1y^2 \\) с начальным условием \\( y(0) = 0 \\) .</p>"
                    },
                    {
                        "id": 10,
                        "content": "<p>Дано уравнение \\( y' = 0.6\\sin x - 1.25y^2 + 1 \\) с начальным условием \\( y(0) = 0 \\) .</p>"
                    },
                    {
                        "id": 11,
                        "content": "<p>Дано уравнение \\( y' = \\cos(2x + y) + 1.5(x - y) \\) с начальным условием \\( y(0) = 0 \\) .</p>"
                    },
                    {
                        "id": 12,
                        "content": "<p>Дано уравнение \\( y' = 1 - \\dfrac{0.1y}{x + 2} - \sin(2x + y) \\) с начальным условием \\( y(0) = 0 \\) .</p>"
                    },
                    {
                        "id": 13,
                        "content": "<p>Дано уравнение \\( y' = \\dfrac{\\cos y}{1.25 + x} - 0.1y^2 \\) с начальным условием \\( y(0) = 0 \\) .</p>"
                    },
                    {
                        "id": 14,
                        "content": "<p>Дано уравнение \\( y' = 1 + 0.8y\\sin x - 2y^2 \\) с начальным условием \\( y(0) = 0 \\) .</p>"
                    },
                    {
                        "id": 15,
                        "content": "<p>Дано уравнение \\( y' = \\cos(1.5x + y) + 1.5(x - y) \\) с начальным условием \\( y(0) = 0 \\) .</p>"
                    },
                    {
                        "id": 16,
                        "content": "<p>Дано уравнение \\( y' = 1 - \\sin(2x + y) + \\dfrac{0.3y}{x + 2} \\) с начальным условием \\( y(0) = 0 \\) .</p>"
                    },
                    {
                        "id": 17,
                        "content": "<p>Дано уравнение \\( y' = \\dfrac{\\cos y}{1.75 + x} - 0.5y^2 \\) с начальным условием \\( y(0) = 0 \\) .</p>"
                    },
                    {
                        "id": 18,
                        "content": "<p>Дано уравнение \\( y' = 1 + (1 - x)\\sin y - (2 + x)y \\) с начальным условием \\( y(0) = 0 \\) .</p>"
                    },
                    {
                        "id": 19,
                        "content": "<p>Дано уравнение \\( y' = (0.8 - y^2)\\cos x + 0.3y \\) с начальным условием \\( y(0) = 0 \\) .</p>"
                    },
                    {
                        "id": 20,
                        "content": "<p>Дано уравнение \\( y' = 1 + 2.2\\sin x + 1.5y^2 \\) с начальным условием \\( y(0) = 0 \\) .</p>"
                    }
                ]
            }
        ]
    };
    
    if (JSON_content.topic07.practica && JSON_content.topic07.practica.includes('"assignments":')) {
        JSON_content.topic07.practica = JSON_content.topic07.practica.split('"assignments":')[0].trim();
    }
}

if (JSON_content.topic08 && !JSON_content.topic08.practicaData) {
        JSON_content.topic08.practicaData = {
            assignments: [{
                title: "Задание 1",
                description: `
	<p>Для функции \\( f(x) \\), заданной в виде таблицы в пяти узлах \\( x_i, \\; i = 0, 1, 2, 3, 4 \\), найти значения её первой и второй производных в первых четырёх узлах, 
используя формулы численного дифференцирования.</p>
`,
                variants: [
                    {
                            "id": 1,
                            "content": ` <table align="center" border="1" cellpadding="5" cellspacing="0" style="border-collapse: collapse;">
    <tbody>
        <tr>
            <td style="border: 1px solid black;">\\(x\\)</td><td style="border: 1px solid black;">\\( 1.25 \\)</td><td style="border: 1px solid black;">\\( 1.27 \\)</td><td style="border: 1px solid black;">\\( 1.29 \\)</td><td style="border: 1px solid black;">\\( 1.31 \\)</td><td style="border: 1px solid black;">\\( 1.33 \\)</td>
        </tr>
        <tr>
            <td style="border: 1px solid black;">\\(y\\)</td><td style="border: 1px solid black;">\\( 4.82835 \\)</td><td style="border: 1px solid black;">\\( 4.84418 \\)</td><td style="border: 1px solid black;">\\( 4.85989 \\)</td><td style="border: 1px solid black;">\\( 4.87523 \\)</td><td style="border: 1px solid black;">\\( 4.86331 \\)</td>
        </tr>
</tbody>
</table>
			`},
                        {
                            "id": 2,
                            "content": ` <table align="center" border="1" cellpadding="5" cellspacing="0" style="border-collapse: collapse;">
    <tbody>
        <tr>
            <td style="border: 1px solid black;">\\(x\\)</td><td style="border: 1px solid black;">\\( 13.5 \\)</td><td style="border: 1px solid black;">\\( 13.7 \\)</td><td style="border: 1px solid black;">\\( 13.9 \\)</td><td style="border: 1px solid black;">\\( 14.1 \\)</td><td style="border: 1px solid black;">\\( 14.3 \\)</td>
        </tr>
        <tr>
            <td style="border: 1px solid black;">\\(y\\)</td><td style="border: 1px solid black;">\\( 4.90583 \\)</td><td style="border: 1px solid black;">\\( 4.92007 \\)</td><td style="border: 1px solid black;">\\( 4.93459 \\)</td><td style="border: 1px solid black;">\\( 4.94882 \\)</td><td style="border: 1px solid black;">\\( 4.96571 \\)</td>
	</tr>
</tbody>
</table>
			`},
                        {
                            "id": 3,
                            "content": ` <table align="center" border="1" cellpadding="5" cellspacing="0" style="border-collapse: collapse;">
    <tbody>
        <tr>
            <td style="border: 1px solid black;">\\(x\\)</td><td style="border: 1px solid black;">\\( 0.145 \\)</td><td style="border: 1px solid black;">\\( 0.147 \\)</td><td style="border: 1px solid black;">\\( 0.149 \\)</td><td style="border: 1px solid black;">\\( 0.151 \\)</td><td style="border: 1px solid black;">\\( 0.153 \\)</td>
	</tr>
        <tr>
            <td style="border: 1px solid black;">\\(y\\)</td><td style="border: 1px solid black;">\\( 4.97674 \\)</td><td style="border: 1px solid black;">\\( 4.99043 \\)</td><td style="border: 1px solid black;">\\( 5.00391 \\)</td><td style="border: 1px solid black;">\\( 5.01730 \\)</td><td style="border: 1px solid black;">\\( 5.03207 \\)</td>
	</tr>
</tbody>
</table>
			`},
                        {
                            "id": 4,
                            "content": ` <table align="center" border="1" cellpadding="5" cellspacing="0" style="border-collapse: collapse;">
    <tbody>
         <tr>
            <td style="border: 1px solid black;">\\(x\\)</td><td style="border: 1px solid black;">\\( 0.451 \\))</td><td style="border: 1px solid black;">\\( 0.452 \\)</td><td style="border: 1px solid black;">\\( 0.453 \\)</td><td style="border: 1px solid black;">\\( 0.454 \\)</td><td style="border: 1px solid black;">\\( 0.455 \\)</td>
	</tr>
        <tr>
            <td style="border: 1px solid black;">\\(y\\)</td><td style="border: 1px solid black;">\\( 0.43587 \\)</td><td style="border: 1px solid black;">\\( 0.43677 \\)</td><td style="border: 1px solid black;">\\( 0.43766 \\)</td><td style="border: 1px solid black;">\\( 0.43856 \\)</td><td style="border: 1px solid black;">\\( 0.43945 \\)</td>
	</tr>
</tbody>
</table>
			`},
                        {
                            "id": 5,
                            "content": ` <table align="center" border="1" cellpadding="5" cellspacing="0" style="border-collapse: collapse;">
    <tbody>
         <tr>
            <td style="border: 1px solid black;">\\(x\\)</td><td style="border: 1px solid black;">\\( 0.724 \\)</td><td style="border: 1px solid black;">\\( 0.725 \\)</td><td style="border: 1px solid black;">\\( 0.726 \\)</td><td style="border: 1px solid black;">\\( 0.727 \\)</td><td style="border: 1px solid black;">\\( 0.728 \\)</td>
	</tr>
        <tr>
            <td style="border: 1px solid black;">\\(y\\)</td><td style="border: 1px solid black;">\\( 0.90000 \\)</td><td style="border: 1px solid black;">\\( 0.89957 \\)</td><td style="border: 1px solid black;">\\( 0.89914 \\)</td><td style="border: 1px solid black;">\\( 0.89870 \\)</td><td style="border: 1px solid black;">\\( 0.89825 \\)</td>
        </tr>
</tbody>
</table>
			`},
                        {
                            "id": 6,
                            "content": ` <table align="center" border="1" cellpadding="5" cellspacing="0" style="border-collapse: collapse;">
    <tbody>
        <tr>
            <td style="border: 1px solid black;">\\(x\\)</td><td style="border: 1px solid black;">\\( 0.349 \\)</td><td style="border: 1px solid black;">\\( 0.350 \\)</td><td style="border: 1px solid black;">\\( 0.351 \\)</td><td style="border: 1px solid black;">\\( 0.352 \\)</td><td style="border: 1px solid black;">\\( 0.353 \\)</td>
        </tr>
        <tr>
            <td style="border: 1px solid black;">\\(y\\)</td><td style="border: 1px solid black;">\\( 0.34196 \\)</td><td style="border: 1px solid black;">\\( 0.34290 \\)</td><td style="border: 1px solid black;">\\( 0.34384 \\)</td><td style="border: 1px solid black;">\\( 0.34478 \\)</td><td style="border: 1px solid black;">\\( 0.34488 \\)</td>
        </tr>
</tbody>
</table>
			`},
                        {
                            "id": 7,
                            "content": ` <table align="center" border="1" cellpadding="5" cellspacing="0" style="border-collapse: collapse;">
    <tbody>
         <tr>
            <td style="border: 1px solid black;">\\(x\\)</td><td style="border: 1px solid black;">\\( 0.725 \\)</td><td style="border: 1px solid black;">\\( 0.727 \\)</td><td style="border: 1px solid black;">\\( 0.729 \\)</td><td style="border: 1px solid black;">\\( 0.731 \\)</td><td style="border: 1px solid black;">\\( 0.733 \\)</td>
        </tr>
        <tr>
            <td style="border: 1px solid black;">\\(y\\)</td><td style="border: 1px solid black;">\\( 0.66314 \\)</td><td style="border: 1px solid black;">\\( 0.66463 \\)</td><td style="border: 1px solid black;">\\( 0.66612 \\)</td><td style="border: 1px solid black;">\\( 0.66761 \\)</td><td style="border: 1px solid black;">\\( 0.66769 \\)</td>
        </tr>
</tbody>
</table>
			`},
                        {
                            "id": 8,
                            "content": ` <table align="center" border="1" cellpadding="5" cellspacing="0" style="border-collapse: collapse;">
    <tbody>
         <tr>
            <td style="border: 1px solid black;">\\(x\\)</td><td style="border: 1px solid black;">\\( 0.251 \\)</td><td style="border: 1px solid black;">\\( 0.254 \\)</td><td style="border: 1px solid black;">\\( 0.257 \\)</td><td style="border: 1px solid black;">\\( 0.260 \\)</td><td style="border: 1px solid black;">\\(0,263\\)</td>
        </tr>
        <tr>
            <td style="border: 1px solid black;">\\(y\\)</td><td style="border: 1px solid black;">\\( 0.24837 \\)</td><td style="border: 1px solid black;">\\( 0.25128 \\)</td><td style="border: 1px solid black;">\\( 0.25418 \\)</td><td style="border: 1px solid black;">\\( 0.25708 \\)</td><td style="border: 1px solid black;">\\( 0.25718 \\)</td>
        </tr>
</tbody>
</table>
			`},
                        {
                            "id": 9,
                            "content": ` <table align="center" border="1" cellpadding="5" cellspacing="0" style="border-collapse: collapse;">
    <tbody>
        <tr>
            <td style="border: 1px solid black;">\\(x\\)</td><td style="border: 1px solid black;">\\( 0.341 \\)</td><td style="border: 1px solid black;">\\( 0.343 \\)</td><td style="border: 1px solid black;">\\( 0.345 \\)</td><td style="border: 1px solid black;">\\( 0.347 \\)</td><td style="border: 1px solid black;">\\( 0.349 \\)</td>
        </tr>
        <tr>
            <td style="border: 1px solid black;">\\(y\\)</td><td style="border: 1px solid black;">\\( 2.19280 \\)</td><td style="border: 1px solid black;">\\( 2.20293 \\)</td><td style="border: 1px solid black;">\\( 2.21309 \\)</td><td style="border: 1px solid black;">\\( 2.22331 \\)</td><td style="border: 1px solid black;">\\( 2.23347 \\)</td>
        </tr>
</tbody>
</table>
			`},
                        {
                            "id": 10,
                            "content": ` <table align="center" border="1" cellpadding="5" cellspacing="0" style="border-collapse: collapse;">
    <tbody>
        <tr>
            <td style="border: 1px solid black;">\\(x\\)</td><td style="border: 1px solid black;">\\( 0.112 \\)</td><td style="border: 1px solid black;">\\( 0.113 \\)</td><td style="border: 1px solid black;">\\( 0.114 \\)</td><td style="border: 1px solid black;">\\( 0.115 \\)</td><td style="border: 1px solid black;">\\( 0.116 \\)</td>
        </tr>
        <tr>
            <td style="border: 1px solid black;">\\(y\\)</td><td style="border: 1px solid black;">\\( 1.29419 \\)</td><td style="border: 1px solid black;">\\( 1.29718 \\)</td><td style="border: 1px solid black;">\\( 1.30017 \\)</td><td style="border: 1px solid black;">\\( 1.30317 \\)</td><td style="border: 1px solid black;">\\( 1.30616 \\)</td>
        </tr>
</tbody>
</table>
			`},
                        {
                            "id": 11,
                            "content": ` <table align="center" border="1" cellpadding="5" cellspacing="0" style="border-collapse: collapse;">
    <tbody>
        <tr>
            <td style="border: 1px solid black;">\\(x\\)</td><td style="border: 1px solid black;">\\( 0.119 \\)</td><td style="border: 1px solid black;">\\( 0.121 \\)</td><td style="border: 1px solid black;">\\( 0.123 \\)</td><td style="border: 1px solid black;">\\( 0.125 \\)</td><td style="border: 1px solid black;">\\( 0.127 \\)</td>
        </tr>
        <tr>
            <td style="border: 1px solid black;">\\(y\\)</td><td style="border: 1px solid black;">\\( 1.31522 \\)</td><td style="border: 1px solid black;">\\( 1.32130 \\)</td><td style="border: 1px solid black;">\\( 1.32730 \\)</td><td style="border: 1px solid black;">\\( 1.33353 \\)</td><td style="border: 1px solid black;">\\( 1.33970 \\)</td>
        </tr>
</tbody>
</table>
			`},
                        {
                            "id": 12,
                            "content": ` <table align="center" border="1" cellpadding="5" cellspacing="0" style="border-collapse: collapse;">
    <tbody>
        <tr>
            <td style="border: 1px solid black;">\\(x\\)</td><td style="border: 1px solid black;">\\( 0.441 \\)</td><td style="border: 1px solid black;">\\( 0.445 \\)</td><td style="border: 1px solid black;">\\( 0.449 \\)</td><td style="border: 1px solid black;">\\(0,453\\)</td><td style="border: 1px solid black;">\\(0,457\\)</td>
        </tr>
        <tr>
            <td style="border: 1px solid black;">\\(y\\)</td><td style="border: 1px solid black;">\\( 2.76058 \\)</td><td style="border: 1px solid black;">\\( 2.78612 \\)</td><td style="border: 1px solid black;">\\( 2.81190 \\)</td><td style="border: 1px solid black;">\\( 2.83792 \\)</td><td style="border: 1px solid black;">\\( 2.86226 \\)</td>
        </tr>
</tbody>
</table>
			`},
                        {
                            "id": 13,
                            "content": ` <table align="center" border="1" cellpadding="5" cellspacing="0" style="border-collapse: collapse;">
    <tbody>
        <tr>
            <td style="border: 1px solid black;">\\(x\\)</td><td style="border: 1px solid black;">\\( 0.117 \\)</td><td style="border: 1px solid black;">\\( 0.122 \\)</td><td style="border: 1px solid black;">\\( 0.127 \\)</td><td style="border: 1px solid black;">\\( 0.132 \\)</td><td style="border: 1px solid black;">\\( 0.137 \\)</td>
        </tr>
        <tr>
            <td style="border: 1px solid black;">\\(y\\)</td><td style="border: 1px solid black;">\\( 1.30918 \\)</td><td style="border: 1px solid black;">\\( 1.32434 \\)</td><td style="border: 1px solid black;">\\( 1.33968 \\)</td><td style="border: 1px solid black;">\\( 1.35519 \\)</td><td style="border: 1px solid black;">\\( 1.37068 \\)</td>
        </tr>
</tbody>
</table>
			`},
                        {
                            "id": 14,
                            "content": ` <table align="center" border="1" cellpadding="5" cellspacing="0" style="border-collapse: collapse;">
    <tbody>
        <tr>
            <td style="border: 1px solid black;">\\(x\\)</td><td style="border: 1px solid black;">\\( 0.750 \\)</td><td style="border: 1px solid black;">\\( 0.751 \\)</td><td style="border: 1px solid black;">\\( 0.752 \\)</td><td style="border: 1px solid black;">\\( 0.753 \\)</td><td style="border: 1px solid black;">\\( 0.754 \\)</td>
        </tr>
        <tr>
            <td style="border: 1px solid black;">\\(y\\)</td><td style="border: 1px solid black;">\\( 5.62341 \\)</td><td style="border: 1px solid black;">\\( 5.63638 \\)</td><td style="border: 1px solid black;">\\( 5.64937 \\)</td><td style="border: 1px solid black;">\\( 5.66239 \\)</td><td style="border: 1px solid black;">\\( 5.67535 \\)</td>
        </tr>
</tbody>
</table>
			`},
                        {
                            "id": 15,
                            "content": ` <table align="center" border="1" cellpadding="5" cellspacing="0" style="border-collapse: collapse;">
    <tbody>
         <tr>
            <td style="border: 1px solid black;">\\(x\\)</td><td style="border: 1px solid black;">\\( 0.261 \\)</td><td style="border: 1px solid black;">\\( 0.263 \\)</td><td style="border: 1px solid black;">\\( 0.265 \\)</td><td style="border: 1px solid black;">\\( 0.267 \\)</td><td style="border: 1px solid black;">\\( 0.269 \\)</td>
        </tr>
        <tr>
            <td style="border: 1px solid black;">\\(y\\)</td><td style="border: 1px solid black;">\\( 1.82390 \\)</td><td style="border: 1px solid black;">\\( 1.83231 \\)</td><td style="border: 1px solid black;">\\( 1.84077 \\)</td><td style="border: 1px solid black;">\\( 1.84927 \\)</td><td style="border: 1px solid black;">\\( 1.85776 \\)</td>
        </tr>
</tbody>
</table>
			`},
                        {
                            "id": 16,
                            "content": ` <table align="center" border="1" cellpadding="5" cellspacing="0" style="border-collapse: collapse;">
    <tbody>
        <tr>
            <td style="border: 1px solid black;">\\(x\\)</td><td style="border: 1px solid black;">\\( 0.271 \\)</td><td style="border: 1px solid black;"> \\( 0.273 \\)</td><td style="border: 1px solid black;"> \\( 0.275 \\)</td><td style="border: 1px solid black;"> \\( 0.277 \\)</td><td style="border: 1px solid black;"> \\( 0.279 \\)</td>
        </tr>
        <tr>
            <td style="border: 1px solid black;">\\(y\\)</td><td style="border: 1px solid black;">\\( 1.86638 \\)</td><td style="border: 1px solid black;">\\( 1.87499 \\)</td><td style="border: 1px solid black;">\\( 1.88365 \\)</td><td style="border: 1px solid black;">\\( 1.89234 \\)</td><td style="border: 1px solid black;">\\( 1.90169 \\)</td>
        </tr>
</tbody>
</table>
			`},
                        {
                            "id": 17,
                            "content": ` <table align="center" border="1" cellpadding="5" cellspacing="0" style="border-collapse: collapse;">
    <tbody>
        <tr>
            <td style="border: 1px solid black;">\\(x\\)</td><td style="border: 1px solid black;">\\( 0.281 \\)</td><td style="border: 1px solid black;">\\( 0.283 \\)</td><td style="border: 1px solid black;">\\( 0.285 \\)</td><td style="border: 1px solid black;">\\( 0.287 \\)</td><td style="border: 1px solid black;">\\( 0.289 \\)</td>
        </tr>
        <tr>
            <td style="border: 1px solid black;">\\(y\\)</td><td style="border: 1px solid black;">\\( 1.90985 \\)</td><td style="border: 1px solid black;">\\( 1.91867 \\)</td><td style="border: 1px solid black;">\\( 1.92752 \\)</td><td style="border: 1px solid black;">\\( 1.93642 \\)</td><td style="border: 1px solid black;">\\( 1.94421 \\)</td>
        </tr>
</tbody>
</table>
			`},
                        {
                            "id": 18,
                            "content": ` <table align="center" border="1" cellpadding="5" cellspacing="0" style="border-collapse: collapse;">
    <tbody>
        <tr>
            <td style="border: 1px solid black;">\\(x\\)</td><td style="border: 1px solid black;">\\( 0.291 \\)</td><td style="border: 1px solid black;">\\( 0.293 \\)</td><td style="border: 1px solid black;">\\( 0.295 \\)</td><td style="border: 1px solid black;">\\( 0.297 \\)</td><td style="border: 1px solid black;">\\( 0.299 \\)</td>
        </tr>
        <tr>
            <td style="border: 1px solid black;">\\(y\\)</td><td style="border: 1px solid black;">\\( 1.96434 \\)</td><td style="border: 1px solid black;">\\( 1.96336 \\)</td><td style="border: 1px solid black;">\\( 1.97242 \\)</td><td style="border: 1px solid black;">\\( 1.98155 \\)</td><td style="border: 1px solid black;">\\( 1.99043 \\)</td>
        </tr>
</tbody>
</table>
			`},
                        {
                            "id": 19,
                            "content": ` <table align="center" border="1" cellpadding="5" cellspacing="0" style="border-collapse: collapse;">
    <tbody>
        <tr>
            <td style="border: 1px solid black;">\\(x\\)</td><td style="border: 1px solid black;">\\(0,501\\)</td><td style="border: 1px solid black;">\\(0,503\\)</td><td style="border: 1px solid black;">\\(0,505\\)</td><td style="border: 1px solid black;">\\(0,507\\)</td><td style="border: 1px solid black;">\\(0,509\\)</td>
        </tr>
        <tr>
            <td style="border: 1px solid black;">\\(y\\)</td><td style="border: 1px solid black;">\\( 3.16957 \\)</td><td style="border: 1px solid black;">\\( 3.18420 \\)</td><td style="border: 1px solid black;">\\( 3.19889 \\)</td><td style="border: 1px solid black;">\\( 3.21366 \\)</td><td style="border: 1px solid black;">\\( 3.22821 \\)</td>
        </tr>
</tbody>
</table>
			`},
                        {
                            "id": 20,
                            "content": ` <table align="center" border="1" cellpadding="5" cellspacing="0" style="border-collapse: collapse;">
    <tbody>
        <tr>
            <td style="border: 1px solid black;">\\(x\\)</td><td style="border: 1px solid black;">\\( 0.511 \\)</td><td style="border: 1px solid black;">\\( 0.513 \\)</td><td style="border: 1px solid black;">\\( 0.515 \\)</td><td style="border: 1px solid black;">\\( 0.517 \\)</td><td style="border: 1px solid black;">\\( 0.519 \\)</td>
        </tr>
        <tr>
            <td style="border: 1px solid black;">\\(y\\)</td><td style="border: 1px solid black;">\\( 3.24340 \\)</td><td style="border: 1px solid black;">\\( 3.33426 \\)</td><td style="border: 1px solid black;">\\( 3.27341 \\)</td><td style="border: 1px solid black;"> \\( 3.28851 \\)</td><td style="border: 1px solid black;">\\( 3.29573 \\)</td>
        </tr>
</tbody>
</table>
			`}
                ]
            }]
        };
        if (JSON_content.topic08.practica && JSON_content.topic08.practica.includes('"assignments":')) {
            JSON_content.topic08.practica = JSON_content.topic08.practica.split('"assignments":')[0].trim();
        }
    }


if (JSON_content.topic09 && !JSON_content.topic09.practicaData) {
        JSON_content.topic09.practicaData = {
            assignments: [{
                title: "Задание 1",
                description: `
	<p>Найти приближенное значение интеграла заданной функции \\( f(x) \\) на отрезке \\( [a, b] \\) методами прямоугольников, трапеций, парабол при делении отрезка на \\( 100 \\) равных частей, произвести оценку погрешности.</p>
`,
                variants: [
                    {
                            "id": 1,
                            "content": "<p>Дана функция \\( \\sqrt{1 + \\cos^2 x} \\) на отрезке \\( [0; 3] \\) .</p>"
                        },
                        {
                            "id": 2,
                            "content": "<p>Дана функция \\( \\sin(2x^2 + 1) \\) на отрезке \\( [0; 1] \\) .</p>"
                        },
                        {
                            "id": 3,
                            "content": "<p>Дана функция \\( (x + 1.9)\\sin\\left(\\dfrac{x}{3}\\right) \\) на отрезке \\( [1; 2] \\) .</p>"
                        },
                        {
                            "id": 4,
                            "content": "<p>Дана функция \\( \\dfrac{1}{x} \\ln(x + 2) \\) на отрезке \\( [2; 3] \\) .</p>"
                        },
                        {
                            "id": 5,
                            "content": "<p>Дана функция \\( x^2 \\cos\\left(\\dfrac{x}{4}\\right) \\) на отрезке \\( [2; 3] \\) .</p>"
                        },
                        {
                            "id": 6,
                            "content": "<p>Дана функция \\( 3x + \\ln x \\) на отрезке \\( [1; 2] \\) .</p>"
                        },
                        {
                            "id": 7,
                            "content": "<p>Дана функция \\( x^2 \\tan \\left( \\dfrac{x}{2} \\right) \\) на отрезке \\( [1.5; 2.5] \\) .</p>"
                        },
                        {
                            "id": 8,
                            "content": "<p>Дана функция \\( \\dfrac{e^x}{x} \\) на отрезке \\( [1; 7] \\) .</p>"
                        },
                        {
                            "id": 9,
                            "content": "<p>Дана функция \\( \\dfrac{1}{x^2 + 1} \\) на отрезке \\( [0; 1] \\) .</p>"
                        },
                        {
                            "id": 10,
                            "content": "<p>Дана функция \\( \\sqrt{4 + x^4} \\) на отрезке \\( [0; 3] \\) .</p>"
                        },
                        {
                            "id": 11,
                            "content": "<p>Дана функция \\( \\sqrt{1 + \\cos^2 x} \\) на отрезке \\( [0; \\pi] \\) .</p>"
                        },
                        {
                            "id": 12,
                            "content": "<p>Дана функция \\( e^x \\sin(x^2) \\) на отрезке \\( [0; 5] \\) .</p>"
                        },
                        {
                            "id": 13,
                            "content": "<p>Дана функция \\( \\dfrac{\\cos x}{\\sqrt{1+x^2}} \\) на отрезке \\( [0; 2] \\) .</p>"
                        },
                        {
                            "id": 14,
                            "content": "<p>Дана функция \\( x e^{-x^2} \\) на отрезке \\( [0; 2] \\) .</p>"
                        },
                        {
                            "id": 15,
                            "content": "<p>Дана функция \\( \\ln(1 + \\sqrt{x}) \\) на отрезке \\( [0; 4] \\) .</p>"
                        },
                        {
                            "id": 16,
                            "content": "<p>Дана функция \\( \\sin(\\sqrt{x}) \\) на отрезке \\( [0; \\pi^2] \\) .</p>"
                        },
                        {
                            "id": 17,
                            "content": "<p>Дана функция \\( \\dfrac{\\arctan x}{1+x^2} \\) на отрезке \\( [0; 1] \\) .</p>"
                        },
                        {
                            "id": 18,
                            "content": "<p>Дана функция \\( x \\sin(\\pi x) \\) на отрезке \\( [0; 2] \\) .</p>"
                        },
                        {
                            "id": 19,
                            "content": "<p>Дана функция \\( \\sqrt{x} \\ln(1+x) \\) на отрезке \\( [0; 2] \\) .</p>"
                        },
                        {
                            "id": 20,
                            "content": "<p>Дана функция \\( e^{-x} \\cos(2x) \\) на отрезке \\( [0; \\pi] \\) .</p>"
                        }
                ]
            }]
        };
        
        if (JSON_content.topic09.practica && JSON_content.topic09.practica.includes('"assignments":')) {
            JSON_content.topic09.practica = JSON_content.topic09.practica.split('"assignments":')[0].trim();
        }
    }
}